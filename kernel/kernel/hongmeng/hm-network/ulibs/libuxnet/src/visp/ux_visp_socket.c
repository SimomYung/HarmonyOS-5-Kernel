/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
 * Description: interface for network visp socket
 * Author: Huawei OS Kernel Lab
 * Create: Sat May  8 16:17:22 2021
 */

#include <sys/ioctl.h>

#include <libhmlog/hmlog.h>
#include <libhmsync/raw_thread.h>

#include "security/raw_socket.h"
#include "ux_compat.h"
#include "ux_domain.h"
#include "ux_sockopt.h"
#include "ux_eventpoll.h"
#include "ux_ioctl.h"
#include "ux_libvisp.h"
#include "ux_visp_arp.h"

#include <visp_socket.h>

static void visp_update_fd_events(ux_visp_sock_t *visp_sock, uint32_t old_event);

static void visp_sock_release(struct ux_sock *sk)
{
	ux_visp_sock_t *visp_sock = container_of(sk, ux_visp_sock_t, sk);

	free(visp_sock);
}

static int visp_inet_getsockevent(ux_sock_t *sk, unsigned int *rcvev, unsigned int *sendev, unsigned int *errev)
{
	ux_visp_sock_t *visp_sock = container_of(sk, ux_visp_sock_t, sk);
	unsigned int ev_read = 0;
	unsigned int ev_write = 0;
	unsigned int ev_error = 0;
	int ret;

	ret = visp_getevents(visp_sock->fd, &ev_read, &ev_write, &ev_error);
	if (ret != 0) {
		net_warn(HMNET_INET, "visp get events for epoll failed\n");
	}

	if (ev_read != 0) {
		*rcvev |= EPOLLIN;
	}

	if (ev_write != 0) {
		*sendev |= EPOLLOUT;
	}

	if (ev_error != 0) {
		*errev |= EPOLLERR;
	}

	return E_HM_OK;
}

static inline ux_visp_sock_t *visp_sk(ux_sock_t *sk)
{
	return (ux_visp_sock_t *)(void *)sk;
}

static ux_visp_sock_t *visp_sock_alloc_and_init(ux_socket_t *socket, int domain, int type, int protocol)
{
	ux_visp_sock_t *sock = visp_sk(ux_sock_alloc(socket, sizeof(ux_visp_sock_t), 0));

	if (sock != NULL) {
		ux_sock_init(&sock->sk, NULL, domain, type, protocol);

		sock->sk.release = visp_sock_release;
		sock->sk.getsockevent = visp_inet_getsockevent;
		sock->fd = -1;
	}

	return sock;
}

static ux_visp_sock_t *visp_sock_from_socket(const ux_socket_t *sock)
{
	ux_sock_t *sk = ux_socket_get_sock(sock);

	return container_of(sk, ux_visp_sock_t, sk);
}

static int visp_set_nonblock(int fd)
{
	int value = 1;
	return visp_ioctl(fd, FIONBIO, &value);
}

static int visp_inet_close(ux_socket_t *sock)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);
	int ret;

	ux_set_sock_flags(&visp_sock->sk, SOCK_DEAD);
	ret = visp_close(visp_sock->fd);

	ux_sock_put(&visp_sock->sk);
	return ret;
}

static int visp_inet_connect_handler(ux_socket_t *sock, const struct sockaddr *addr,
			     socklen_t addrlen)
{
	int ret = E_HM_OK;
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);

	ret = visp_connect(visp_sock->fd, addr, addrlen);
	if (ret != E_HM_OK) {
		return ret;
	}
	/*
	 * generate POLLOUT after connect because
	 * it won't be generated by vrp_select with an initialized socket
	 */
	visp_update_fd_events(visp_sock, EPOLLOUT);
	return E_HM_OK;
}

static int visp_inet_connect(ux_socket_t *sock, const struct sockaddr *addr, socklen_t addrlen)
{
	return socket_connect_wrapper(sock, addr, addrlen, visp_inet_connect_handler);
}

static int visp_inet_bind_handler(ux_socket_t *sock, const struct sockaddr *addr,
			  socklen_t addrlen)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);

	return visp_bind(visp_sock->fd, addr, addrlen);
}

static int visp_inet_bind(ux_socket_t *sock, const struct sockaddr *addr, socklen_t addrlen)
{
	return socket_bind_wrapper(sock, addr, addrlen, visp_inet_bind_handler);
}

static int visp_inet_listen(ux_socket_t *sock, int backlog)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);

	return visp_listen(visp_sock->fd, backlog);
}

static int visp_inet_accept(ux_socket_t *sock, ux_socket_t *nsock,
			    struct sockaddr *addr, socklen_t *addrlen,
			    int flags)
{
	ux_visp_sock_t *s_visp_sock = visp_sock_from_socket(sock);
	ux_visp_sock_t *c_visp_sock = visp_sock_alloc_and_init(sock, s_visp_sock->sk.socket_domain, s_visp_sock->sk.type,
									s_visp_sock->sk.socket_protocol);
	int ret = E_HM_OK;
	int cfd = -1;

	if (c_visp_sock == NULL) {
		ret = E_HM_NOMEM;
	} else {
		cfd = visp_accept(s_visp_sock->fd, addr, addrlen);
		if (cfd < 0) {
			ret = cfd;
		}
	}

	if (ret == E_HM_OK) {
		if (flags & SOCK_NONBLOCK) {
			ret = visp_set_nonblock(cfd);
		}
	}

	if (ret == E_HM_OK) {
		ret = visp_setuserdata(cfd, &c_visp_sock->sk.epoll_ctx);
	}

	if (ret == E_HM_OK) {
		c_visp_sock->fd = cfd;

		ux_socket_set_sock(nsock, &c_visp_sock->sk);

		nsock->ops = sock->ops;
		visp_update_fd_events(s_visp_sock, EPOLLIN);

		if (flags & SOCK_NONBLOCK) {
			(void)socket_fcntl(nsock, F_SETFL, O_NONBLOCK);
		}
	} else {
		if (cfd >= 0) {
			visp_close(cfd);
		}

		if (c_visp_sock != NULL) {
			free(c_visp_sock);
		}
	}

	return ret;
}

static int visp_inet_shutdown(ux_socket_t *sock, int how)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);

	return visp_shutdown(visp_sock->fd, how);
}

static int visp_inet_ioctl(ux_socket_t *sock, int cmd, uintptr_t args_u)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);
	void *arg_buf = NULL;
	int cmdlen = 0;
	int ret;

	cmdlen = ux_ioctl_cmdlen(cmd);
	if (cmdlen < 0) {
		return cmdlen;
	}

	arg_buf = calloc(1, (size_t)(unsigned int)cmdlen + 1);
	if (arg_buf == NULL) {
		return E_HM_NOMEM;
	}

	if (hm_actv_read_xact_vm(arg_buf, (void *)args_u,
				 (unsigned long)(unsigned int)cmdlen)) {
		ret = E_HM_POSIX_FAULT;
		goto out;
	}

	switch (cmd) {
	case SIOCDARP:
	case SIOCGARP:
	case SIOCSARP:
		ret = visp_arp_ioctl(cmd, (struct arpreq*)arg_buf);
		break;
	default:
		ret = visp_ioctl(visp_sock->fd, cmd, arg_buf);
		break;
	}

	if (ret < 0) {
		goto out;
	}

	if (hm_actv_write_xact_vm((void *)args_u, arg_buf,
				  (unsigned long)(unsigned int)cmdlen)) {
		ret = E_HM_POSIX_FAULT;
	}
out:
	free(arg_buf);
	return ret;
}

static int visp_inet_fcntl(ux_socket_t *sock, int cmd, int arg)
{
	ux_sock_t *sk = NULL;
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);
	unsigned int uarg = (unsigned int)arg;
	int ret = E_HM_OK;

	sk = ux_socket_get_sock(sock);
	if (sk == NULL) {
		return E_HM_INVAL;
	}

	switch (cmd) {
	case F_GETFL:
		ret = (int)sk->noblock;
		break;
	case F_SETFL:
		/* noblock work when O_NONBLOCK == SOCK_NONBLOCK */
		uarg = sock_remove_ignored_fflags(uarg);
		if (!sock_if_fflags_supported(uarg)) {
			ret = E_HM_INVAL;
			break;
		}

		if ((uarg & O_NONBLOCK) != 0) {
			ret = visp_set_nonblock(visp_sock->fd);
			if (ret != E_HM_OK) {
				break;
			}
		}

		sk->noblock = sock_enable_supported_fflags(sk->noblock, uarg);
		break;
	default:
		ret = E_HM_INVAL;
		break;
	}
	return ret;
}

static ssize_t visp_send_handler(ux_socket_t *sock, const void *buf, size_t len, int flags)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);
	ssize_t ret;

	ret = visp_send(visp_sock->fd, buf, len, flags);

	visp_update_fd_events(visp_sock, EPOLLOUT);

	return ret;
}

static ssize_t visp_inet_send(ux_socket_t *sock, const void *buf, size_t len, int flags)
{
	return socket_send_wrapper(sock, buf, len, flags, visp_send_handler);
}

static ssize_t visp_inet_recv(ux_socket_t *sock, void *buf, size_t len,
			      int flags)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);
	ssize_t ret;

	ret = visp_recv(visp_sock->fd, buf, len, flags);

	visp_update_fd_events(visp_sock, EPOLLIN);

	return ret;
}

static ssize_t visp_sendmsg_handler(ux_socket_t *sock, const struct msghdr *msg, int flags)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);
	ssize_t ret;

	ret = visp_sendmsg(visp_sock->fd, msg, flags);

	visp_update_fd_events(visp_sock, EPOLLOUT);

	return ret;
}

static ssize_t visp_inet_sendmsg(ux_socket_t *sock, const struct msghdr *msg, int flags)
{
	return socket_sendmsg_wrapper(sock, msg, flags, visp_sendmsg_handler);
}

static ssize_t visp_recvmsg_handler(ux_socket_t *sock, struct msghdr *msg, int flags)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);
	int ret;

	if (!is_recv_flag_valid((unsigned int)flags)) {
		return E_HM_INVAL;
	}

	ret = visp_recvmsg(visp_sock->fd, msg, flags);

	visp_update_fd_events(visp_sock, EPOLLIN);

	return ret;
}

static ssize_t visp_inet_recvmsg(ux_socket_t *sock, struct msghdr *msg, int flags)
{
	return socket_recvmsg_wrapper(sock, msg, flags, visp_recvmsg_handler);
}

static ssize_t visp_sendto_handler(ux_socket_t *sock, const void *buf, size_t len,
			   int flags, const struct sockaddr *daddr,
			   socklen_t addrlen)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);
	ssize_t ret;

	ret = visp_sendto(visp_sock->fd, buf, len, flags, daddr, addrlen);

	visp_update_fd_events(visp_sock, EPOLLOUT);

	return ret;
}

static ssize_t visp_inet_sendto(ux_socket_t *sock, const void *buf, size_t len,
			   int flags, const struct sockaddr *daddr,
			   socklen_t addrlen)
{
	return socket_sendto_wrapper(sock, buf, len, flags, daddr, addrlen,
				     visp_sendto_handler);
}

static ssize_t visp_recvfrom_handler(ux_socket_t *sock, void *buf, size_t len, int flags,
			     struct sockaddr *saddr, socklen_t *addrlen)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);
	ssize_t ret;

	ret = visp_recvfrom(visp_sock->fd, buf, len, flags, saddr, addrlen);

	visp_update_fd_events(visp_sock, EPOLLIN);

	return ret;
}

static ssize_t visp_inet_recvfrom(ux_socket_t *sock, void *buf, size_t len, int flags,
			     struct sockaddr *saddr, socklen_t *addrlen)
{
	return socket_recvfrom_wrapper(sock, buf, len, flags, saddr, addrlen,
				       visp_recvfrom_handler);
}

static ssize_t visp_inet_writev(ux_socket_t *sock, const struct iovec *iov, int iovcnt, int flags)
{
	UNUSED(flags);
	return socket_writev_wrapper(sock, iov, iovcnt, visp_sendmsg_handler);
}

static ssize_t visp_inet_readv(ux_socket_t *sock, const struct iovec *iov, int iovcnt)
{
	return socket_readv_wrapper(sock, iov, iovcnt, visp_recvmsg_handler);
}

struct ip_mreq_intf {
	struct in_addr imrif_mcastaddr;
	unsigned int imrif_ifno;
};

static unsigned int visp_ip_from_netif(unsigned int ifindex)
{
	unsigned int s_addr;
	struct sockaddr_in sockaddr;

	visp_get_ip(ifindex, &sockaddr);
	s_addr = sockaddr.sin_addr.s_addr;

	return s_addr;
}

static int visp_inet_getsockopt(ux_socket_t *sock, int level, int optname,
				void *optval, socklen_t *optlen)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);
	void *buf = NULL;
	socklen_t len = 0;
	int optname_tmp = optname;
	int ret = 0;

	if (hm_actv_read_xact_vm(&len, optlen, sizeof(socklen_t)) || optval == NULL) {
		return E_HM_POSIX_FAULT;
	}

	if (len > UX_MAX_SOCKOPT_LEN) {
		return E_HM_INVAL;
	}

	buf = calloc(1, UX_MAX_SOCKOPT_LEN);
	if (buf == NULL) {
		return E_HM_NOMEM;
	}

	if (ux_is_compat_client() &&
	    (optname == SO_RCVTIMEO_NEW || optname == SO_SNDTIMEO_NEW)) {
	    optname_tmp = optname - (SO_RCVTIMEO_NEW - SO_RCVTIMEO_OLD);
	}

	if (hm_actv_read_xact_vm(buf, optval, len)) {
		free(buf);
		return E_HM_FAULT;
	}

	ret = visp_getsockopt(visp_sock->fd, level, optname_tmp, buf, &len);
	if (ret < 0) {
		free(buf);
		return ret;
	}

	if (optname == SO_RCVTIMEO || optname == SO_SNDTIMEO) {
		/* In both 32-bit and 64-bit VISPs, only the int type is required. */
		struct timeval32 tv32 = *(struct timeval32 *)buf;
		struct timeval *tv = buf;

		tv->tv_sec = (long)tv32.tv_sec;
		tv->tv_usec = (long)tv32.tv_usec;
		len = sizeof(struct timeval);
	}

	/* get index from visp, we need change it to ip addr. */
	if (optname == IP_MULTICAST_IF) {
		*((unsigned int *)buf) = visp_ip_from_netif(*((unsigned int *)buf));
	}

	/* get index from visp, we need change it to ip addr. */
	if (optname == IP_ADD_MEMBERSHIP) {
		struct ip_mreq *mreq = buf;
		struct ip_mreq_intf *mreq_intf = buf;
		mreq->imr_interface.s_addr = visp_ip_from_netif(mreq_intf->imrif_ifno);
	}

	if (hm_actv_write_xact_vm(optlen, &len, sizeof(socklen_t)) || hm_actv_write_xact_vm(optval, buf, len)) {
		free(buf);
		return E_HM_POSIX_FAULT;
	}

	free(buf);
	return ret;
}

struct if_ip {
	uint32_t dst_addr;
	unsigned int *ifindex;
};

static int iter_addr_callback(struct visp_if_addr *addr, void *data)
{
	struct if_ip *args = (struct if_ip *)data;

	if ((args->dst_addr & addr->mask) == (addr->ip & addr->mask)) {
		return 1;
	}

	return 0;
}

static int iter_device_callback(const ux_netdev_t *dev, void *data)
{
	struct netif *nif = ux_netdev_priv(dev);

	if (visp_for_each_addr(nif->ifindex, iter_addr_callback, data) != 0) {
		struct if_ip *args = (struct if_ip *)data;
		*(args->ifindex) = nif->ifindex;
		return 1;
	} else {
		return 0;
	}
}

static int visp_netif_from_ip(unsigned int *ifindex, unsigned int ip_addr)
{
	struct if_ip args = {ip_addr, ifindex};

	return ux_netdev_for_each_device(iter_device_callback, &args);
}

static int visp_inet_setsockopt(ux_socket_t *sock, int level, int optname,
				const void *optval, socklen_t optlen)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);
	void *buf = NULL;
	int ret = 0;

	if (optlen > UX_MAX_SOCKOPT_LEN) {
		return E_HM_INVAL;
	}

	buf = calloc(1, UX_MAX_SOCKOPT_LEN);
	if (buf == NULL) {
		return E_HM_NOMEM;
	}

	if (hm_actv_read_xact_vm(buf, optval, optlen)) {
		free(buf);
		return E_HM_POSIX_FAULT;
	}

	if (ux_is_compat_client() &&
	    (optname == SO_RCVTIMEO_NEW || optname == SO_SNDTIMEO_NEW)) {
		optname = optname - (SO_RCVTIMEO_NEW - SO_RCVTIMEO_OLD);
	} else if (optname == SO_RCVTIMEO_NEW || optname == SO_SNDTIMEO_NEW) {
		free(buf);
		return E_HM_NOPROTOOPT;
	} else if (optname == SO_RCVTIMEO || optname == SO_SNDTIMEO) {
		/* In both 32-bit and 64-bit VISPs, only the int type is required. */
		struct timeval tv = *(struct timeval *)buf;
		struct timeval32 *tv32 = buf;

		tv32->tv_sec = (int)tv.tv_sec;
		tv32->tv_usec = (int)tv.tv_usec;
		optlen = sizeof(struct timeval32);
	} else if (optname == IP_MULTICAST_IF) {
		/* visp need index, so wo must change ip addr to if index. */
		unsigned int *ifindex = buf;
		struct in_addr *local_addr = buf;
		if (visp_netif_from_ip(ifindex, local_addr->s_addr) == 0) {
			free(buf);
			return E_HM_INVAL;
		}
	} else if (optname == IP_ADD_MEMBERSHIP) {
		/* visp need index, so wo must change ip addr to if index. */
		struct ip_mreq *mreq = buf;
		struct ip_mreq_intf *mreq_intf = buf;
		if (visp_netif_from_ip(&mreq_intf->imrif_ifno, mreq->imr_interface.s_addr) == 0) {
			free(buf);
			return E_HM_INVAL;
		}
	}

	ret = visp_setsockopt(visp_sock->fd, level, optname, buf, optlen);

	free(buf);
	return ret;
}

static int visp_inet_getsockname(ux_socket_t *sock, struct sockaddr *addr,
				 socklen_t *addrlen)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);

	return visp_getsockname(visp_sock->fd, addr, addrlen);
}

static int visp_inet_getpeername(ux_socket_t *sock, struct sockaddr *addr,
				 socklen_t *addrlen)
{
	ux_visp_sock_t *visp_sock = visp_sock_from_socket(sock);

	return visp_getpeername(visp_sock->fd, addr, addrlen);
}

void visp_event_notify_hook(int fd, struct visp_event_notify_args *args)
{
	void *epoll_info = NULL;
	unsigned int event = 0;
	int ret;

	if (args == NULL) {
		return;
	}

	ret = visp_getuserdata(fd, &epoll_info);
	if (ret != 0 || epoll_info == NULL) {
		return;
	}

	if ((args->event & VISP_EVENT_READ) != 0) {
		event |= EPOLLIN;
	}

	if ((args->event & VISP_EVENT_WRITE) != 0) {
		event |= EPOLLOUT;
	}

	if ((args->event & VISP_EVENT_ERROR) != 0) {
		event |= EPOLLERR;
	}

	ux_epoll_wakeup_clean(epoll_info, event);
}

static void visp_update_fd_events(ux_visp_sock_t *visp_sock, uint32_t old_event)
{
	unsigned int ev_read = 0;
	unsigned int ev_write = 0;
	unsigned int ev_error = 0;
	uint32_t events = 0;
	int ret;

	ret = visp_getevents(visp_sock->fd, &ev_read, &ev_write, &ev_error);
	if (ret != 0) {
		net_warn(HMNET_INET, "visp get events for epoll failed\n");
		return;
	}

	if (ev_read != 0) {
		events |= EPOLLIN;
	}

	if (ev_write != 0) {
		events |= EPOLLOUT;
	}

	if (ev_error != 0) {
		events |= EPOLLERR;
	}

	ux_epoll_wakeup_clean(&visp_sock->sk.epoll_ctx, old_event << CLEAN_EVENT_SHIFT);
	ux_epoll_wakeup_clean(&visp_sock->sk.epoll_ctx, events);
}

static ux_proto_ops_t visp_inet_ops = {
	.socketpair = NULL,
	.close = visp_inet_close,
	.connect = visp_inet_connect,
	.bind = visp_inet_bind,
	.listen = visp_inet_listen,
	.accept = visp_inet_accept,
	.shutdown = visp_inet_shutdown,
	.ioctl = visp_inet_ioctl,
	.fcntl = visp_inet_fcntl,
	.send = visp_inet_send,
	.recv = visp_inet_recv,
	.sendmmsg = NULL,
	.recvmmsg = NULL,
	.sendmsg = visp_inet_sendmsg,
	.recvmsg = visp_inet_recvmsg,
	.sendto = visp_inet_sendto,
	.recvfrom = visp_inet_recvfrom,
	.writev = visp_inet_writev,
	.readv = visp_inet_readv,
	.getsockopt = visp_inet_getsockopt,
	.setsockopt = visp_inet_setsockopt,
	.getsockname = visp_inet_getsockname,
	.getpeername = visp_inet_getpeername,
	.check_perm = NULL,
#ifdef CONFIG_LSYSCALL_ENABLED
	.epoll_recheck_revents = NULL,
#endif  /* !CONFIG_LSYSCALL_ENABLED */
	.fd_config = NULL,
	.mmap = NULL,
	.sync_ctrlmem_polllist = NULL,
};

static int visp_inet_socket_create(ux_socket_t *sock, int domain, int type,
				   int protocol, ux_namespace_t *ns)
{
	UNUSED(ns);
	ux_visp_sock_t *visp_sock = visp_sock_alloc_and_init(sock, domain, type, protocol);
	unsigned int flags = 0;
	int fd = -1;
	int ret = E_HM_OK;

	flags = (unsigned int)type & ~SOCK_TYPE_MASK;
	type = (int)((unsigned int)type & SOCK_TYPE_MASK);
	if (type == SOCK_RAW && sec_chk_raw_socket() != 0) {
		ret = E_HM_PERM;
	} else if (visp_sock == NULL) {
		ret = E_HM_NOMEM;
	} else {
		fd = visp_socket(domain, type, protocol);
		if (fd < 0) {
			ret = fd;
		}
	}

	if (ret == E_HM_OK) {
		ret = visp_setuserdata(fd, &visp_sock->sk.epoll_ctx);
	}

	if (ret == E_HM_OK) {
		visp_sock->fd = fd;

		ux_socket_set_sock(sock, &visp_sock->sk);

		sock->ops = &visp_inet_ops;
		sock->priv_ops = NULL;

		if ((flags & SOCK_NONBLOCK) != 0) {
			(void)socket_fcntl(sock, F_SETFL, O_NONBLOCK);
		}
	} else {
		if (fd >= 0) {
			visp_close(fd);
		}

		if (visp_sock != NULL) {
			free(visp_sock);
		}
	}

	return ret;
}

static ux_domain_t visp_inet_domain = {
	.family = AF_INET,
	.create = visp_inet_socket_create,
};

int visp_socket_init(void)
{
	int ret;

	ret = ux_domain_register(&visp_inet_domain);
	if (ret) {
		net_error(HMNET_INET, "visp register inet failed\n");
		return ret;
	}

	return 0;
}
