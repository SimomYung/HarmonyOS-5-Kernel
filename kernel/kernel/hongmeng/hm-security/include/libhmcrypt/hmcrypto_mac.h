/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2023. All rights reserved.
 * Description: Add mac cipher interface.
 * Author: Huawei OS Kernel Lab
 * Create: Mon Feb 6 16:10:24 2023
 */
#ifndef ULIBS_HMCRYPTO_MAC_H
#define ULIBS_HMCRYPTO_MAC_H

#include <stdint.h>
#include <string.h>
#include <libhmcrypt/hmcrypto_common.h>
#include <libhmcrypt/hmcrypto_algid.h>

#define HMCRYPTO_HMAC_SHA2_256_DIGEST	(32)
#define HMCRYPTO_HMAC_SHA2_512_DIGEST	(64)
#define HMCRYPTO_SIPHASH_2_4_8_DIGEST	(8)

/*
 * The message authentication code(mac) uses a key to generate a data block of a fixed
 * size to authenticate the integrity of a message and prevent the message from being
 * tampered with. The message authentication code can be generated by the hash function
 * with a key (hmac) or by the block ciphers(cbc-mac). In most cases, a mac can be
 * repressed as out = MAC(k, m), where k in the key, m is the message and out
 * is the data block of a fixed size to authenticate the integrity.
 *
 * In detail, given the key(key_data, key_len) and input(input_data, input_len), you can
 * choose an mac id to get the mac value and store the result in an output(output_data,
 * output_len) as follows. Note that, the output_len should be set as needed.
 * 1) new ctx: hmcrypto_mac_ctx *ctx = hmcrypto_mac_newctx(id);
 * 2) add key: hmcrypto_mac_addkey(ctx, key_data, key_len), note that, the key should be non-NULL;
 * 3) init: hmcrypto_mac_init(ctx);
 * 4) update: hmcrypto_mac_update(ctx, input_data, input_len), this can be called multi times;
 * 5) final: hmcrypto_mac_final(ctx, output_data, &output_len);
 * 6) remove key: hmcrypto_mac_removekey(ctx);
 * 7) free ctx: hmcrypto_mac_freectx(ctx);
 * Note that, you must call the remove key befor init.
 */

typedef struct hmcrypto_mac_ctx_internal hmcrypto_mac_ctx;

hmcrypto_mac_ctx *hmcrypto_mac_newctx(hmcrypto_mac_id id);
void hmcrypto_mac_freectx(hmcrypto_mac_ctx *ctx);

int hmcrypto_mac_addkey(hmcrypto_mac_ctx *ctx, const uint8_t *key, size_t key_len);
void hmcrypto_mac_removekey(hmcrypto_mac_ctx *ctx);
int hmcrypto_mac_init(hmcrypto_mac_ctx *ctx);
int hmcrypto_mac_update(hmcrypto_mac_ctx *ctx, const uint8_t *data, size_t data_len);
int hmcrypto_mac_final(hmcrypto_mac_ctx *ctx, uint8_t *out, size_t *out_len);

/*
 * For the convenience, you can call the following api to get the mac result directly, but this
 * api call hmcrypto_mac_update only once. Note that, hmcrypto_data *key = {key_data, key_len},
 * hmcrypto_data *data = {input_data, input_len}, and hmcrypto_data *output = {output_data, output_len}.
 */
int hmcrypto_mac(hmcrypto_mac_id id, const hmcrypto_data *key, const hmcrypto_data *data, hmcrypto_data *output);

#endif
