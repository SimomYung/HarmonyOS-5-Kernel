/*
 * Copyright (C) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * Description: smart code sign introduces fast path for signature
 * Author: Huawei OS Kernel Lab
 * Create: Create: Wed Mar 19 21:20:12 2025
 */

#include <ctype.h>

#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/x509_vfy.h>
#include <openssl/pem.h>
#include <openssl/asn1t.h>
#include <openssl/ec.h>
#include <openssl/bio.h>
#include <openssl/bn.h>
#include <openssl/asn1.h>
#include <openssl/pkcs7.h>
#include <openssl/objects.h>
#include <openssl/err.h>
#include <crypto/x509.h>
#include <stdint.h>

#include <libhwsecurec/securec.h>
#include <hongmeng/errno.h>
#include <libhmlog/hmlog.h>
#include <libhmcrypt/hmcert.h>
#include <libhmcrypt/hmcert_smartcs.h>
#include <libkeymgr/fsverity_api.h>
#include <libhmsrv_key/key.h>

/*
 * 1. This hard-coded  cert is used for fastpath of signature verification.
 * 2. This cert is maintained by CBG Cloud.
 *.   It is updated every 5 years, and the next update will be held on April, 2028
 * 3. When the cert is updated
 *        1) Signature of APPs signed by the OLD cert will be verified successfully, via the fastpath, as usual
 *........2) Signature of APPs signed by the NEW cert will be verified via the fastpath first.
 *           After it fails as expectedï¼Œ the verification will go back to the slowpath and succeed.
 *........3) The new cert should be added here to support the fast verification of APPs signed by it.
*/

static const unsigned char agc_crt_data[765] = {
        0x30, 0x82, 0x02, 0xF9, 0x30, 0x82, 0x02, 0x7F, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x08, 0x59,
        0x7B, 0x01, 0x14, 0x02, 0x4E, 0x43, 0x32, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
        0x04, 0x03, 0x03, 0x30, 0x64, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,
        0x43, 0x4E, 0x31, 0x0F, 0x30, 0x0D, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x0C, 0x06, 0x48, 0x75, 0x61,
        0x77, 0x65, 0x69, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x0A, 0x48, 0x75,
        0x61, 0x77, 0x65, 0x69, 0x20, 0x43, 0x42, 0x47, 0x31, 0x2F, 0x30, 0x2D, 0x06, 0x03, 0x55, 0x04,
        0x03, 0x0C, 0x26, 0x48, 0x75, 0x61, 0x77, 0x65, 0x69, 0x20, 0x43, 0x42, 0x47, 0x20, 0x53, 0x6F,
        0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x53,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x32, 0x33, 0x30,
        0x34, 0x32, 0x34, 0x30, 0x36, 0x32, 0x32, 0x30, 0x35, 0x5A, 0x17, 0x0D, 0x32, 0x38, 0x30, 0x34,
        0x32, 0x34, 0x30, 0x36, 0x32, 0x32, 0x30, 0x35, 0x5A, 0x30, 0x64, 0x31, 0x0B, 0x30, 0x09, 0x06,
        0x03, 0x55, 0x04, 0x06, 0x0C, 0x02, 0x43, 0x4E, 0x31, 0x0F, 0x30, 0x0D, 0x06, 0x03, 0x55, 0x04,
        0x0A, 0x0C, 0x06, 0x48, 0x75, 0x61, 0x77, 0x65, 0x69, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55,
        0x04, 0x0B, 0x0C, 0x0E, 0x48, 0x4F, 0x53, 0x20, 0x41, 0x70, 0x70, 0x47, 0x61, 0x6C, 0x6C, 0x65,
        0x72, 0x79, 0x31, 0x2B, 0x30, 0x29, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x22, 0x48, 0x4F, 0x53,
        0x20, 0x41, 0x70, 0x70, 0x47, 0x61, 0x6C, 0x6C, 0x65, 0x72, 0x79, 0x20, 0x41, 0x70, 0x70, 0x6C,
        0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x30,
        0x59, 0x30, 0x13, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x08, 0x2A, 0x86,
        0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0x8A, 0x24, 0x8E, 0x7F, 0x6D, 0x55,
        0x1A, 0x60, 0x10, 0x2E, 0x9B, 0xD4, 0x04, 0x7D, 0x72, 0x18, 0xA2, 0x7A, 0x35, 0x06, 0x06, 0x21,
        0x7C, 0xDC, 0xBC, 0xE6, 0xD6, 0x08, 0xB2, 0x65, 0x7F, 0x57, 0x29, 0x5C, 0xD3, 0x3E, 0x41, 0xEA,
        0x45, 0x1B, 0x8C, 0x2F, 0xEC, 0xE1, 0x46, 0xD4, 0xF5, 0x24, 0x44, 0x84, 0x30, 0xE5, 0x20, 0x80,
        0xFC, 0x89, 0x6D, 0xEF, 0x7E, 0xAE, 0xDD, 0xE4, 0xF4, 0x28, 0xA3, 0x82, 0x01, 0x19, 0x30, 0x82,
        0x01, 0x15, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xFA,
        0xF5, 0xF7, 0xBE, 0x20, 0x56, 0x5D, 0x5D, 0xD4, 0xDA, 0x6D, 0xF1, 0x14, 0x15, 0x3C, 0x1D, 0x09,
        0xDB, 0xB2, 0x34, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x17, 0x34,
        0x6D, 0x0C, 0xB6, 0x19, 0xEF, 0x35, 0xFF, 0x89, 0xD4, 0x6C, 0x1D, 0x89, 0x89, 0x67, 0xBD, 0xF8,
        0xBF, 0x08, 0x30, 0x46, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x3F, 0x30, 0x3D, 0x30, 0x3B, 0x06,
        0x04, 0x55, 0x1D, 0x20, 0x00, 0x30, 0x33, 0x30, 0x31, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05,
        0x07, 0x02, 0x01, 0x16, 0x25, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x70, 0x6B, 0x69, 0x2E,
        0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x72, 0x2E, 0x68, 0x75, 0x61, 0x77, 0x65, 0x69, 0x2E,
        0x63, 0x6F, 0x6D, 0x2F, 0x63, 0x61, 0x2F, 0x63, 0x70, 0x73, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D,
        0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x4C, 0x06, 0x03, 0x55, 0x1D,
        0x1F, 0x04, 0x45, 0x30, 0x43, 0x30, 0x41, 0xA0, 0x3F, 0xA0, 0x3D, 0x86, 0x3B, 0x68, 0x74, 0x74,
        0x70, 0x3A, 0x2F, 0x2F, 0x70, 0x6B, 0x69, 0x2E, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x72,
        0x2E, 0x68, 0x75, 0x61, 0x77, 0x65, 0x69, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x63, 0x61, 0x2F, 0x63,
        0x72, 0x6C, 0x2F, 0x73, 0x6F, 0x66, 0x74, 0x5F, 0x73, 0x69, 0x67, 0x6E, 0x5F, 0x73, 0x72, 0x76,
        0x5F, 0x63, 0x72, 0x6C, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04,
        0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x30, 0x18, 0x06,
        0x0C, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x8F, 0x5B, 0x02, 0x82, 0x78, 0x01, 0x03, 0x04, 0x08, 0x30,
        0x06, 0x02, 0x01, 0x01, 0x0A, 0x01, 0x00, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
        0x04, 0x03, 0x03, 0x03, 0x68, 0x00, 0x30, 0x65, 0x02, 0x31, 0x00, 0x9A, 0x1F, 0xC8, 0x64, 0x16,
        0xE1, 0x95, 0x43, 0x5B, 0xAE, 0x2A, 0x4D, 0xE8, 0x95, 0x41, 0x59, 0xF9, 0xC3, 0xB8, 0x91, 0x85,
        0xE8, 0xCF, 0xE9, 0x81, 0x6A, 0x61, 0x7F, 0x61, 0xFF, 0x99, 0x8D, 0x5C, 0xA3, 0x10, 0xF1, 0x9B,
        0x90, 0x08, 0x54, 0xFB, 0x11, 0xAA, 0xA1, 0x55, 0xB9, 0x56, 0x95, 0x02, 0x30, 0x58, 0x83, 0xC1,
        0xC4, 0x2F, 0x98, 0x84, 0xFC, 0xFA, 0x26, 0x60, 0xCC, 0x49, 0x90, 0xF2, 0x9D, 0x92, 0x0D, 0x9D,
        0x78, 0xB4, 0x4F, 0x79, 0x3D, 0x52, 0xF6, 0xDC, 0x0B, 0x26, 0xDB, 0x77, 0x69, 0x36, 0x3D, 0x61,
        0xD8, 0xBD, 0x8A, 0x90, 0x74, 0xA0, 0x2E, 0x60, 0x67, 0x0D, 0x73, 0x61, 0xE8
};
static const unsigned char agc_cert_pubkey[65] = {
	0x04, 0x8A, 0x24, 0x8E, 0x7F, 0x6D, 0x55, 0x1A, 0x60, 0x10, 0x2E, 0x9B, 0xD4, 0x04, 0x7D, 0x72,
	0x18, 0xA2, 0x7A, 0x35, 0x06, 0x06, 0x21, 0x7C, 0xDC, 0xBC, 0xE6, 0xD6, 0x08, 0xB2, 0x65, 0x7F,
	0x57, 0x29, 0x5C, 0xD3, 0x3E, 0x41, 0xEA, 0x45, 0x1B, 0x8C, 0x2F, 0xEC, 0xE1, 0x46, 0xD4, 0xF5,
	0x24, 0x44, 0x84, 0x30, 0xE5, 0x20, 0x80, 0xFC, 0x89, 0x6D, 0xEF, 0x7E, 0xAE, 0xDD, 0xE4, 0xF4,
	0x28
};

struct smartcs_scratch_states {
	bool inited;
	ASN1_OBJECT *type;
	ASN1_INTEGER *version;
	STACK_OF(X509_ALGOR) *md_algs;
	STACK_OF(X509) *cert;
	X509_STORE *store;
	PKCS7 *contents;
	int ownerid_nid;
	int signtime_nid;
};

static struct smartcs_scratch_states g_smartcs_states;

int smartcs_init(void)
{
	int ret;
	struct smartcs_scratch_states *gobj = &g_smartcs_states;
	BUG_ON(gobj->inited);
	STACK_OF(X509_ALGOR) *md_algs = NULL;
	STACK_OF(X509) *sk_cert = NULL;
	X509 *cert = NULL;
	PKCS7 *contents = NULL;
	ASN1_INTEGER *version = ASN1_INTEGER_new();
	BUG_ON(version == NULL);
	ASN1_INTEGER_set_int64(version, 1);

	md_algs = sk_X509_ALGOR_new_null();
	BUG_ON(md_algs == NULL);
	X509_ALGOR *alg = X509_ALGOR_new();
	BUG_ON(alg == NULL);
	alg->algorithm = OBJ_nid2obj(NID_sha256);
	alg->parameter = ASN1_TYPE_new();
	BUG_ON(alg->parameter == NULL);
	alg->parameter->value.integer = ASN1_INTEGER_new();
	BUG_ON(alg->parameter->value.integer == NULL);
	ret = ASN1_INTEGER_set(alg->parameter->value.integer, 32); // SHA256 size in bytes: 32
	BUG_ON(!ret);
	alg->parameter->type= V_ASN1_INTEGER;
	sk_X509_ALGOR_push(md_algs, alg);

	BIO *file_crt = BIO_new_mem_buf(agc_crt_data, sizeof(agc_crt_data));
	BUG_ON(file_crt == NULL);
	sk_cert = sk_X509_new_null();
	BUG_ON(sk_cert == NULL);
	cert = d2i_X509_bio(file_crt, NULL);
	BUG_ON(cert == NULL);
	X509_STORE *store = X509_STORE_new();
	BUG_ON(store == NULL);
	ret = X509_STORE_add_cert(store, cert);
	BUG_ON(!ret);
	contents = calloc(sizeof(PKCS7), 1);
	BUG_ON(contents == NULL);
	contents->type = OBJ_nid2obj(NID_pkcs7_data);

	ret = sk_X509_push(sk_cert, cert);
	BUG_ON(!ret);
	gobj->version = version;
	gobj->type = OBJ_nid2obj(NID_pkcs7_signed);
	gobj->md_algs = md_algs;
	gobj->cert = sk_cert;
	gobj->store = store;
	gobj->contents = contents;
	gobj->ownerid_nid = get_ownerid_nid(false);
	BUG_ON(gobj->ownerid_nid == NID_undef);
	gobj->signtime_nid = get_signtime_nid();
	BUG_ON(gobj->signtime_nid == NID_undef);

	BIO_free(file_crt);
	gobj->inited = true;
	return E_HM_OK;
}

void smartcs_uninit(void)
{
	struct smartcs_scratch_states *gobj = &g_smartcs_states;
	BUG_ON(!gobj->inited);
	ASN1_OBJECT_free(gobj->type);
	ASN1_INTEGER_free(gobj->version);
	PKCS7_free(gobj->contents);

	X509_ALGOR *algor = sk_X509_ALGOR_value(gobj->md_algs, 0);
	sk_X509_ALGOR_free(gobj->md_algs);
	X509_ALGOR_free(algor);

	X509_STORE_free(gobj->store);

	X509 *cert = sk_X509_value(gobj->cert, 0);
	sk_X509_free(gobj->cert);
	X509_free(cert);
	NOFAIL(memset_s(gobj, sizeof(*gobj), 0, sizeof(*gobj)));
}

static PKCS7 *smartcs_assemble_p7_with_agc_cert(PKCS7_SIGNER_INFO *si)
{
	PKCS7 *p7 = calloc(sizeof(PKCS7), 1);
	if (p7 == NULL) {
		return NULL;
	}
	p7->type = OBJ_nid2obj(NID_pkcs7_signed);
	PKCS7_SIGNED *p7_signed = calloc(sizeof(PKCS7_SIGNED), 1);
	if (p7_signed == NULL) {
		free(p7);
		return NULL;
	}
	p7_signed->version = g_smartcs_states.version;
	p7_signed->md_algs = g_smartcs_states.md_algs;
	p7_signed->cert = g_smartcs_states.cert;
	p7_signed->signer_info = sk_PKCS7_SIGNER_INFO_new_null();
	if (p7_signed->signer_info == NULL) {
		free(p7_signed);
		free(p7);
		return NULL;
	}
	p7_signed->contents = g_smartcs_states.contents;
	sk_PKCS7_SIGNER_INFO_push(p7_signed->signer_info, si);
	p7->d.sign = p7_signed;
	return p7;
}

static void smartcs_disassemble_p7(PKCS7 *p7)
{
	PKCS7_SIGNER_INFO *si = sk_PKCS7_SIGNER_INFO_value(p7->d.sign->signer_info, 0);
	sk_PKCS7_SIGNER_INFO_free(p7->d.sign->signer_info);
	p7->d.sign->signer_info = NULL;
	PKCS7_SIGNER_INFO_free(si);
	free(p7->d.sign);
	p7->d.sign = NULL;
	free(p7);
}

static int smartcs_fill_sig_info_with_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si,
						  struct hmcert_sig_info_s *sig_info)
{
	BUG_ON_D(p7 == NULL);
	BUG_ON_D(si == NULL);
	BUG_ON_D(sig_info == NULL);
	int nid_ownerid, nid_signtime;
	ASN1_TYPE* asn1_type = NULL;
	int err;
	nid_ownerid = g_smartcs_states.ownerid_nid;
	nid_signtime = g_smartcs_states.signtime_nid;
	asn1_type = PKCS7_get_signed_attribute(si, nid_ownerid);
	err = find_ownerid(asn1_type, sig_info);
	if (err == E_HM_NOMEM) {
		return err;
	}
	asn1_type = PKCS7_get_signed_attribute(si, nid_signtime);
	(void)find_signtime(asn1_type, &sig_info->signtime);
	sig_info->pkcs7 = p7;
	return E_HM_OK;
}

void hm_sig_agc_fastpath_fini(struct hmcert_sig_info_s *sig_info)
{
	if (sig_info == NULL) {
		return;
	}
	PKCS7 *p7 = sig_info->pkcs7;
	if(sig_info->ownerid != NULL) {
		free(sig_info->ownerid);
		sig_info->ownerid = NULL;
	}
	if (p7 != NULL) {
		smartcs_disassemble_p7(p7);
	}
	free(sig_info);
}

static X509_STORE *smartcs_states_store_of(void)
{
	X509_STORE *store = g_smartcs_states.store;
	if (sk_X509_OBJECT_num(X509_STORE_get0_objects(store)) != 1) {
		return NULL;
	}
	X509_OBJECT *cert_obj = sk_X509_OBJECT_value(X509_STORE_get0_objects(store), 0);
	if (cert_obj == NULL) {
		return NULL;
	}
	X509 *cert = X509_OBJECT_get0_X509(cert_obj);
	if (cert == NULL) {
		return NULL;
	}
	ASN1_BIT_STRING *pubkey_bitstr = X509_get0_pubkey_bitstr(cert);
	if (pubkey_bitstr == NULL) {
		return NULL;
	}
	pubkey_bitstr->data = agc_cert_pubkey; /* using the hard-coded pubkey protected by HKIP */

	return store;
}

#define OPENSSL_VERIFY_SUCCESS 1
int hm_sig_verify_agc_fastpath(const unsigned char *signer_info, size_t signer_info_len,
			       const unsigned char *data, size_t data_len,
			       struct hmcert_sig_info_s **_sig_info)
{
	BUG_ON_D(signer_info == NULL);
	BUG_ON_D(data == NULL);
	BUG_ON_D(_sig_info == NULL);
	int ret;
	PKCS7 *p7 = NULL;
	BIO *msg_bio = NULL;
	struct hmcert_sig_info_s *sig_info = NULL;
	X509_STORE *store = smartcs_states_store_of();
	if (store == NULL) {
		return E_HM_INVAL;
	}
	sig_info = calloc(sizeof(struct hmcert_sig_info_s), 1);
	if (sig_info == NULL) {
		return E_HM_NOMEM;
	}

	msg_bio = BIO_new_mem_buf(data, (int)data_len);
	if (msg_bio == NULL) {
		free(sig_info);
		return E_HM_NOMEM;
	}

	PKCS7_SIGNER_INFO *si = d2i_PKCS7_SIGNER_INFO(NULL, &signer_info, signer_info_len);
	if (si == NULL) {
		free(sig_info);
		BIO_free(msg_bio);
		hm_warn("failed to extract signer info\n");
		return E_HM_INVAL;
	}

	p7 = smartcs_assemble_p7_with_agc_cert(si);
	if (p7 == NULL) {
		PKCS7_SIGNER_INFO_free(si);
		free(sig_info);
		BIO_free(msg_bio);
		return E_HM_NOMEM;
	}

	ret = PKCS7_verify(p7, NULL, store, msg_bio, NULL, PKCS7_NOCHAIN | PKCS7_NOVERIFY);
	if (ret == OPENSSL_VERIFY_SUCCESS) {
		ret = smartcs_fill_sig_info_with_signer_info(p7, si, sig_info);
		if (ret == E_HM_OK) {
			*_sig_info = sig_info;
		} else {
			smartcs_disassemble_p7(p7);
			free(sig_info);
		}
	} else {
		hm_info("failed to verify signature in fastpath\n");
		smartcs_disassemble_p7(p7);
		free(sig_info);
		ret = E_HM_KEYREJECTED;
	}
	BIO_free(msg_bio);
	return ret;
}
