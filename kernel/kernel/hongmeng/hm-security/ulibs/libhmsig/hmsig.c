/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
 * Description: This function offer the implementation of init function before invoking hmsig.
 * Author: Huawei OS Kernel Lab
 * Create: Wed Jnu 15 06:10:24 2022
 */
#include <cmscbb/cmscbb_sdk.h>
#include <cmscbb/cmscbb_verify.h>
#include <cmscbb/cmscbb_init.h>
#include <cmscbb/cmscbb_err_def.h>
#include <cmscbb/cmscbb_cms_vrf.h>

#include <crypto/crypt_algid.h>
#include <crypto/crypt_eal_md.h>
#include <crypto/crypt_eal_pkey.h>
#include <crypto/crypt_errno.h>
#include <bsl/bsl_sal.h>

#include <libhmsig/hmsig.h>

#include <hongmeng/errno.h>
#include <libhmlog/hmlog.h>
#include <lib/printf.h>
#include <lib/klog.h>
#include <libhwsecurec/securec.h>
#include <string.h>

#ifdef __HOST_LLT__
#define INNER
#else
#define INNER static
#endif

typedef struct {
	CVB_VOID *crypt_md_ctx;
	CVB_UINT32 hash_id;
} hm_crypto_md;

typedef struct {
	CVB_VOID *rsakey;
	hm_crypto_md *md_ctx;
	CRYPT_RSA_PssPara pkey_pad;
} hm_crypto_vrf;

INNER CMSCBB_ERROR_CODE cms_malloc(CVB_VOID **pp_byte, CVB_SIZE_T size)
{
	if (pp_byte == NULL) {
		return CMSCBB_ERR_CONTEXT_INVALID_PARAM;
	}

	if (size == 0) {
		*pp_byte = NULL;
		return CVB_SUCCESS;
	}

	*pp_byte = malloc(size);
	if (*pp_byte == NULL) {
		return CMSCBB_ERR_SYS_MEM_ALLOC;
	}

	return CVB_SUCCESS;
}

INNER CVB_VOID cms_free(CVB_VOID *ptr)
{
	if (ptr == NULL) {
		return;
	}

	free(ptr);
}

INNER CVB_INT cms_memcmp(const CVB_VOID *s1, const CVB_VOID *s2, CVB_SIZE_T n)
{
	if (s1 == NULL || s2 == NULL) {
		return -1;
	}

	return (CVB_INT)memcmp(s1, s2, n);
}

INNER CVB_INT cms_strncmp(const CVB_CHAR *s1, const CVB_CHAR *s2, CVB_SIZE_T n)
{
	if (s1 == NULL || s2 == NULL) {
		return -1;
	}

	return (CVB_INT)strncmp((const char*)s1, (const char*)s2, n);
}

INNER const CVB_CHAR *cms_strstr(const CVB_CHAR *haystack, const CVB_CHAR *needle)
{
	CVB_CHAR *s1 = NULL;
	CVB_CHAR *s2 = NULL;
	size_t len1;
	size_t len2;

	s1 = (CVB_CHAR*)haystack;
	s2 = (CVB_CHAR*)needle;

	if (s1 == NULL || s2 == NULL) {
		return NULL;
	}

	len1 = strlen(s1);
	len2 = strlen(s2);
	if (len2 == 0) {
		return s1;
	}

	while (len1 >= len2) {
		if (memcmp(s1, s2, len2) == 0) {
			return s1;
		}
		s1++;
	}

	return NULL;
}

INNER CVB_CHAR *cms_strchr(const CVB_CHAR *s, CVB_CHAR c)
{
	if (s == NULL) {
		return NULL;
	}

	return (CVB_CHAR*)strchr((char*)s, (int)c);
}

INNER CVB_UINT32 cms_strlen(const CVB_CHAR *s)
{
	if (s == NULL) {
		return 0;
	}

	return (CVB_UINT32)strlen((const char*)s);
}

INNER CVB_INT cms_strcmp(const CVB_CHAR *s1, const CVB_CHAR *s2)
{
	size_t len1 = 0, len2 = 0;

	if (s1 == NULL || s2 == NULL) {
		return -1;
	}

	if (s1 == s2) {
		return 0;
	}

	len1 = (size_t)strlen((const char*)s1);
	len2 = (size_t)strlen((const char*)s2);
	if (len1 != len2) {
		return -1;
	}

	return strncmp((const char*)s1, (const char*)s2, (size_t)len1);
}

INNER CVB_FILE_HANDLE cms_file_open(const CVB_CHAR *path, const CVB_CHAR *mode)
{
	FILE *file = NULL;
	char *realp = NULL;

	if (path == NULL || mode == NULL) {
		return NULL;
	}

	realp = realpath((const char*)path, NULL);
	if (realp == NULL) {
		return NULL;
	}

	file = fopen(realp, (const char*)mode);

	free(realp);

	return (CVB_FILE_HANDLE)file;
}

INNER CVB_SIZE_T cms_file_read(CVB_VOID *ptr, CVB_SIZE_T size, CVB_FILE_HANDLE fp)
{
	FILE *file = (FILE*)fp;
	if (file == NULL || ptr == NULL) {
		return (CVB_SIZE_T)CMSCBB_ERR_UNDEFINED;
	}
	return fread(ptr, 1, size, file);
}

INNER CMSCBB_ERROR_CODE cms_file_close(CVB_FILE_HANDLE fp)
{
	FILE *file = fp;
	if (file == NULL) {
		return CMSCBB_ERR_UNDEFINED;
	}
	return (CMSCBB_ERROR_CODE)fclose(file);
}

INNER CVB_UINT64 cms_file_getsize(CVB_FILE_HANDLE fp)
{
	FILE *file = (FILE*)fp;
	long cur0;
	long filesize;

	if (file == NULL) {
		return 0;
	}

	cur0 = ftell(file);
	(void)fseek(file, 0, SEEK_END);
	filesize = ftell(file);
	(void)fseek(file, cur0, SEEK_SET);
	return (CVB_UINT64)(CVB_INT64)filesize;
}

INNER CVB_VOID cms_log_print1(CMSCBB_LOG_TYPE loglevel, CMSCBB_LOG_LOC logloc,
			       CMSCBB_ERROR_CODE rc, const CVB_CHAR *log)
{
	switch (loglevel) {
	case CMSCBB_LOG_TYPE_ERROR:
		hm_error("[%s:%d] %s (err=0x%x)\n", logloc.function,
			 logloc.line, log, (unsigned int)rc);
		break;
	case CMSCBB_LOG_TYPE_WARNING:
		hm_warn("[%s:%d] %s (err=0x%x)\n", logloc.function,
			logloc.line, log, (unsigned int)rc);
		break;
	case CMSCBB_LOG_TYPE_INFO:
		hm_info("[%s:%d] %s (err=0x%x)\n", logloc.function,
			logloc.line, log, (unsigned int)rc);
		break;
	case CMSCBB_LOG_TYPE_DEBUG:
		hm_debug("[%s:%d] %s (err=0x%x)\n", logloc.function,
			 logloc.line, log, (unsigned int)rc);
		break;
	default:
		break;
	}
}

INNER CVB_VOID cms_log_print2(CMSCBB_LOG_TYPE loglevel, CMSCBB_LOG_LOC logloc,
			       CMSCBB_ERROR_CODE rc, const CVB_CHAR *log)
{
	cms_log_print1(loglevel, logloc, rc, log);
}

INNER CRYPT_MD_AlgId cms_hash_algo_tran(CVB_UINT32 hash_id)
{
	CRYPT_MD_AlgId hash_md_id = CRYPT_MD_MAX;
	switch (hash_id) {
	case CMSCBB_HASH_SHA256:
		hash_md_id = CRYPT_MD_SHA256;
		break;
	case CMSCBB_HASH_SHA384:
		hash_md_id = CRYPT_MD_SHA384;
		break;
	case CMSCBB_HASH_SHA512:
		hash_md_id = CRYPT_MD_SHA512;
		break;
	default:
		break;
	}
	return hash_md_id;
}

INNER CMSCBB_ERROR_CODE cms_md_create(CMSCBB_CRYPTO_MD_CTX *mdctx)
{
	int ret = 0;
	CMSCBB_ERROR_CODE rc = 0;
	hm_crypto_md *pmd = NULL;

	if (mdctx == NULL) {
		return CMSCBB_ERR_CONTEXT_INVALID_PARAM;
	}

	pmd = malloc(sizeof(hm_crypto_md));
	if (pmd == NULL) {
		return CMSCBB_ERR_SYS_MEM_ALLOC;
	}
	ret = memset_s((CVB_VOID*)pmd, sizeof(hm_crypto_md), 0, sizeof(hm_crypto_md));
	if (ret != EOK) {
		rc = CMSCBB_ERR_SYS_MEM_SET;
		goto err_free_ctx;
	}

	*mdctx = (CMSCBB_CRYPTO_MD_CTX)pmd;
	return CVB_SUCCESS;

err_free_ctx:
	cms_free((CVB_VOID*)pmd);
	return rc;
}

INNER CMSCBB_ERROR_CODE cms_md_init(CMSCBB_CRYPTO_MD_CTX mdctx, CVB_UINT32 hash_id)
{
	hm_crypto_md *pmd = (hm_crypto_md*)mdctx;
	CRYPT_EAL_MdCTX *ctx = NULL;
	CRYPT_MD_AlgId hash_md_id = CRYPT_MD_MAX;

	pmd->hash_id = hash_id;
	hash_md_id = cms_hash_algo_tran(hash_id);
	ctx = CRYPT_EAL_MdNewCtx(hash_md_id);
	if (ctx == NULL) {
		return CMSCBB_ERR_CRYPT_MD_CTX_NEW;
	}

	if (CRYPT_EAL_MdInit(ctx) != CRYPT_SUCCESS) {
		CRYPT_EAL_MdFreeCtx(ctx);
		return CMSCBB_ERR_CRYPT_MD_START;
	}

	pmd->crypt_md_ctx = (CVB_VOID*)ctx;

	return CVB_SUCCESS;
}

INNER CMSCBB_ERROR_CODE cms_md_update(CMSCBB_CRYPTO_MD_CTX mdctx,
				      const CVB_BYTE *data, CVB_UINT32 len)
{
	hm_crypto_md *pmd = (hm_crypto_md*)mdctx;

	if (pmd == NULL || data == NULL) {
		return CMSCBB_ERR_CONTEXT_INVALID_PARAM;
	}

	if (CRYPT_EAL_MdUpdate((CRYPT_EAL_MdCTX*)pmd->crypt_md_ctx, data, len) != CRYPT_SUCCESS) {
		return CMSCBB_ERR_CRYPT_MD_UPDATE;
	}

	return CVB_SUCCESS;
}

INNER CMSCBB_ERROR_CODE cms_md_final(CMSCBB_CRYPTO_MD_CTX mdctx, CVB_BYTE *digest,
				     CVB_UINT32 *len, const CVB_UINT32 *digest_maxlen)
{
	hm_crypto_md *pmd = (hm_crypto_md*)mdctx;
	uint32_t length;

	if (pmd == NULL || digest == NULL || len == NULL || digest_maxlen == NULL) {
		return CMSCBB_ERR_CONTEXT_INVALID_PARAM;
	}

	length = (uint32_t)(*digest_maxlen);
	if (CRYPT_EAL_MdFinal((CRYPT_EAL_MdCTX*)pmd->crypt_md_ctx, digest, &length) != CRYPT_SUCCESS) {
		return CMSCBB_ERR_CRYPT_MD_FINISH;
	}

	*len = (CVB_UINT32)length;
	return CVB_SUCCESS;
}

INNER CVB_VOID cms_md_destory(CMSCBB_CRYPTO_MD_CTX mdctx)
{
	hm_crypto_md *pmd = (hm_crypto_md*)mdctx;
	if (pmd != NULL) {
		if (pmd->crypt_md_ctx != NULL) {
			CRYPT_EAL_MdFreeCtx((CRYPT_EAL_MdCTX*)pmd->crypt_md_ctx);
			pmd->crypt_md_ctx = NULL;
		}
		cms_free(pmd);
	}
}

INNER CMSCBB_ERROR_CODE cms_verify_create(CMSCBB_CRYPTO_VRF_CTX *vrf_ctx)
{
	int ret = 0;
	CMSCBB_ERROR_CODE rc = CVB_SUCCESS;
	hm_crypto_vrf *pvrf = NULL;
	CMSCBB_CRYPTO_MD_CTX md_ctx = NULL;

	if (vrf_ctx == NULL) {
		return CMSCBB_ERR_CONTEXT_INVALID_PARAM;
	}

	pvrf = malloc(sizeof(hm_crypto_vrf));
	if (pvrf == NULL) {
		rc = CMSCBB_ERR_SYS_MEM_ALLOC;
		goto err_out;
	}
	ret = memset_s((CVB_VOID*)pvrf, sizeof(hm_crypto_vrf), 0, sizeof(hm_crypto_vrf));
	if (ret != EOK) {
		rc = CMSCBB_ERR_SYS_MEM_SET;
		goto err_free_ctx;
	}

	rc = cms_md_create(&md_ctx);
	if (rc != CVB_SUCCESS) {
		goto err_free_ctx;
	}

	pvrf->md_ctx = (hm_crypto_md*)md_ctx;
	*vrf_ctx = (CMSCBB_CRYPTO_VRF_CTX)pvrf;
	return rc;

err_free_ctx:
	cms_free(pvrf);
err_out:
	return rc;
}

/*
 * This following two functions are paired:
 * rsa_pkey_init: malloc memory and assign values for pkey;
 * rsa_pkey_fini: free the memory that malloc by get_rsa_pkey.
 */
INNER int rsa_pkey_init(CRYPT_EAL_PkeyPub *pkey, const CmscbbBigInt *e, const CmscbbBigInt *n)
{
	pkey->id = CRYPT_PKEY_RSA;

	pkey->key.rsaPub.e = malloc(e->uiLength);
	if (pkey->key.rsaPub.e == NULL) {
		return E_HM_NOMEM;
	}
	pkey->key.rsaPub.eLen = e->uiLength;
	NOFAIL(memcpy_s(pkey->key.rsaPub.e, e->uiLength, e->aVal, e->uiLength));

	pkey->key.rsaPub.n = malloc(n->uiLength);
	if (pkey->key.rsaPub.n == NULL) {
		free(pkey->key.rsaPub.e);
		pkey->key.rsaPub.e = NULL;
		pkey->key.rsaPub.eLen = 0;
		return E_HM_NOMEM;
	}
	pkey->key.rsaPub.nLen = n->uiLength;
	NOFAIL(memcpy_s(pkey->key.rsaPub.n, n->uiLength, n->aVal, n->uiLength));

	return E_HM_OK;
}

INNER void rsa_pkey_fini(CRYPT_EAL_PkeyPub *pkey)
{
	if (pkey->key.rsaPub.e != NULL) {
		free(pkey->key.rsaPub.e);
		pkey->key.rsaPub.e = NULL;
	}
	pkey->key.rsaPub.eLen = 0;

	if (pkey->key.rsaPub.n != NULL) {
		free(pkey->key.rsaPub.n);
		pkey->key.rsaPub.n = NULL;
	}
	pkey->key.rsaPub.nLen = 0;

	return;
}

INNER CMSCBB_ERROR_CODE cms_verify_init(CMSCBB_CRYPTO_VRF_CTX vrf_ctx,
					CmscbbKeyAndAlgInfo *info)
{
	CMSCBB_ERROR_CODE ret = CVB_SUCCESS;
	hm_crypto_vrf *pvrf = (hm_crypto_vrf*)vrf_ctx;
	CRYPT_EAL_PkeyCtx *rsakey = NULL;
	CRYPT_EAL_PkeyPub rsa_pub = {0};
	int rc;

	if (pvrf == NULL || info == NULL) {
		return CMSCBB_ERR_CONTEXT_INVALID_PARAM;
	}

	ret = cms_md_init((CMSCBB_CRYPTO_MD_CTX)pvrf->md_ctx, info->hashAlg);
	BUG_ON(ret != CVB_SUCCESS);

	rsakey = CRYPT_EAL_PkeyNewCtx(CRYPT_PKEY_RSA);
	if (rsakey == NULL) {
		ret = CMSCBB_ERR_CRYPT_RSA_NEW;
		goto err_out;
	}

	/*
	 * The function rsa_pkey_init will malloc memory for rsa_pub.
	 * After function CRYPT_EAL_PkeySetPub, the memory should be free
	 * by calling rsa_pkey_fini.
	 */
	if (rsa_pkey_init(&rsa_pub, info->e, info->n) != E_HM_OK) {
		ret = CMSCBB_ERR_SYS_MEM_ALLOC;
		goto err_free_key;
	}

	rc = CRYPT_EAL_PkeySetPub(rsakey, &rsa_pub);
	BUG_ON(rc != CRYPT_SUCCESS);

	rsa_pkey_fini(&rsa_pub); // Free memory that malloc by function rsa_pkey_init.

	pvrf->rsakey = (CVB_VOID*)rsakey;
	pvrf->pkey_pad.saltLen = info->saltLen;
	pvrf->pkey_pad.mdId = cms_hash_algo_tran(info->hashAlg);
	pvrf->pkey_pad.mgfId = cms_hash_algo_tran(info->mgfAlg);

	return ret;

err_free_key:
	CRYPT_EAL_PkeyFreeCtx(rsakey);
	rsakey = NULL;
err_out:
	cms_md_destory((CMSCBB_CRYPTO_MD_CTX)pvrf->md_ctx);
	pvrf->md_ctx = NULL;
	return ret;
}

INNER CMSCBB_ERROR_CODE cms_verify_update(CMSCBB_CRYPTO_VRF_CTX vrf_ctx,
					  const CVB_BYTE *data, CVB_UINT32 len)
{
	hm_crypto_vrf *pvrf = (hm_crypto_vrf*)vrf_ctx;

	if (pvrf == NULL || pvrf->md_ctx == NULL) {
		return CMSCBB_ERR_CONTEXT_INVALID_PARAM;
	}

	return cms_md_update((CMSCBB_CRYPTO_MD_CTX)pvrf->md_ctx, data, len);
}

INNER CMSCBB_ERROR_CODE cms_verify_final(CMSCBB_CRYPTO_VRF_CTX vrf_ctx,
					 const CVB_BYTE *signature, CVB_UINT32 len,
					 CVB_INT *result)
{
	int rc;
	CMSCBB_ERROR_CODE ret = 0;
	hm_crypto_vrf *pvrf = (hm_crypto_vrf*)vrf_ctx;
	CVB_BYTE file_hash[CMSCBB_MAX_DIGEST_SIZE] = { 0 };
	CVB_UINT32 hash_len = 0;
	CVB_UINT32 hash_len_max = CMSCBB_MAX_DIGEST_SIZE;

	if (pvrf == NULL || pvrf->md_ctx == NULL) {
		*result = 0;
		return CMSCBB_ERR_CONTEXT_INVALID_PARAM;
	}

	ret = cms_md_final((CMSCBB_CRYPTO_MD_CTX)pvrf->md_ctx, file_hash, &hash_len, &hash_len_max);
	if (ret != CVB_SUCCESS) {
		*result = 0;
		return ret;
	}

	rc = CRYPT_EAL_PkeyCtrl((CRYPT_EAL_PkeyCtx*)pvrf->rsakey, CRYPT_CTRL_SET_RSA_EMSA_PSS,
				&pvrf->pkey_pad, sizeof(CRYPT_RSA_PssPara));
	if (rc != CRYPT_SUCCESS) {
		*result = 0;
		return CMSCBB_ERR_CRYPT_SIG_VERIFY;
	}

	rc = CRYPT_EAL_PkeyVerifyData((CRYPT_EAL_PkeyCtx*)pvrf->rsakey, file_hash, hash_len, signature, len);
	if (rc != CRYPT_SUCCESS) {
		*result = 0;
		return CMSCBB_ERR_CRYPT_SIG_VERIFY;
	}

	*result = 1;
	return CVB_SUCCESS;
}

INNER CVB_VOID cms_verify_destroy(CMSCBB_CRYPTO_VRF_CTX vrf_ctx)
{
	hm_crypto_vrf *vrf_ptr = (hm_crypto_vrf*)vrf_ctx;
	if (vrf_ptr != NULL) {
		if (vrf_ptr->rsakey != NULL) {
			CRYPT_EAL_PkeyFreeCtx((CRYPT_EAL_PkeyCtx*)(vrf_ptr->rsakey));
			vrf_ptr->rsakey = NULL;
		}
		if (vrf_ptr->md_ctx != NULL) {
			cms_md_destory((CMSCBB_CRYPTO_VRF_CTX)(vrf_ptr->md_ctx));
			vrf_ptr->md_ctx = NULL;
		}
		cms_free(vrf_ptr);
	}
}

INNER unsigned char pb_root_cert[] = {
0x30, 0x82, 0x06, 0x42, 0x30, 0x82, 0x03, 0xf6, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x03, 0x3c,
0x3a, 0xdb, 0x30, 0x41, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0a, 0x30,
0x34, 0xa0, 0x0f, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
0x05, 0x00, 0xa1, 0x1c, 0x30, 0x1a, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
0x08, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00,
0xa2, 0x03, 0x02, 0x01, 0x20, 0x30, 0x7c, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
0x13, 0x02, 0x43, 0x4e, 0x31, 0x1c, 0x30, 0x1a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x13, 0x48,
0x75, 0x61, 0x77, 0x65, 0x69, 0x20, 0x54, 0x65, 0x63, 0x68, 0x6e, 0x6f, 0x6c, 0x6f, 0x67, 0x69,
0x65, 0x73, 0x31, 0x27, 0x30, 0x25, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x1e, 0x48, 0x75, 0x61,
0x77, 0x65, 0x69, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
0x6e, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x31, 0x26, 0x30, 0x24, 0x06,
0x03, 0x55, 0x04, 0x03, 0x13, 0x1d, 0x48, 0x75, 0x61, 0x77, 0x65, 0x69, 0x20, 0x49, 0x6e, 0x74,
0x65, 0x67, 0x72, 0x69, 0x74, 0x79, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43, 0x41, 0x20, 0x2d,
0x20, 0x47, 0x32, 0x30, 0x20, 0x17, 0x0d, 0x32, 0x31, 0x30, 0x32, 0x30, 0x37, 0x30, 0x39, 0x33,
0x36, 0x34, 0x36, 0x5a, 0x18, 0x0f, 0x32, 0x30, 0x35, 0x31, 0x30, 0x35, 0x30, 0x37, 0x30, 0x39,
0x33, 0x36, 0x34, 0x36, 0x5a, 0x30, 0x7c, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
0x13, 0x02, 0x43, 0x4e, 0x31, 0x1c, 0x30, 0x1a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x13, 0x48,
0x75, 0x61, 0x77, 0x65, 0x69, 0x20, 0x54, 0x65, 0x63, 0x68, 0x6e, 0x6f, 0x6c, 0x6f, 0x67, 0x69,
0x65, 0x73, 0x31, 0x27, 0x30, 0x25, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x1e, 0x48, 0x75, 0x61,
0x77, 0x65, 0x69, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
0x6e, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x31, 0x26, 0x30, 0x24, 0x06,
0x03, 0x55, 0x04, 0x03, 0x13, 0x1d, 0x48, 0x75, 0x61, 0x77, 0x65, 0x69, 0x20, 0x49, 0x6e, 0x74,
0x65, 0x67, 0x72, 0x69, 0x74, 0x79, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43, 0x41, 0x20, 0x2d,
0x20, 0x47, 0x32, 0x30, 0x82, 0x02, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x02, 0x0f, 0x00, 0x30, 0x82, 0x02, 0x0a, 0x02,
0x82, 0x02, 0x01, 0x00, 0xdd, 0x89, 0x4f, 0x23, 0xfc, 0x75, 0x2d, 0xa6, 0x24, 0x8b, 0x8e, 0xc9,
0xab, 0xd6, 0xdd, 0x4f, 0xfe, 0x70, 0x43, 0x4d, 0xbc, 0x6e, 0xba, 0x7d, 0x0e, 0x55, 0xc8, 0x9a,
0x43, 0xa3, 0x9c, 0xf8, 0x4e, 0xb2, 0xd5, 0x85, 0xc2, 0x52, 0x61, 0x67, 0xfa, 0x9d, 0x56, 0xc0,
0xa1, 0x09, 0x41, 0xeb, 0x64, 0x29, 0xb0, 0x96, 0x95, 0xc6, 0x5c, 0x87, 0xc2, 0x36, 0x1b, 0xf7,
0xfc, 0xe8, 0x9f, 0xd9, 0xe2, 0x6e, 0x19, 0xc1, 0x92, 0x52, 0x57, 0x4e, 0x01, 0xfe, 0xe2, 0x90,
0x18, 0x0c, 0xb7, 0xe4, 0x55, 0xb9, 0x6c, 0xd0, 0x6d, 0xbd, 0x81, 0xf7, 0xc4, 0xde, 0x27, 0x7b,
0x4a, 0x06, 0x5b, 0xaa, 0x96, 0x92, 0x02, 0x50, 0xb0, 0x31, 0xc6, 0xea, 0x21, 0x59, 0xa9, 0x10,
0x4a, 0x2f, 0x1d, 0x4e, 0xef, 0x23, 0xa1, 0xc2, 0xf1, 0x1d, 0x1b, 0x98, 0xdf, 0x27, 0x08, 0x36,
0xe8, 0xd2, 0xb9, 0x69, 0xde, 0xf9, 0xbc, 0xce, 0x8b, 0x1c, 0x0e, 0xad, 0x10, 0xf1, 0xbd, 0xb6,
0xd3, 0x21, 0x72, 0x68, 0xfd, 0x56, 0x0c, 0xd4, 0x74, 0x01, 0x4e, 0x1c, 0xeb, 0x75, 0x22, 0x50,
0x24, 0x67, 0xea, 0x1d, 0x16, 0x7e, 0x8f, 0xae, 0xd7, 0xb8, 0x8b, 0xf3, 0x34, 0x6d, 0x86, 0x60,
0x0f, 0xf2, 0xd2, 0x86, 0x58, 0x2d, 0x06, 0x9f, 0xa2, 0x0e, 0xb5, 0x83, 0xfb, 0x31, 0xdf, 0x71,
0x60, 0x03, 0x10, 0x61, 0x2c, 0x13, 0x3c, 0x72, 0x5f, 0xb0, 0x89, 0xbe, 0x22, 0x41, 0x4e, 0x7a,
0x14, 0xc0, 0xa3, 0x34, 0xfc, 0x24, 0x06, 0x2f, 0x36, 0x94, 0x4d, 0xc1, 0x8a, 0x7e, 0x65, 0x51,
0xaa, 0xf9, 0x71, 0x0a, 0xe4, 0x86, 0x45, 0x8b, 0x19, 0x5a, 0x53, 0xb2, 0xa0, 0x6a, 0x26, 0x89,
0x2c, 0xe6, 0x1f, 0x10, 0x8c, 0x2b, 0x3b, 0x21, 0xac, 0x75, 0xbe, 0x45, 0x33, 0xba, 0x62, 0x27,
0x45, 0xbd, 0xbb, 0x7f, 0x78, 0xa3, 0x34, 0x4d, 0x19, 0x77, 0xb1, 0x79, 0xba, 0x4b, 0x5f, 0x82,
0xf8, 0x54, 0x58, 0xdb, 0x97, 0xac, 0xe2, 0x5a, 0xd7, 0x06, 0x6d, 0x7f, 0xed, 0x52, 0x1c, 0x63,
0x2f, 0x02, 0x02, 0x60, 0x40, 0xcd, 0x8b, 0x1c, 0x16, 0x46, 0x89, 0xa8, 0x38, 0x8e, 0xa9, 0x9d,
0xb0, 0x1f, 0x79, 0xc3, 0x9a, 0x89, 0xd9, 0x78, 0xb8, 0x0b, 0xd2, 0x07, 0xe1, 0x48, 0xde, 0x57,
0xa1, 0xfb, 0x0e, 0x6b, 0x7f, 0x8a, 0xd0, 0x5c, 0x0b, 0x18, 0xc4, 0xac, 0xf1, 0x2e, 0xb3, 0x9d,
0x2c, 0x85, 0x76, 0x68, 0x2c, 0x74, 0x0b, 0xb9, 0xdc, 0x4c, 0xd0, 0x43, 0xf0, 0x83, 0xa2, 0x5c,
0x83, 0x2b, 0x36, 0xb7, 0xf2, 0xca, 0x91, 0x33, 0x16, 0xb6, 0x15, 0x2b, 0xc8, 0xad, 0xb8, 0xe2,
0x97, 0x2a, 0x6e, 0x52, 0x0e, 0x90, 0x1f, 0x8a, 0x7c, 0x5d, 0x97, 0x4b, 0x69, 0xcf, 0xc3, 0xeb,
0x7b, 0x3a, 0xf6, 0xb5, 0x5b, 0x0e, 0x07, 0x2d, 0xf5, 0x8b, 0x77, 0xf5, 0xee, 0xcf, 0x0b, 0x1e,
0x75, 0x5c, 0xb9, 0x10, 0x65, 0xeb, 0xf3, 0x5b, 0x4c, 0x1a, 0x72, 0xec, 0xa5, 0xbf, 0x3c, 0x96,
0x4c, 0x21, 0xea, 0xbc, 0xd1, 0xe8, 0xdf, 0x35, 0x4b, 0xbd, 0xf8, 0x6d, 0x7c, 0x1e, 0xf4, 0x2e,
0x48, 0x53, 0x4e, 0x76, 0x48, 0x70, 0x91, 0x52, 0x8b, 0xf4, 0x33, 0xeb, 0x60, 0x5f, 0x43, 0x00,
0x6b, 0x88, 0xc2, 0xc4, 0xb4, 0xd6, 0x85, 0x0f, 0x25, 0x40, 0xd7, 0xf6, 0x72, 0x24, 0xb3, 0xda,
0x3b, 0x43, 0x6f, 0x43, 0xb4, 0xf6, 0xb6, 0x49, 0x1f, 0xb2, 0x8a, 0x52, 0x8c, 0x6a, 0xbc, 0x53,
0xd6, 0xdc, 0x8a, 0xb2, 0xcb, 0xc8, 0x82, 0x53, 0xdc, 0xf5, 0xb9, 0x8f, 0xec, 0xeb, 0xf7, 0xa7,
0x0e, 0xe2, 0x79, 0xce, 0xe9, 0x32, 0xb6, 0x7a, 0xc5, 0xe7, 0x04, 0x2e, 0xa6, 0xfe, 0xda, 0xab,
0x36, 0x12, 0xa7, 0x43, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x63, 0x30, 0x61, 0x30, 0x0e, 0x06,
0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x0f, 0x06,
0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x1d,
0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x0e, 0x39, 0x01, 0x7d, 0x26, 0xcb, 0x02,
0x6a, 0xe0, 0xca, 0x34, 0x65, 0x50, 0x20, 0xa1, 0x44, 0x6c, 0xec, 0x7f, 0x9e, 0x30, 0x1f, 0x06,
0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x0e, 0x39, 0x01, 0x7d, 0x26, 0xcb,
0x02, 0x6a, 0xe0, 0xca, 0x34, 0x65, 0x50, 0x20, 0xa1, 0x44, 0x6c, 0xec, 0x7f, 0x9e, 0x30, 0x41,
0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0a, 0x30, 0x34, 0xa0, 0x0f, 0x30,
0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0xa1, 0x1c,
0x30, 0x1a, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x08, 0x30, 0x0d, 0x06,
0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0xa2, 0x03, 0x02, 0x01,
0x20, 0x03, 0x82, 0x02, 0x01, 0x00, 0x61, 0x9d, 0xa9, 0xe9, 0x54, 0xec, 0xf4, 0x7b, 0x17, 0x45,
0x7d, 0x2c, 0xaf, 0xf1, 0x5c, 0x41, 0x64, 0xa2, 0xf4, 0x5c, 0x86, 0x03, 0xb9, 0xee, 0x67, 0x99,
0xea, 0x34, 0x08, 0x9d, 0xbb, 0xef, 0x44, 0xe3, 0xe8, 0xd6, 0x5a, 0xc0, 0xe2, 0x4f, 0x90, 0xe0,
0x25, 0xbb, 0x34, 0x80, 0x26, 0x91, 0x8a, 0x65, 0xd6, 0x60, 0x4d, 0xf6, 0x5d, 0x8c, 0xa8, 0x11,
0x52, 0x61, 0x80, 0xcc, 0xbd, 0x08, 0x05, 0xd3, 0x9f, 0xda, 0x56, 0xe6, 0x47, 0x2c, 0xf8, 0x42,
0x6d, 0x5e, 0xea, 0x74, 0xea, 0x07, 0xa4, 0xef, 0xbd, 0xec, 0x9e, 0x92, 0xc9, 0xf1, 0x7f, 0x10,
0xc0, 0x42, 0xad, 0x2d, 0xdb, 0x36, 0xc8, 0xbf, 0x8d, 0x4e, 0x4b, 0x74, 0x4e, 0x6d, 0xfe, 0x42,
0x4f, 0x9e, 0x93, 0x29, 0x1e, 0xe6, 0xa7, 0xbb, 0x7a, 0x41, 0x1f, 0x37, 0x12, 0xbf, 0x33, 0x68,
0xaf, 0x16, 0x6d, 0xe8, 0x45, 0x33, 0x1d, 0x29, 0xb9, 0x14, 0xed, 0xfa, 0x44, 0x93, 0xed, 0xbd,
0xf6, 0x37, 0x3a, 0x76, 0x8c, 0x8e, 0xe3, 0xc6, 0x5b, 0xa0, 0x8b, 0xbf, 0xbf, 0xa0, 0x9a, 0x11,
0x77, 0x06, 0x1d, 0xec, 0xd2, 0x93, 0x76, 0x4a, 0x63, 0x2d, 0x20, 0x73, 0xdd, 0xd7, 0xe2, 0x82,
0xdd, 0x86, 0xa7, 0xc5, 0x39, 0x05, 0x35, 0xf1, 0x02, 0xf3, 0xba, 0x86, 0xc5, 0x64, 0x6f, 0x83,
0x87, 0x6c, 0x9e, 0x67, 0xfa, 0x1e, 0x5a, 0xbd, 0x8f, 0x2a, 0xfc, 0x7c, 0xf3, 0x77, 0x6c, 0x5c,
0xed, 0xb2, 0x45, 0x1d, 0x5c, 0xb9, 0xa4, 0xbe, 0x27, 0x87, 0xfb, 0xcc, 0xd7, 0x3f, 0x3f, 0x31,
0x16, 0x54, 0xa7, 0x11, 0x8b, 0x28, 0xea, 0x33, 0x35, 0xaa, 0xd8, 0x11, 0x25, 0x52, 0xcc, 0x86,
0x5c, 0xf6, 0x8b, 0xc0, 0xd3, 0xc5, 0x8a, 0x99, 0xa4, 0xaa, 0x5e, 0x40, 0xa0, 0x37, 0x01, 0x2f,
0xec, 0xaf, 0xdc, 0x0c, 0x29, 0xca, 0x02, 0x9e, 0xf7, 0x6a, 0x49, 0xd4, 0x00, 0x62, 0x60, 0xeb,
0x30, 0x0d, 0xdc, 0x16, 0x62, 0x91, 0x22, 0xd8, 0x33, 0xe5, 0x7e, 0x4e, 0x67, 0x38, 0x15, 0x1f,
0xd4, 0x40, 0x6f, 0xfe, 0x19, 0x29, 0x1d, 0xbe, 0x0d, 0x24, 0x9b, 0x12, 0xad, 0xde, 0x2c, 0xf0,
0xa1, 0x57, 0x2d, 0x8f, 0xf2, 0x5e, 0xdf, 0x9d, 0x15, 0x40, 0xb3, 0xa0, 0x62, 0x49, 0x8e, 0x4d,
0x05, 0xdd, 0x04, 0x2b, 0x4c, 0xa3, 0xc4, 0xf9, 0xab, 0xf6, 0x56, 0xab, 0xc9, 0x9c, 0xb7, 0x50,
0xed, 0x4b, 0x82, 0x9a, 0x2f, 0x18, 0x0b, 0x41, 0x03, 0x76, 0xd7, 0x84, 0x12, 0xe4, 0xca, 0x98,
0xeb, 0xc9, 0x85, 0xca, 0xe5, 0x37, 0x78, 0xa3, 0x7b, 0xb0, 0x3e, 0xc1, 0x53, 0x38, 0x46, 0xea,
0xdf, 0xa9, 0x85, 0x58, 0x45, 0x27, 0xa9, 0xac, 0x94, 0xf3, 0xa9, 0x6b, 0x13, 0x92, 0x69, 0x41,
0x70, 0x05, 0x75, 0xb5, 0x9d, 0x9e, 0x1a, 0x7e, 0x82, 0xab, 0x93, 0xb1, 0x05, 0x5d, 0x54, 0x35,
0xc6, 0xbd, 0xfb, 0x16, 0xc7, 0x3e, 0x6b, 0x63, 0xfb, 0x0c, 0x5f, 0x46, 0x0f, 0x89, 0x62, 0xcb,
0x32, 0xdc, 0xfb, 0x4c, 0x4e, 0x25, 0x94, 0x55, 0xac, 0xce, 0xdf, 0x34, 0xf6, 0xdd, 0x20, 0x3d,
0x1a, 0xda, 0x0a, 0x7a, 0xe6, 0xac, 0x93, 0x2b, 0x8c, 0x2b, 0x0f, 0xfc, 0x6c, 0x4b, 0xb7, 0x3a,
0x36, 0xd0, 0x0f, 0xbe, 0x5f, 0x12, 0x5f, 0xf1, 0xfb, 0xeb, 0x25, 0x7b, 0xfd, 0x71, 0x6d, 0xaa,
0x69, 0x9f, 0x46, 0x3d, 0xd8, 0xc8, 0x68, 0xf6, 0x0d, 0xcb, 0x56, 0x67, 0xca, 0x94, 0x55, 0x3b,
0x31, 0x1d, 0x0c, 0x55, 0x31, 0x69, 0x1e, 0x17, 0x37, 0xfb, 0x1b, 0x86, 0xae, 0xea, 0x3a, 0xa7,
0x50, 0x2a, 0xd9, 0xc7, 0x0c, 0x24, 0xad, 0xb3, 0xcc, 0xdc, 0x7e, 0x8b, 0x03, 0x75, 0x5d, 0xac,
0x5d, 0x68, 0x58, 0xdd, 0x21, 0x8e};

INNER CMSCBB_ERROR_CODE cms_create_context(CMSCBB_VRF_CTX *pvrf_ctx)
{
	CMSCBB_ERROR_CODE ret;
	CmscbbCtxCreateParams create_params = {0};
	/* create context of verification */
	create_params.st_size = sizeof(create_params);
	ret = CmscbbVerifyCreateCtx(pvrf_ctx, &create_params);
	if (ret != CVB_SUCCESS) {
		return ret;
	}
	/* add root certificate */
	ret = CmscbbVerifyAddCert(*pvrf_ctx, (const CVB_BYTE *)(CVB_VOID *)pb_root_cert,
				  (CVB_UINT32)sizeof(pb_root_cert));
	if (ret != CVB_SUCCESS) {
		(void)CmscbbVrfCtxFree(*pvrf_ctx);
		return ret;
	}
	return CVB_SUCCESS;
}

INNER CVB_VOID cms_destory_context(CMSCBB_VRF_CTX vrf_ctx)
{
	if (vrf_ctx == NULL) {
		return;
	}
	(void)CmscbbVrfCtxFree(vrf_ctx);
}

INNER CMSCBB_ERROR_CODE cms_verify_cmsdata(CmscbbVerifyInfo *info)
{
	CMSCBB_VRF_CTX vrf_ctx = NULL;
	CMSCBB_ERROR_CODE ret;
	CmscbbCtxCreateParams create_params = {0};
	CVB_UINT32 root_sz;
#define SIGN_SUCCESS (1)
	CVB_INT32 result = SIGN_SUCCESS;

	if (info == NULL) {
		return CMSCBB_ERR_CONTEXT_INVALID_PARAM;
	}
	NOFAIL(memset_s(&create_params, sizeof(create_params), 0, sizeof(create_params)));
	/* create context of verification */
	create_params.st_size = sizeof(create_params);
	ret = CmscbbVerifyCreateCtx(&vrf_ctx, &create_params);
	if (ret != CVB_SUCCESS) {
		return ret;
	}
	root_sz = (CVB_UINT32)sizeof(pb_root_cert); // size of root certificate in bytes
	/* add root certificate */
	ret = CmscbbVerifyAddCert(vrf_ctx, (const CVB_BYTE *)pb_root_cert, root_sz);
	if (ret != CVB_SUCCESS) {
		goto err_free;
	}

	/* add crl */
	if (info->crl != NULL) {
		ret = CmscbbVerifyAddCrl(vrf_ctx, (CVB_BYTE *)info->crl, info->crlSz);
		if (ret != CVB_SUCCESS) {
			goto err_free;
		}
	}

	ret = CmscbbVerifyDetachSignatureBegin(vrf_ctx, (const CVB_BYTE *)info->sig, info->sigSz);
	if (ret != CVB_SUCCESS) {
		goto err_free;
	}

	ret = CmscbbVerifyDetachSignatureUpdate(vrf_ctx,(const CVB_BYTE *)info->src, (CVB_INT32)info->srcSz);
	if (ret != CVB_SUCCESS) {
		goto err_free;
	}

	ret = CmscbbVerifyDetachSignatureFinal(vrf_ctx, (CVB_INT32 *)&result);
	if (ret != CVB_SUCCESS) {
		goto err_free;
	}
	/* check verification result */
	if (result != SIGN_SUCCESS) {
		ret = CMSCBB_ERR_PKI_CERT_VERIFY_FAILED;
		goto err_free;
	}
	hm_info("verification succeeded\n");
err_free:
	(void)CmscbbVrfCtxFree(vrf_ctx);

	return ret;
}

int hmsig_init(void)
{
	cmscbb_method cms_method;

	cms_method.mem_method.malloc = cms_malloc;
	cms_method.mem_method.free = cms_free;

	cms_method.str_method.memcmp = cms_memcmp;
	cms_method.str_method.strncmp = cms_strncmp;
	cms_method.str_method.strstr = cms_strstr;
	cms_method.str_method.strchr = cms_strchr;
	cms_method.str_method.strlen = cms_strlen;
	cms_method.str_method.strcmp = cms_strcmp;

	cms_method.file_method.file_open = cms_file_open;
	cms_method.file_method.file_read = cms_file_read;
	cms_method.file_method.file_close = cms_file_close;
	cms_method.file_method.file_getsize = cms_file_getsize;

	cms_method.logprint_method.log_print1 = cms_log_print1;
	cms_method.logprint_method.log_print2 = cms_log_print2;

	cms_method.md_method.md_create = cms_md_create;
	cms_method.md_method.md_init = cms_md_init;
	cms_method.md_method.md_update = cms_md_update;
	cms_method.md_method.md_final = cms_md_final;
	cms_method.md_method.md_destory = cms_md_destory;

	cms_method.verify_method.verify_create = cms_verify_create;
	cms_method.verify_method.verify_init = cms_verify_init;
	cms_method.verify_method.verify_update = cms_verify_update;
	cms_method.verify_method.verify_final = cms_verify_final;
	cms_method.verify_method.verify_destory = cms_verify_destroy;

	cms_method.cmsdata_method.verify_cmsdata = cms_verify_cmsdata;

	cms_method.context_method.create_context = cms_create_context;
	cms_method.context_method.destory_context = cms_destory_context;

	cmscbb_method_init(&cms_method);
	return E_HM_OK;
}

void hmsig_fini(void)
{
	return;
}
