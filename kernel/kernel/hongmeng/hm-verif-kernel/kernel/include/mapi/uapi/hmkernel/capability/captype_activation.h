/*
 * Copyright (C) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.
 * Description: Captype activation
 * Author: Huawei OS Kernel Lab
 * Create: Mon Aug 12 21:46:25 2019
 */
/*
 * Must choose one GRANT type from ALL/NO/COARSE/FINE
 * Must choose one GRANTMOVE type from ALL/NO/COARSE
 */
CAPTYPE(Activation, 5, CAPNOGRANT(Activation)
		       CAPNOGRANTMOVE(Activation)
		       CAPDEFAULTSIZE(Activation),
	CAPMETHOD(Activation, Init)
	CAPMETHOD(Activation, Ready)
	CAPMETHOD(Activation, Recycle)
	CAPMETHOD(Activation, Kill)
	CAPMETHOD(Activation, LoadActvUctx)
	CAPMETHOD(Activation, LoadLastUctx)
	CAPMETHOD(Activation, StoreLastUctx)
	CAPMETHOD(Activation, HMSignalMask)
	CAPMETHOD(Activation, TriggerDetachOne)
	CAPMETHOD(Activation, AvailableExtFastcall)
	CAPMETHOD(Activation, PacCtrl)

	CAPERRNO(Activation, EHMERROR, ACTIVATION_WORKING,		"E_HM_ACTIVATION_WORKING")
	CAPERRNO(Activation, EHMERROR, ACTIVATION_INACTIVE,		"E_HM_ACTIVATION_INACTIVE")
	CAPERRNO(Activation, EHMERROR, ACTIVATION_NOTINIT,		"E_HM_ACTIVATION_NOTINIT")
	CAPERRNO(Activation, EHMERROR, ACTIVATION_CRASH,		"E_HM_ACTIVATION_CRASH")
	CAPERRNO(Activation, EHMERROR, ACTIVATION_STATE,		"E_HM_ACTIVATION_STATE")
	CAPERRNO(Activation, EHMERROR, ACTIVATION_BOUND,		"E_HM_ACTIVATION_BOUND")
	CAPERRNO(Activation, EHMERROR, ACTIVATION_EXP_NO_HANDLER,	"E_HM_ACTIVATION_EXP_NO_HANDLER")
	CAPERRNO(Activation, EHMERROR, ACTIVATION_WRONG_CHAIN,		"E_HM_ACTIVATION_WRONG_CHAIN")
	CAPERRNO(Activation, EHMERROR, ACTIVATION_RPC_RETRY,		"E_HM_ACTIVATION_RPC_RETRY")
	CAPERRNO(Activation, EHMERROR, ACTIVATION_NOT_ALLOW_REFWD,	"E_HM_ACTIVATION_NOT_ALLOW_REFWD")
	)

#ifdef CAP_EXPORT_API

#include <hmkernel/activation/local_area.h>

#define __CAP_ACTIVATION_OBJ_SIZE  2048U

#define __ACTV_WFERET_UPCALL_OK		((int)(0))
#define __ACTV_WFERET_UPCALL_RET	((int)(1))
#define __ACTV_WFERET_UPCALL_REWIND	((int)(2))
#define __ACTV_WFERET_UPCALL_CRASH	((int)(3))
#define __ACTV_WFERET_UPCALL_RETRY	((int)(4))

#define __ACTV_WFERET_KPAGEFAULT_OK	__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_KPAGEFAULT_RET	__ACTV_WFERET_UPCALL_RET
#define __ACTV_WFERET_KPAGEFAULT_REWIND	__ACTV_WFERET_UPCALL_REWIND

#define __ACTV_WFERET_LINUX_SYSCALL_OK		__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_LINUX_SYSCALL_RET		__ACTV_WFERET_UPCALL_RET
#define __ACTV_WFERET_LINUX_SYSCALL_REWIND	__ACTV_WFERET_UPCALL_REWIND
#define __ACTV_WFERET_LINUX_SYSCALL_CRASH	__ACTV_WFERET_UPCALL_CRASH

#define __ACTV_WFERET_POOL_GRANT_CHANGE_OK	__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_POOL_GRANT_CHANGE_RET	__ACTV_WFERET_UPCALL_RET
#define __ACTV_WFERET_POOL_GRANT_CHANGE_REWIND	__ACTV_WFERET_UPCALL_REWIND

#define __ACTV_WFERET_HMSIGNAL_OK	__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_HMSIGNAL_REWIND	__ACTV_WFERET_UPCALL_REWIND
#define __ACTV_WFERET_HMSIGNAL_CRASH	__ACTV_WFERET_UPCALL_CRASH

#define __ACTV_WFERET_SIGNAL_OK		__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_SIGNAL_REWIND	__ACTV_WFERET_UPCALL_REWIND
#define __ACTV_WFERET_SIGNAL_CRASH	__ACTV_WFERET_UPCALL_CRASH

#define __ACTV_WFERET_EXCEPTION_OK	__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_EXCEPTION_CRASH	__ACTV_WFERET_UPCALL_CRASH

#define __ACTV_WFERET_HYP_VMEXIT_OK		__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_HYP_VMEXIT_CRASH		__ACTV_WFERET_UPCALL_CRASH
#define __ACTV_WFERET_HYP_VMEXIT_REWIND		__ACTV_WFERET_UPCALL_REWIND

#define __ACTV_WFERET_HYP_MMIO_DISPATCHER_OK		__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_HYP_MMIO_DISPATCHER_CRASH		__ACTV_WFERET_UPCALL_CRASH
#define __ACTV_WFERET_HYP_MMIO_DISPATCHER_REWIND	__ACTV_WFERET_UPCALL_REWIND

#define __ACTV_WFERET_EVENTPOLL_OK		__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_EVENTPOLL_RET		__ACTV_WFERET_UPCALL_RET
#define __ACTV_WFERET_EVENTPOLL_REWIND		__ACTV_WFERET_UPCALL_REWIND
#define __ACTV_WFERET_EVENTPOLL_WAIT		((int)(4))

#define __ACTV_WFERET_POOL_PAGE_OK	__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_POOL_PAGE_RET	__ACTV_WFERET_UPCALL_RET
#define __ACTV_WFERET_POOL_PAGE_REWIND	__ACTV_WFERET_UPCALL_REWIND
#define __ACTV_WFERET_POOL_PAGE_CRASH	__ACTV_WFERET_UPCALL_CRASH

#define __ACTV_WFERET_FILE_CLOSE_OK		__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_FILE_CLOSE_RET		__ACTV_WFERET_UPCALL_RET
#define __ACTV_WFERET_FILE_CLOSE_REWIND		__ACTV_WFERET_UPCALL_REWIND

#define __ACTV_WFERET_CLOSE_ON_EXEC_OK		__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_CLOSE_ON_EXEC_RET		__ACTV_WFERET_UPCALL_RET
#define __ACTV_WFERET_CLOSE_ON_EXEC_REWIND	__ACTV_WFERET_UPCALL_REWIND

#define __ACTV_WFERET_SECCOMP_OK		__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_SECCOMP_RET		__ACTV_WFERET_UPCALL_RET
#define __ACTV_WFERET_SECCOMP_REWIND		__ACTV_WFERET_UPCALL_REWIND
#define __ACTV_WFERET_SECCOMP_CRASH		__ACTV_WFERET_UPCALL_CRASH
#define __ACTV_WFERET_SECCOMP_ACTION_MASK	0xffff0000U
#define __ACTV_WFERET_SECCOMP_DATA_MASK		0x0000ffffU
#define HM_SECCOMP_ACTION_ALLOW			0x7fff0000U
#define __ACTV_WFERET_SECCOMP_ALLOW		HM_SECCOMP_ACTION_ALLOW
#define __ACTV_WFERET_SECCOMP_TRAP		0x7ddd0000U // upcall signal for trap
#define __ACTV_WFERET_SECCOMP_KILL		0x7eee0000U
#define __ACTV_WFERET_SECCOMP_KILL_STRICT	0x7eef0000U // upcall signal for kill strict
#define __ACTV_WFERET_SECCOMP_KILL_PROCESS	0x7eff0000U // upcall signal for kill process

#define __ACTV_WFERET_RPCCNT_PUT_RET	__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_RPCCNT_PUT_REWIND	__ACTV_WFERET_UPCALL_REWIND
#define __ACTV_WFERET_RPCCNT_PUT_CRASH	__ACTV_WFERET_UPCALL_CRASH
#define __ACTV_WFERET_RPCCNT_PUT_RETRY	__ACTV_WFERET_UPCALL_RETRY

#define __ACTV_WFERET_BINDER_IOCTL_OK		__ACTV_WFERET_UPCALL_OK
#define __ACTV_WFERET_BINDER_IOCTL_RET		__ACTV_WFERET_UPCALL_RET
#define __ACTV_WFERET_BINDER_IOCTL_REWIND	__ACTV_WFERET_UPCALL_REWIND
#define __ACTV_WFERET_BINDER_IOCTL_POOL_JOIN	((int)(4))
#define __ACTV_WFERET_BINDER_IOCTL_SEND_DATA	((int)(5))
#define __ACTV_WFERET_BINDER_IOCTL_RPLY_DATA	((int)(6))
#define __ACTV_WFERET_BINDER_IOCTL_RETRY	((int)(7))

#define __ACTV_WFERET_PTRACE_SYSCALL_RET	__ACTV_WFERET_UPCALL_RET
#define __ACTV_WFERET_PTRACE_SYSCALL_RETRY	__ACTV_WFERET_UPCALL_REWIND

/*
 * Return value of vsfault handler:
 * 0:          do nothing. Trigger vsfault again if not assign a busy idx
 *             caller vspace.
 * E_HM_NOENT: Automatically assign a usable busy idx by kernel.
 * E_HM_AGAIN: Same as 0
 * Other: busy idx + 1. See mapi/uapi/hmkernel/ctrlmem/vspace.h
 */
#define __ACTV_WFERET_VSFAULT_AGAIN		__ACTV_WFERET_UPCALL_OK

#define __ACTV_LOAD_STAT_UCTX		(1UL << 1U)
#define __ACTV_LOAD_STAT_FPSIMD		(1UL << 3U)

/* flags for kpagefault kcall */
#define KPAGEFAULT_F_WRITE		(__U(1) << 6)
#define KPAGEFAULT_F_STATUS_MASK	0x3FUL	/* The fault status code from esr/fsr */

struct sysarg_actv_stat {
	struct arch_uctx uctx;
};

enum {
	CRIGHT_ACTIVATION_MAX
};

#endif
