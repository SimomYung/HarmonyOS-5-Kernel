/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2023. All rights reserved.
 * Description: XPM mode header
 * Author: Huawei OS Kernel Lab
 * Create: Wed Dec 12 22:48:00 2023
 */

#ifndef SYSMGR_MEMMGR_XPM_MODE_H
#define SYSMGR_MEMMGR_XPM_MODE_H
#include <hongmeng/errno.h>
#include <libstrict/strict.h>

struct vregion_s;
struct codesign_info_s;

struct xpm_report_info_s {
	unsigned long fid;
	unsigned long vm_size;
	uint64_t pos;
	struct codesign_info_s *pcs_info;
	uint64_t flags;
	union {
		unsigned long verified_datasize;
		const char *code_segment_str;
	};
	uint32_t prot;
	uint8_t etype;
	bool is_exec;
};

#define DEVELOPER_STATUS_UNINT 0
#define DEVELOPER_STATUS_ON 1
#define DEVELOPER_STATUS_OFF 2

enum xpm_ctrl_level {
	XPM_CTRL_LEVEL_SIGNATURE = 1,
	XPM_CTRL_LEVEL_DATA,
	XPM_CTRL_LEVEL_INTEGRITY,
	XPM_CTRL_LEVEL_PROT,
	XPM_CTRL_LEVEL_OWNERID,
	XPM_CTRL_LEVEL_INVAL,
};

enum xpm_event_type {
	XPM_EVENT_INIT_STATE = 1,
	XPM_EVENT_GET_SIGN_FAILED,
	XPM_EVENT_SIGN_INVALID,
	XPM_EVENT_FILE_FORMAT_UNDEF,
	XPM_EVENT_DATA_MMAP_CODE,
	XPM_EVENT_PAGE_CONTENT_TAMPERED,
	XPM_EVENT_INTEGRITY_VIOLATED,
	XPM_EVENT_OWNERID_INCONSISTENT,
	XPM_EVENT_ANON_EXEC_PROHIBITED,
	XPM_EVENT_SET_JIT_MEM_VIOLATED,
	XPM_EVENT_WRITE_JIT_MEM_VIOLATED,
	XPM_EVENT_EXEC_UNAUTHED_CODE,
};

enum xpm_sign_invalid_err {
	XPM_SIGN_OK = 0,
	XPM_SIGN_INVALID_UNSIGNED,
	XPM_SIGN_INVALID_VERIFICATION_FAIL,
	XPM_SIGN_INVALID_LOADING_DEBUG_CODE_IN_NON_DEVELOPER,
	XPM_SIGN_INVALID_OUT_OF_VERIFIED_RANGE,
};

struct xpm_info_init_state {
	int32_t old_status;
	int32_t new_status;
	uint64_t timestamp;
};

struct xpm_info_get_sign_failed {
	int32_t xpm_status;
	uint32_t provision_type;
	char *code_type;
	char *comm; // should be filled by hkids framework
	const char *filename;
	uint32_t vm_prot;
	uint8_t error_type;
	uint64_t pgoff;
	uint64_t vm_size;
	uint64_t timestamp; // should be filled by hkids framework
};

struct xpm_info_sign_invalid {
	int32_t xpm_status;
	uint32_t provision_type;
	char *code_type;
	char *comm; // should be filled by hkids framework
	const char *filename;
	uint32_t vm_prot;
	uint64_t pgoff;
	uint64_t vm_size;
	int8_t error_type;
	uint64_t verified_datasize;
	uint64_t timestamp; // should be filled by hkids framework
};

struct xpm_info_format_undefined {
	int32_t xpm_status;
	uint32_t provision_type;
	char *code_type;
	char *comm; // should be filled by hkids framework
	const char *filename;
	uint32_t cert_type;
	uint64_t timestamp; // should be filled by hkids framework
};

struct xpm_info_data_mmapped_as_code {
	int32_t xpm_status;
	uint32_t provision_type;
	char *comm; // should be regenerated by hkids framework
	const char *filename;
	uint32_t vm_prot;
	uint32_t cert_type;
	const char *code_segment_str;
	uint64_t pgoff;
	uint64_t vm_size;
	uint64_t timestamp; // should be filled by hkids framework
};

struct xpm_info_integrity_violated {
	int32_t xpm_status;
	uint32_t provision_type;
	const char *code_type;
	char *comm; // should be filled by hkids framework
	const char *filename;
	uint32_t vm_prot;
	uint64_t pgoff;
	uint64_t vm_size;
	uint64_t timestamp; // should be filled by hkids framework
};

struct xpm_info_ownerid_inconsist {
	int32_t xpm_status;
	uint32_t provision_type;
	char *code_type;
	char *comm; // should be filled by hkids framework
	const char *filename;
	uint32_t p_id_type;
	uint32_t f_id_type;
	uint64_t p_ownerid;
	uint64_t f_ownerid;
	uint64_t timestamp; // should be filled by hkids framework
};


struct xpm_info_set_jit_mem_violated {
	int32_t init_status;
	uint32_t provision_type;
	char *comm; // should be filled by hkids framework
	uint32_t vm_prot;
	uint64_t vm_flag;
	uint64_t timestamp; // should be filled by hkids framework
};

struct xpm_info_write_jit_mem_violated {
	int32_t init_status;
	uint32_t provision_type;
	char *comm; // should be filled by hkids framework
	const char *filename;
	uint32_t cert_type;
	uint64_t timestamp; // should be filled by hkids framework
};

struct xpm_hkids_info {
	int32_t event_type_id;
	union {
		struct xpm_info_init_state xi_init_state;
		struct xpm_info_get_sign_failed xi_get_sign_failed;
		struct xpm_info_sign_invalid xi_sign_invalid;
		struct xpm_info_format_undefined xi_format_ud;
		struct xpm_info_data_mmapped_as_code xi_data_mmap_code;
		struct xpm_info_integrity_violated xi_integrity_violated;
		struct xpm_info_ownerid_inconsist xi_ownerid_inconsist;
		struct xpm_info_set_jit_mem_violated xi_set_jit_mem_violated;
		struct xpm_info_write_jit_mem_violated xi_write_jit_mem_violated;
	} xpm_info_u;
};

void xpm_hkids_fill_event_get_sign_failed(struct xpm_info_get_sign_failed *xi_get_sign_failed,
					  struct xpm_report_info_s *info, const char *filename);

void xpm_hkids_fill_event_get_sign_invalid(struct xpm_info_sign_invalid *xi_sign_invalid,
					   struct xpm_report_info_s *info, const char *filename);

void xpm_hkids_fill_event_data_mmap_code(struct xpm_info_data_mmapped_as_code *xi_data_mmap_code,
					 struct xpm_report_info_s *info, const char *filename,
					 uint32_t cert_type);

void xpm_hkids_fill_event_integrity_violated(struct xpm_info_integrity_violated *xi_integrity_violated,
					     struct xpm_report_info_s *info, const char *filename);

void xpm_hkids_fill_event_ownerid_inconsistent(struct xpm_info_ownerid_inconsist *xi_ownerid_inconsist,
					       struct xpm_report_info_s *info, const char *filename,
					       uint32_t f_id_type, uint64_t f_ownerid);

void xpm_hkids_fill_event_set_jit_mem_violated(struct xpm_info_set_jit_mem_violated *xi_set_jit_mem_violated,
					       struct xpm_report_info_s *info);

void xpm_hkids_fill_event_write_jit_mem_violated(struct xpm_info_write_jit_mem_violated *xi_write_jit_mem_violated,
					       struct xpm_report_info_s *info, const char *filename,
					       uint32_t cert_type);

int xpm_hkids_report_info(struct xpm_hkids_info *hkids_info);

bool xpm_is_enabled(void);
int xpm_mode_of(void);
void xpm_init_system_recovery_mode(void);
void xpm_enable(int xpm_ctrl_level);
void xpm_disable(void);
bool hmxpm_advsecmode_on(void);

#if defined(CONFIG_SECURITY_XPM) && defined(CONFIG_DEBUG_BUILD)
int xpm_mode_write(void *buf, size_t len);
int xpm_mode_read(void *buf, size_t len);
#else
static inline int xpm_mode_write(void *buf, size_t len)
{
	UNUSED(buf, len);
	return E_HM_NOSYS;
}
static inline int xpm_mode_read(void *buf, size_t len)
{
	UNUSED(buf, len);
	return E_HM_NOSYS;
}
#endif

int xpm_dsmm_developer_mode_of(void);

#ifdef CONFIG_SECURITY_XPM
void xpm_hkids_report_jit_event(int event_type_id, const struct vregion_s *vr);
void xpm_hkids_report_integrity_event(const struct vregion_s *vr, uint32_t prot);
#else
static inline void xpm_hkids_report_jit_event(int event_type_id, const struct vregion_s *vr)
{
	UNUSED(event_type_id, vr);
}

static inline void xpm_hkids_report_integrity_event(const struct vregion_s *vr, uint32_t prot)
{
	UNUSED(vr, prot);
}
#endif
#endif
