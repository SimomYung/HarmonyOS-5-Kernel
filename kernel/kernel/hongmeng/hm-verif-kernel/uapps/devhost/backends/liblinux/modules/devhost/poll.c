/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2023-2023. All rights reserved.
 * Description: Liblinux poll support
 * Author: Huawei OS Kernel Lab
 * Create: Fri Mar 24 15:52:17 2023
 */
#include <linux/list.h>
#include <linux/poll.h>
#include <linux/slab.h>
#include <linux/securec.h>
#include <linux/version.h>

#include <devhost/poll.h>

#include "devhost.h"

#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,0)
typedef struct wait_queue_entry wait_queue_t;
#endif

struct kmem_cache *poll_cachep = NULL;

struct devhost_poll_wqueues;
struct devhost_poll_table_entry {
	wait_queue_t wait;                /* wait in LDK wait_address */
	wait_queue_head_t *wait_address;  /* wait_address in LDK device  */
	struct list_head list;            /* list in devhost poll wqueue */
	struct devhost_poll_wqueues *pwq; /* devhost poll wqueue */
};

/* Most devices do not have more than 2 wait_queue_head_t */
#define DH_INLINE_POLL_ENTRIES 2
struct devhost_poll_wqueues {
	poll_table pt;
	void *target;                    /* wakeup target */
	int (*wakeup)(void *target, unsigned int revents);
	struct list_head head; /* associate entries that exceed inline entries */
	int inline_index;
	struct devhost_poll_table_entry inline_entries[DH_INLINE_POLL_ENTRIES];
};

static int __devhost_pollwake(wait_queue_t *wait, unsigned mode,
			      int sync, void *key)
{
	int ret;
	struct devhost_poll_wqueues *pwq = NULL;
	struct devhost_poll_table_entry *entry = NULL;
	unsigned int revents = (unsigned int)(uintptr_t)key;

	if (unlikely(wait == NULL)) {
		pr_err("wakeup an invalid wait(NULL)\n");
		return -EINVAL;
	}

	entry = container_of(wait, struct devhost_poll_table_entry, wait);
	pwq = entry->pwq;
	if (unlikely((pwq == NULL) || (pwq->wakeup == NULL))) {
		pr_err("wakeup an invalid entry\n");
		return -EINVAL;
	}

	ret = pwq->wakeup(pwq->target, revents);
	if (ret < 0) {
		pr_debug("devhost pollwake revents(%#x) failed, err=%d\n", revents, ret);
	}

	return ret;
}

/* A devhost_poll_wqueues object manages the added entries generated by only
 * one poll call. This constraint ensures that poll_queue_proc and poll freewait
 * operations are mutually exclusive, that is, non-concurrent operations. */
static void __devhost_poll_queue_proc(struct file *file,
				      wait_queue_head_t *whead,
				      poll_table *pt)
{
	wait_queue_t *wait = NULL;
	struct devhost_poll_wqueues *pwq = NULL;
	struct devhost_poll_table_entry *entry = NULL;

	if (unlikely((whead == NULL) || (pt == NULL))) {
		return;
	}

	pwq = (struct devhost_poll_wqueues *)pt;
	if (pwq->inline_index < DH_INLINE_POLL_ENTRIES) {
		entry = pwq->inline_entries + pwq->inline_index;
		pwq->inline_index++;
	} else {
		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
		if (unlikely(entry == NULL)) {
			pr_err("devhost alloc poll table entry failed\n");
			return;
		}
		list_add_tail(&entry->list, &pwq->head);
	}
	wait = &entry->wait;
	init_waitqueue_func_entry(wait, __devhost_pollwake);
	entry->wait_address = whead;
	entry->pwq = pwq;
	add_wait_queue(whead, wait);
}

static void __devhost_poll_freewait(void *pt)
{
	int i;
	struct devhost_poll_table_entry *pos = NULL;
	struct devhost_poll_table_entry *next = NULL;
	struct devhost_poll_wqueues *pwq = NULL;

	if (pt == NULL) {
		return;
	}

	pwq = (struct devhost_poll_wqueues *)pt;
	if (unlikely(pwq->inline_index == 0)) {
		/* no wait entry is added to the wait queue head */
		kmem_cache_free(poll_cachep, pwq);
		return;
	}

	for (i = 0; i < pwq->inline_index; i++) {
		pos = pwq->inline_entries + i;
		remove_wait_queue(pos->wait_address, &pos->wait);
	}

	/* There is a high probability that the head is empty */
	list_for_each_entry_safe(pos, next, &pwq->head, list) {
		list_del(&pos->list);
		remove_wait_queue(pos->wait_address, &pos->wait);
		kfree(pos);
	}
	kmem_cache_free(poll_cachep, pwq);
}

int devhost_poll_initwait(void *poll_info, void **pt)
{
	struct devhost_poll_wqueues *pwq = NULL;
	struct devhost_poll_wqueues_info *pwq_info =  NULL;
	struct devhost_poll_info *pinfo = (struct devhost_poll_info *)poll_info;

	if (unlikely((pt == NULL) || (pinfo == NULL) ||
		     (pinfo->pwq_info == NULL) || (pinfo->target == NULL) ||
		     (pinfo->wakeup == NULL)) || (poll_cachep == NULL)) {
		pr_err("devhost poll initwait input invalid\n");
		return -EINVAL;
	}

	pwq = kmem_cache_zalloc(poll_cachep, GFP_KERNEL);
	if (unlikely(pwq == NULL)) {
		pr_err("devhost alloc pwq info failed\n");
		return -ENOMEM;
	}

	INIT_LIST_HEAD(&pwq->head);
	pwq->target = pinfo->target;
	pwq->wakeup = pinfo->wakeup;
	init_poll_funcptr(&pwq->pt, __devhost_poll_queue_proc);
	*pt = (void *)&pwq->pt;

	pwq_info = (struct devhost_poll_wqueues_info *)pinfo->pwq_info;
	pwq_info->pwq = pwq;
	pwq_info->release = __devhost_poll_freewait;

	return 0;
}

int __init devhost_poll_init(void)
{
	poll_cachep = kmem_cache_create("poll_areas", sizeof(struct devhost_poll_wqueues),
					__alignof__(struct devhost_poll_wqueues), 0, NULL);
	if (poll_cachep == NULL)
		return -ENOMEM;

	return 0;
}
