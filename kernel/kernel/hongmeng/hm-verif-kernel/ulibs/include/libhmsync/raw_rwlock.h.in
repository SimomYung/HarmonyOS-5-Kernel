/*
 * Copyright (C) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.
 * Description: Interfaces of raw_rwlock
 * Author: Huawei OS Kernel Lab
 * Create: Sun May 05 11:32:50 2019
 */
#ifndef LIBHMSYNC_RAW_RWLOCK_H
#define LIBHMSYNC_RAW_RWLOCK_H

#include <hmkernel/capability.h>
#include <hmkernel/futex.h>
#include <hongmeng/types.h>
#include <vsync/atomic.h>

#define RAW_RWLOCK_XDEP_MAX_HOLDERS   __FUTEX_XDEP_MAX_BUCKET_HOLDERS

/*
 * Only shared attribute is supported for now,
 * may be extended with bit-field.
 */
struct raw_rwlock_attr {
	unsigned int wrhold	: 1;
	unsigned int shared	: 1;
	unsigned int xdep     	: 1;
	unsigned int xdep_trace	: 1;
	unsigned int reserved	: 28;
};

#define RAW_MUTEX_IMPL_WITH_LOCKID 1
#define RAW_MUTEX_IMPL_NO_LOCKID 2
#define RAW_MUTEX_IMPL @RAW_MUTEX_IMPL@

#define RAW_MUTEX_WITH_LOCKTRACE 1
#define RAW_MUTEX_NO_LOCKTRACE 2
#define RAW_MUTEX_LOCKTRACE @RAW_MUTEX_LOCKTRACE@

/*
 * lock records the number of rwlock callers:
 * lock = 0 means rwlock unlock.
 * positive lock values read lock callers.
 * waiters means there is a write lock occupied.
 * attr: rwlock attributes:
 *	shared(1bit):
 *		0 ==> private rwlock (default)
 *		1 ==> shared rwlock
 */
struct raw_rwlock {
	vatomic32_t lock;
	vatomic32_t waiters;
	struct raw_rwlock_attr attr;
#if RAW_MUTEX_IMPL == RAW_MUTEX_IMPL_WITH_LOCKID
	vatomic32_t lock_id;
#endif
};

struct raw_rwlock_xdep {
	struct raw_rwlock rwlock; /* must be the first position */
	vatomic64_t holders_bm;
	cref_t holders[RAW_RWLOCK_XDEP_MAX_HOLDERS];
	uint16_t recursive_locks[RAW_RWLOCK_XDEP_MAX_HOLDERS];
};

#if RAW_MUTEX_IMPL == RAW_MUTEX_IMPL_WITH_LOCKID
#define RAW_RDLOCK_INITIALIZER {.lock = VATOMIC_INIT(0), \
				.waiters = VATOMIC_INIT(0), .attr = {.wrhold = 0U, .shared = 0U, .xdep = 0U, .xdep_trace = 0U, .reserved = 0U}, \
				.lock_id = VATOMIC_INIT(0)}
#define RAW_RDLOCK_INITIALIZER_NOTRACE {.lock = VATOMIC_INIT(0), \
				.waiters = VATOMIC_INIT(0), .attr = {.wrhold = 0U, .shared = 0U, .xdep = 0U, .xdep_trace = 0U, .reserved = 0U}, \
				.lock_id = VATOMIC_INIT(~0U)}
#else
#define RAW_RDLOCK_INITIALIZER {.lock = VATOMIC_INIT(0), \
				.waiters = VATOMIC_INIT(0), .attr = {.wrhold = 0U, .shared = 0U, .xdep = 0U, .xdep_trace = 0U, .reserved = 0U}}
#define RAW_RDLOCK_INITIALIZER_NOTRACE RAW_RDLOCK_INITIALIZER
#endif

#undef RAW_MUTEX_IMPL

void raw_rwlock_init(struct raw_rwlock *rwlock, struct raw_rwlock_attr *attr);
int raw_rwlock_tryrdlock(struct raw_rwlock *rwlock);
int raw_rwlock_rdlock(struct raw_rwlock *rwlock);
int raw_rwlock_wrlock(struct raw_rwlock *rwlock);
int raw_rwlock_trywrlock(struct raw_rwlock *rwlock);
int raw_rwlock_downgrade(struct raw_rwlock *rwlock);
int raw_rwlock_try_upgrade(struct raw_rwlock *rwlock);
int raw_rwlock_unlock(struct raw_rwlock *rwlock);
void raw_rwlock_destroy(struct raw_rwlock *rwlock);
int raw_rwlock_getwaiter(struct raw_rwlock *rwlock);

void disable_raw_rwlock(void);
void enable_raw_rwlock(void);
_Bool is_raw_rwlock_disabled(void);

void raw_rwlock_attr_setshared(struct raw_rwlock_attr *attr, int shared);
void raw_rwlock_attr_set_wrhold(struct raw_rwlock_attr *attr, int wrhold);
void raw_rwlock_init_shared(struct raw_rwlock *rwlock);
void raw_rwlock_init_xdep(struct raw_rwlock_xdep *rwlock_xdep, struct raw_rwlock_attr *attr);

#endif
