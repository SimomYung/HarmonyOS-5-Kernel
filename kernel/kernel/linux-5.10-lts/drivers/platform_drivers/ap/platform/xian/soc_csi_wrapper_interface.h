/*
 * Copyright (C) Huawei Technologies Co., Ltd. 2001-2024. All rights reserved.
 *
 * Description: file name soc_csi_wrapper_interface.h
 *              Auto gen from file "nManager_CSI_WRAPPER.xml"
 * Author     : Generated by tool
 * Create     : 2024-6-11 15:56:53
 */

#ifndef __SOC_CSI_WRAPPER_INTERFACE_H__
#define __SOC_CSI_WRAPPER_INTERFACE_H__


/*****************************************************************************
  1 Other head file
*****************************************************************************/


#ifdef __cplusplus
#if __cplusplus
    extern "C" {
#endif
#endif


/*****************************************************************************
  2 macro
*****************************************************************************/

/****************************************************************************
                     (1/1) CSI_WRAPPER
 ****************************************************************************/
#ifndef __SOC_H_FOR_ASM__


/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_0_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_0_ADDR(base)                  ((base) + (0x000UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_0_SET_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_0_SET_ADDR(base)              ((base) + (0x004UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_0_CLEAR_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_0_CLEAR_ADDR(base)            ((base) + (0x008UL))

/* Register description: Soft reset control for each module which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_RESET_0_UNION */
#define SOC_CSI_WRAPPER_CSI_RESET_0_ADDR(base)                ((base) + (0x00CUL))

/* Register description: PHY CSI-A debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_A_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_ADDR(base)              ((base) + (0x010UL))

/* Register description: PHY CSI-B debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_B_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_ADDR(base)              ((base) + (0x014UL))

/* Register description: PHY CSI-C debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_C_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_ADDR(base)              ((base) + (0x018UL))

/* Register description: csi and mudp idi intf sel
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_ABC_IDI_SEL_UNION */
#define SOC_CSI_WRAPPER_CSI_ABC_IDI_SEL_ADDR(base)            ((base) + (0x01CUL))

/* Register description: force pclk on of csi controller
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_ABC_FORCE_PCLKON_UNION */
#define SOC_CSI_WRAPPER_CSI_ABC_FORCE_PCLKON_ADDR(base)       ((base) + (0x020UL))

/* Register description: used to query security status
   Bit domain definition UNION:  SOC_CSI_WRAPPER_SECURE_ST_UNION */
#define SOC_CSI_WRAPPER_SECURE_ST_ADDR(base)                  ((base) + (0x300UL))

/* Register description: mudp idi rs clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_MUDP_RS_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CSI_MUDP_RS_CLKRST_ADDR(base)         ((base) + (0x304UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_1_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_1_ADDR(base)                  ((base) + (0x400UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_1_SET_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_1_SET_ADDR(base)              ((base) + (0x404UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_1_CLEAR_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_1_CLEAR_ADDR(base)            ((base) + (0x408UL))

/* Register description: Soft reset control for each module which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_RESET_1_UNION */
#define SOC_CSI_WRAPPER_CSI_RESET_1_ADDR(base)                ((base) + (0x40CUL))

/* Register description: PHY CSI-D debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_D_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_ADDR(base)              ((base) + (0x410UL))

/* Register description: force pclk on of csi controller
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_D_FORCE_PCLKON_UNION */
#define SOC_CSI_WRAPPER_CSI_D_FORCE_PCLKON_ADDR(base)         ((base) + (0x414UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_2_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_2_ADDR(base)                  ((base) + (0x500UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_2_SET_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_2_SET_ADDR(base)              ((base) + (0x504UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_2_CLEAR_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_2_CLEAR_ADDR(base)            ((base) + (0x508UL))

/* Register description: Soft reset control for each module which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_RESET_2_UNION */
#define SOC_CSI_WRAPPER_CSI_RESET_2_ADDR(base)                ((base) + (0x50CUL))

/* Register description: PHY CSI-E debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_E_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_ADDR(base)              ((base) + (0x510UL))

/* Register description: force pclk on of csi controller
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_E_FORCE_PCLKON_UNION */
#define SOC_CSI_WRAPPER_CSI_E_FORCE_PCLKON_ADDR(base)         ((base) + (0x514UL))

/* Register description: enables to control CSIA Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIA_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSIA_CTRL_ADDR(base)                  ((base) + (0x600UL))

/* Register description: enables to control CSIB Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIB_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSIB_CTRL_ADDR(base)                  ((base) + (0x604UL))

/* Register description: enables to control CSIC Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIC_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSIC_CTRL_ADDR(base)                  ((base) + (0x608UL))

/* Register description: enables to control CSID Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSID_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSID_CTRL_ADDR(base)                  ((base) + (0x60CUL))

/* Register description: enables to control CSIE Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIE_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSIE_CTRL_ADDR(base)                  ((base) + (0x610UL))

/* Register description: enables to control CSIF Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIF_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSIF_CTRL_ADDR(base)                  ((base) + (0x614UL))

/* Register description: enables to control CSIG Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIG_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSIG_CTRL_ADDR(base)                  ((base) + (0x618UL))

/* Register description: CSI Debug control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_DBG_UNION */
#define SOC_CSI_WRAPPER_CSI_DBG_ADDR(base)                    ((base) + (0x800UL))

/* Register description: CSIA Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIA_DBG_UNION */
#define SOC_CSI_WRAPPER_CSIA_DBG_ADDR(base)                   ((base) + (0x804UL))

/* Register description: CSIB Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIB_DBG_UNION */
#define SOC_CSI_WRAPPER_CSIB_DBG_ADDR(base)                   ((base) + (0x808UL))

/* Register description: CSIB Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIC_DBG_UNION */
#define SOC_CSI_WRAPPER_CSIC_DBG_ADDR(base)                   ((base) + (0x80CUL))

/* Register description: CSIB Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSID_DBG_UNION */
#define SOC_CSI_WRAPPER_CSID_DBG_ADDR(base)                   ((base) + (0x810UL))

/* Register description: CSIB Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIE_DBG_UNION */
#define SOC_CSI_WRAPPER_CSIE_DBG_ADDR(base)                   ((base) + (0x814UL))

/* Register description: CSIB Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIF_DBG_UNION */
#define SOC_CSI_WRAPPER_CSIF_DBG_ADDR(base)                   ((base) + (0x818UL))

/* Register description: CSIB Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIG_DBG_UNION */
#define SOC_CSI_WRAPPER_CSIG_DBG_ADDR(base)                   ((base) + (0x81CUL))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_DBG_TESTDOUT_SEL_UNION */
#define SOC_CSI_WRAPPER_PHY_DBG_TESTDOUT_SEL_ADDR(base)       ((base) + (0x820UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIF_CGR_UNION */
#define SOC_CSI_WRAPPER_CSIF_CGR_ADDR(base)                   ((base) + (0x900UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIF_CGR_SET_UNION */
#define SOC_CSI_WRAPPER_CSIF_CGR_SET_ADDR(base)               ((base) + (0x904UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIF_CGR_CLEAR_UNION */
#define SOC_CSI_WRAPPER_CSIF_CGR_CLEAR_ADDR(base)             ((base) + (0x908UL))

/* Register description: Soft reset control for each module which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIF_RESET_UNION */
#define SOC_CSI_WRAPPER_CSIF_RESET_ADDR(base)                 ((base) + (0x90CUL))

/* Register description: PHY CSI-F debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_F_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_ADDR(base)              ((base) + (0x910UL))

/* Register description: csi and mudp idi intf sel
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_F_IDI_SEL_UNION */
#define SOC_CSI_WRAPPER_CSI_F_IDI_SEL_ADDR(base)              ((base) + (0x914UL))

/* Register description: force pclk on of csi controller
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_F_FORCE_PCLKON_UNION */
#define SOC_CSI_WRAPPER_CSI_F_FORCE_PCLKON_ADDR(base)         ((base) + (0x918UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIG_CGR_UNION */
#define SOC_CSI_WRAPPER_CSIG_CGR_ADDR(base)                   ((base) + (0xA00UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIG_CGR_SET_UNION */
#define SOC_CSI_WRAPPER_CSIG_CGR_SET_ADDR(base)               ((base) + (0xA04UL))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIG_CGR_CLEAR_UNION */
#define SOC_CSI_WRAPPER_CSIG_CGR_CLEAR_ADDR(base)             ((base) + (0xA08UL))

/* Register description: Soft reset control for each module which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIG_RESET_UNION */
#define SOC_CSI_WRAPPER_CSIG_RESET_ADDR(base)                 ((base) + (0xA0CUL))

/* Register description: PHY CSI-G debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_G_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_ADDR(base)              ((base) + (0xA10UL))

/* Register description: csi and mudp idi intf sel
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_G_IDI_SEL_UNION */
#define SOC_CSI_WRAPPER_CSI_G_IDI_SEL_ADDR(base)              ((base) + (0xA14UL))

/* Register description: force pclk on of csi controller
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_G_FORCE_PCLKON_UNION */
#define SOC_CSI_WRAPPER_CSI_G_FORCE_PCLKON_ADDR(base)         ((base) + (0xA18UL))

/* Register description: PHY Test interface control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_ADDR(base)          ((base) + (0xB00UL))

/* Register description: PHY Test interface dout
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_TEST_DOUT_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_DOUT_ADDR(base)          ((base) + (0xB04UL))

/* Register description: PHY reset control.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_SHUTDOWN_RST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_SHUTDOWN_RST_CTRL_ADDR(base)  ((base) + (0xB08UL))

/* Register description: PHY mode and enable control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_ADDR(base)               ((base) + (0xB0CUL))

/* Register description: PHY lock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_LOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_LOCK_CTRL_ADDR(base)          ((base) + (0xB10UL))

/* Register description: PHY unlock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_UNLOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_UNLOCK_CTRL_ADDR(base)        ((base) + (0xB14UL))

/* Register description: PHY lock state
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_LOCK_STATE_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_LOCK_STATE_ADDR(base)         ((base) + (0xB18UL))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_DBG_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_DBG_ADDR(base)                ((base) + (0xB1CUL))

/* Register description: PHY clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_CLKRST_ADDR(base)             ((base) + (0xB20UL))

/* Register description: PHY Test interface control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_ADDR(base)          ((base) + (0xB40UL))

/* Register description: PHY Test interface dout
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_TEST_DOUT_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_DOUT_ADDR(base)          ((base) + (0xB44UL))

/* Register description: PHY reset control.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_SHUTDOWN_RST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_SHUTDOWN_RST_CTRL_ADDR(base)  ((base) + (0xB48UL))

/* Register description: PHY mode and enable control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_ADDR(base)               ((base) + (0xB4CUL))

/* Register description: PHY lock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_LOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_LOCK_CTRL_ADDR(base)          ((base) + (0xB50UL))

/* Register description: PHY unlock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_UNLOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_UNLOCK_CTRL_ADDR(base)        ((base) + (0xB54UL))

/* Register description: PHY lock state
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_LOCK_STATE_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_LOCK_STATE_ADDR(base)         ((base) + (0xB58UL))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_DBG_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_DBG_ADDR(base)                ((base) + (0xB5CUL))

/* Register description: PHY clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_CLKRST_ADDR(base)             ((base) + (0xB60UL))

/* Register description: PHY Test interface control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_ADDR(base)          ((base) + (0xB80UL))

/* Register description: PHY Test interface dout
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_TEST_DOUT_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_DOUT_ADDR(base)          ((base) + (0xB84UL))

/* Register description: PHY reset control.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_SHUTDOWN_RST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_SHUTDOWN_RST_CTRL_ADDR(base)  ((base) + (0xB88UL))

/* Register description: PHY mode and enable control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_ADDR(base)               ((base) + (0xB8CUL))

/* Register description: PHY lock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_LOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_LOCK_CTRL_ADDR(base)          ((base) + (0xB90UL))

/* Register description: PHY unlock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_UNLOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_UNLOCK_CTRL_ADDR(base)        ((base) + (0xB94UL))

/* Register description: PHY lock state
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_LOCK_STATE_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_LOCK_STATE_ADDR(base)         ((base) + (0xB98UL))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_DBG_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_DBG_ADDR(base)                ((base) + (0xB9CUL))

/* Register description: PHY clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_CLKRST_ADDR(base)             ((base) + (0xBA0UL))

/* Register description: PHY Test interface control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_ADDR(base)          ((base) + (0xBC0UL))

/* Register description: PHY Test interface dout
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_TEST_DOUT_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_DOUT_ADDR(base)          ((base) + (0xBC4UL))

/* Register description: PHY reset control.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_SHUTDOWN_RST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_SHUTDOWN_RST_CTRL_ADDR(base)  ((base) + (0xBC8UL))

/* Register description: PHY mode and enable control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_ADDR(base)               ((base) + (0xBCCUL))

/* Register description: PHY lock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_LOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_LOCK_CTRL_ADDR(base)          ((base) + (0xBD0UL))

/* Register description: PHY unlock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_UNLOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_UNLOCK_CTRL_ADDR(base)        ((base) + (0xBD4UL))

/* Register description: PHY lock state
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_LOCK_STATE_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_LOCK_STATE_ADDR(base)         ((base) + (0xBD8UL))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_DBG_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_DBG_ADDR(base)                ((base) + (0xBDCUL))

/* Register description: PHY clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_CLKRST_ADDR(base)             ((base) + (0xBE0UL))

/* Register description: PHY Test interface control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_ADDR(base)          ((base) + (0xC00UL))

/* Register description: PHY Test interface dout
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_TEST_DOUT_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_DOUT_ADDR(base)          ((base) + (0xC04UL))

/* Register description: PHY reset control.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_SHUTDOWN_RST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_SHUTDOWN_RST_CTRL_ADDR(base)  ((base) + (0xC08UL))

/* Register description: PHY mode and enable control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_ADDR(base)               ((base) + (0xC0CUL))

/* Register description: PHY lock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_LOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_LOCK_CTRL_ADDR(base)          ((base) + (0xC10UL))

/* Register description: PHY unlock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_UNLOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_UNLOCK_CTRL_ADDR(base)        ((base) + (0xC14UL))

/* Register description: PHY lock state
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_LOCK_STATE_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_LOCK_STATE_ADDR(base)         ((base) + (0xC18UL))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_DBG_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_DBG_ADDR(base)                ((base) + (0xC1CUL))

/* Register description: PHY clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_CLKRST_ADDR(base)             ((base) + (0xC20UL))

/* Register description: PHY Test interface control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_ADDR(base)          ((base) + (0xC40UL))

/* Register description: PHY Test interface dout
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_TEST_DOUT_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_DOUT_ADDR(base)          ((base) + (0xC44UL))

/* Register description: PHY reset control.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_SHUTDOWN_RST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_SHUTDOWN_RST_CTRL_ADDR(base)  ((base) + (0xC48UL))

/* Register description: PHY mode and enable control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_ADDR(base)               ((base) + (0xC4CUL))

/* Register description: PHY lock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_LOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_LOCK_CTRL_ADDR(base)          ((base) + (0xC50UL))

/* Register description: PHY unlock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_UNLOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_UNLOCK_CTRL_ADDR(base)        ((base) + (0xC54UL))

/* Register description: PHY lock state
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_LOCK_STATE_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_LOCK_STATE_ADDR(base)         ((base) + (0xC58UL))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_DBG_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_DBG_ADDR(base)                ((base) + (0xC5CUL))

/* Register description: PHY clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_CLKRST_ADDR(base)             ((base) + (0xC60UL))

/* Register description: secure cfg register
   Bit domain definition UNION:  SOC_CSI_WRAPPER_S_UNION */
#define SOC_CSI_WRAPPER_S_ADDR(base)                          ((base) + (0xE00UL))

/* Register description: CSI wrapper idi clock control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_ADDR(base)          ((base) + (0xE80UL))


#else


/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_0_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_0_ADDR(base)                  ((base) + (0x000))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_0_SET_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_0_SET_ADDR(base)              ((base) + (0x004))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_0_CLEAR_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_0_CLEAR_ADDR(base)            ((base) + (0x008))

/* Register description: Soft reset control for each module which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_RESET_0_UNION */
#define SOC_CSI_WRAPPER_CSI_RESET_0_ADDR(base)                ((base) + (0x00C))

/* Register description: PHY CSI-A debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_A_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_ADDR(base)              ((base) + (0x010))

/* Register description: PHY CSI-B debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_B_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_ADDR(base)              ((base) + (0x014))

/* Register description: PHY CSI-C debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_C_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_ADDR(base)              ((base) + (0x018))

/* Register description: csi and mudp idi intf sel
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_ABC_IDI_SEL_UNION */
#define SOC_CSI_WRAPPER_CSI_ABC_IDI_SEL_ADDR(base)            ((base) + (0x01C))

/* Register description: force pclk on of csi controller
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_ABC_FORCE_PCLKON_UNION */
#define SOC_CSI_WRAPPER_CSI_ABC_FORCE_PCLKON_ADDR(base)       ((base) + (0x020))

/* Register description: used to query security status
   Bit domain definition UNION:  SOC_CSI_WRAPPER_SECURE_ST_UNION */
#define SOC_CSI_WRAPPER_SECURE_ST_ADDR(base)                  ((base) + (0x300))

/* Register description: mudp idi rs clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_MUDP_RS_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CSI_MUDP_RS_CLKRST_ADDR(base)         ((base) + (0x304))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_1_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_1_ADDR(base)                  ((base) + (0x400))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_1_SET_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_1_SET_ADDR(base)              ((base) + (0x404))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_1_CLEAR_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_1_CLEAR_ADDR(base)            ((base) + (0x408))

/* Register description: Soft reset control for each module which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_RESET_1_UNION */
#define SOC_CSI_WRAPPER_CSI_RESET_1_ADDR(base)                ((base) + (0x40C))

/* Register description: PHY CSI-D debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_D_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_ADDR(base)              ((base) + (0x410))

/* Register description: force pclk on of csi controller
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_D_FORCE_PCLKON_UNION */
#define SOC_CSI_WRAPPER_CSI_D_FORCE_PCLKON_ADDR(base)         ((base) + (0x414))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_2_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_2_ADDR(base)                  ((base) + (0x500))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_2_SET_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_2_SET_ADDR(base)              ((base) + (0x504))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_CGR_2_CLEAR_UNION */
#define SOC_CSI_WRAPPER_CSI_CGR_2_CLEAR_ADDR(base)            ((base) + (0x508))

/* Register description: Soft reset control for each module which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_RESET_2_UNION */
#define SOC_CSI_WRAPPER_CSI_RESET_2_ADDR(base)                ((base) + (0x50C))

/* Register description: PHY CSI-E debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_E_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_ADDR(base)              ((base) + (0x510))

/* Register description: force pclk on of csi controller
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_E_FORCE_PCLKON_UNION */
#define SOC_CSI_WRAPPER_CSI_E_FORCE_PCLKON_ADDR(base)         ((base) + (0x514))

/* Register description: enables to control CSIA Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIA_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSIA_CTRL_ADDR(base)                  ((base) + (0x600))

/* Register description: enables to control CSIB Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIB_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSIB_CTRL_ADDR(base)                  ((base) + (0x604))

/* Register description: enables to control CSIC Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIC_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSIC_CTRL_ADDR(base)                  ((base) + (0x608))

/* Register description: enables to control CSID Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSID_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSID_CTRL_ADDR(base)                  ((base) + (0x60C))

/* Register description: enables to control CSIE Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIE_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSIE_CTRL_ADDR(base)                  ((base) + (0x610))

/* Register description: enables to control CSIF Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIF_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSIF_CTRL_ADDR(base)                  ((base) + (0x614))

/* Register description: enables to control CSIG Host integration as well as the CDPHY attached to it.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIG_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSIG_CTRL_ADDR(base)                  ((base) + (0x618))

/* Register description: CSI Debug control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_DBG_UNION */
#define SOC_CSI_WRAPPER_CSI_DBG_ADDR(base)                    ((base) + (0x800))

/* Register description: CSIA Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIA_DBG_UNION */
#define SOC_CSI_WRAPPER_CSIA_DBG_ADDR(base)                   ((base) + (0x804))

/* Register description: CSIB Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIB_DBG_UNION */
#define SOC_CSI_WRAPPER_CSIB_DBG_ADDR(base)                   ((base) + (0x808))

/* Register description: CSIB Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIC_DBG_UNION */
#define SOC_CSI_WRAPPER_CSIC_DBG_ADDR(base)                   ((base) + (0x80C))

/* Register description: CSIB Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSID_DBG_UNION */
#define SOC_CSI_WRAPPER_CSID_DBG_ADDR(base)                   ((base) + (0x810))

/* Register description: CSIB Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIE_DBG_UNION */
#define SOC_CSI_WRAPPER_CSIE_DBG_ADDR(base)                   ((base) + (0x814))

/* Register description: CSIB Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIF_DBG_UNION */
#define SOC_CSI_WRAPPER_CSIF_DBG_ADDR(base)                   ((base) + (0x818))

/* Register description: CSIB Debug control2
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIG_DBG_UNION */
#define SOC_CSI_WRAPPER_CSIG_DBG_ADDR(base)                   ((base) + (0x81C))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_DBG_TESTDOUT_SEL_UNION */
#define SOC_CSI_WRAPPER_PHY_DBG_TESTDOUT_SEL_ADDR(base)       ((base) + (0x820))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIF_CGR_UNION */
#define SOC_CSI_WRAPPER_CSIF_CGR_ADDR(base)                   ((base) + (0x900))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIF_CGR_SET_UNION */
#define SOC_CSI_WRAPPER_CSIF_CGR_SET_ADDR(base)               ((base) + (0x904))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIF_CGR_CLEAR_UNION */
#define SOC_CSI_WRAPPER_CSIF_CGR_CLEAR_ADDR(base)             ((base) + (0x908))

/* Register description: Soft reset control for each module which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIF_RESET_UNION */
#define SOC_CSI_WRAPPER_CSIF_RESET_ADDR(base)                 ((base) + (0x90C))

/* Register description: PHY CSI-F debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_F_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_ADDR(base)              ((base) + (0x910))

/* Register description: csi and mudp idi intf sel
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_F_IDI_SEL_UNION */
#define SOC_CSI_WRAPPER_CSI_F_IDI_SEL_ADDR(base)              ((base) + (0x914))

/* Register description: force pclk on of csi controller
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_F_FORCE_PCLKON_UNION */
#define SOC_CSI_WRAPPER_CSI_F_FORCE_PCLKON_ADDR(base)         ((base) + (0x918))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIG_CGR_UNION */
#define SOC_CSI_WRAPPER_CSIG_CGR_ADDR(base)                   ((base) + (0xA00))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIG_CGR_SET_UNION */
#define SOC_CSI_WRAPPER_CSIG_CGR_SET_ADDR(base)               ((base) + (0xA04))

/* Register description: used to gate the clock which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIG_CGR_CLEAR_UNION */
#define SOC_CSI_WRAPPER_CSIG_CGR_CLEAR_ADDR(base)             ((base) + (0xA08))

/* Register description: Soft reset control for each module which is generally controlled by HW
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSIG_RESET_UNION */
#define SOC_CSI_WRAPPER_CSIG_RESET_ADDR(base)                 ((base) + (0xA0C))

/* Register description: PHY CSI-G debug status.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_PHY_CSI_G_DBG_UNION */
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_ADDR(base)              ((base) + (0xA10))

/* Register description: csi and mudp idi intf sel
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_G_IDI_SEL_UNION */
#define SOC_CSI_WRAPPER_CSI_G_IDI_SEL_ADDR(base)              ((base) + (0xA14))

/* Register description: force pclk on of csi controller
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_G_FORCE_PCLKON_UNION */
#define SOC_CSI_WRAPPER_CSI_G_FORCE_PCLKON_ADDR(base)         ((base) + (0xA18))

/* Register description: PHY Test interface control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_ADDR(base)          ((base) + (0xB00))

/* Register description: PHY Test interface dout
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_TEST_DOUT_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_DOUT_ADDR(base)          ((base) + (0xB04))

/* Register description: PHY reset control.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_SHUTDOWN_RST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_SHUTDOWN_RST_CTRL_ADDR(base)  ((base) + (0xB08))

/* Register description: PHY mode and enable control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_ADDR(base)               ((base) + (0xB0C))

/* Register description: PHY lock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_LOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_LOCK_CTRL_ADDR(base)          ((base) + (0xB10))

/* Register description: PHY unlock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_UNLOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_UNLOCK_CTRL_ADDR(base)        ((base) + (0xB14))

/* Register description: PHY lock state
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_LOCK_STATE_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_LOCK_STATE_ADDR(base)         ((base) + (0xB18))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_DBG_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_DBG_ADDR(base)                ((base) + (0xB1C))

/* Register description: PHY clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_A_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CDPHY_A_CLKRST_ADDR(base)             ((base) + (0xB20))

/* Register description: PHY Test interface control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_ADDR(base)          ((base) + (0xB40))

/* Register description: PHY Test interface dout
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_TEST_DOUT_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_DOUT_ADDR(base)          ((base) + (0xB44))

/* Register description: PHY reset control.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_SHUTDOWN_RST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_SHUTDOWN_RST_CTRL_ADDR(base)  ((base) + (0xB48))

/* Register description: PHY mode and enable control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_ADDR(base)               ((base) + (0xB4C))

/* Register description: PHY lock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_LOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_LOCK_CTRL_ADDR(base)          ((base) + (0xB50))

/* Register description: PHY unlock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_UNLOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_UNLOCK_CTRL_ADDR(base)        ((base) + (0xB54))

/* Register description: PHY lock state
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_LOCK_STATE_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_LOCK_STATE_ADDR(base)         ((base) + (0xB58))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_DBG_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_DBG_ADDR(base)                ((base) + (0xB5C))

/* Register description: PHY clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_B_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CDPHY_B_CLKRST_ADDR(base)             ((base) + (0xB60))

/* Register description: PHY Test interface control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_ADDR(base)          ((base) + (0xB80))

/* Register description: PHY Test interface dout
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_TEST_DOUT_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_DOUT_ADDR(base)          ((base) + (0xB84))

/* Register description: PHY reset control.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_SHUTDOWN_RST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_SHUTDOWN_RST_CTRL_ADDR(base)  ((base) + (0xB88))

/* Register description: PHY mode and enable control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_ADDR(base)               ((base) + (0xB8C))

/* Register description: PHY lock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_LOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_LOCK_CTRL_ADDR(base)          ((base) + (0xB90))

/* Register description: PHY unlock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_UNLOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_UNLOCK_CTRL_ADDR(base)        ((base) + (0xB94))

/* Register description: PHY lock state
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_LOCK_STATE_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_LOCK_STATE_ADDR(base)         ((base) + (0xB98))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_DBG_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_DBG_ADDR(base)                ((base) + (0xB9C))

/* Register description: PHY clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_C_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CDPHY_C_CLKRST_ADDR(base)             ((base) + (0xBA0))

/* Register description: PHY Test interface control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_ADDR(base)          ((base) + (0xBC0))

/* Register description: PHY Test interface dout
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_TEST_DOUT_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_DOUT_ADDR(base)          ((base) + (0xBC4))

/* Register description: PHY reset control.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_SHUTDOWN_RST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_SHUTDOWN_RST_CTRL_ADDR(base)  ((base) + (0xBC8))

/* Register description: PHY mode and enable control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_ADDR(base)               ((base) + (0xBCC))

/* Register description: PHY lock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_LOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_LOCK_CTRL_ADDR(base)          ((base) + (0xBD0))

/* Register description: PHY unlock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_UNLOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_UNLOCK_CTRL_ADDR(base)        ((base) + (0xBD4))

/* Register description: PHY lock state
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_LOCK_STATE_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_LOCK_STATE_ADDR(base)         ((base) + (0xBD8))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_DBG_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_DBG_ADDR(base)                ((base) + (0xBDC))

/* Register description: PHY clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_D_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CDPHY_D_CLKRST_ADDR(base)             ((base) + (0xBE0))

/* Register description: PHY Test interface control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_ADDR(base)          ((base) + (0xC00))

/* Register description: PHY Test interface dout
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_TEST_DOUT_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_DOUT_ADDR(base)          ((base) + (0xC04))

/* Register description: PHY reset control.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_SHUTDOWN_RST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_SHUTDOWN_RST_CTRL_ADDR(base)  ((base) + (0xC08))

/* Register description: PHY mode and enable control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_ADDR(base)               ((base) + (0xC0C))

/* Register description: PHY lock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_LOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_LOCK_CTRL_ADDR(base)          ((base) + (0xC10))

/* Register description: PHY unlock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_UNLOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_UNLOCK_CTRL_ADDR(base)        ((base) + (0xC14))

/* Register description: PHY lock state
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_LOCK_STATE_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_LOCK_STATE_ADDR(base)         ((base) + (0xC18))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_DBG_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_DBG_ADDR(base)                ((base) + (0xC1C))

/* Register description: PHY clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_E_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CDPHY_E_CLKRST_ADDR(base)             ((base) + (0xC20))

/* Register description: PHY Test interface control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_ADDR(base)          ((base) + (0xC40))

/* Register description: PHY Test interface dout
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_TEST_DOUT_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_DOUT_ADDR(base)          ((base) + (0xC44))

/* Register description: PHY reset control.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_SHUTDOWN_RST_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_SHUTDOWN_RST_CTRL_ADDR(base)  ((base) + (0xC48))

/* Register description: PHY mode and enable control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_ADDR(base)               ((base) + (0xC4C))

/* Register description: PHY lock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_LOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_LOCK_CTRL_ADDR(base)          ((base) + (0xC50))

/* Register description: PHY unlock  control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_UNLOCK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_UNLOCK_CTRL_ADDR(base)        ((base) + (0xC54))

/* Register description: PHY lock state
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_LOCK_STATE_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_LOCK_STATE_ADDR(base)         ((base) + (0xC58))

/* Register description: Dbg_out.
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_DBG_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_DBG_ADDR(base)                ((base) + (0xC5C))

/* Register description: PHY clk gate and soft rst
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CDPHY_F_CLKRST_UNION */
#define SOC_CSI_WRAPPER_CDPHY_F_CLKRST_ADDR(base)             ((base) + (0xC60))

/* Register description: secure cfg register
   Bit domain definition UNION:  SOC_CSI_WRAPPER_S_UNION */
#define SOC_CSI_WRAPPER_S_ADDR(base)                          ((base) + (0xE00))

/* Register description: CSI wrapper idi clock control
   Bit domain definition UNION:  SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_UNION */
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_ADDR(base)          ((base) + (0xE80))


#endif




/*****************************************************************************
  3 enums
*****************************************************************************/



/*****************************************************************************
  4 message head
*****************************************************************************/



/*****************************************************************************
  5 message
*****************************************************************************/



/*****************************************************************************
  6 struct
*****************************************************************************/



/*****************************************************************************
  7 union
*****************************************************************************/

/****************************************************************************
                     (1/1) CSI_WRAPPER
 ****************************************************************************/
/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_CGR_0_UNION
 struct description   : CSI_CGR_0 Register structure definition
                        Address Offset:0x000 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csia  : 1;  /* bit[0]   : Functional clock gate control for CSIA, clock is gated when set to 0 */
        unsigned int  cg_csib  : 1;  /* bit[1]   : Functional clock gate control for CSIB, clock is gated when set to 0 */
        unsigned int  cg_csic  : 1;  /* bit[2]   : Functional clock gate control for CSIC, clock is gated when set to 0 */
        unsigned int  reserved : 29; /* bit[3-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_CGR_0_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_CGR_0_cg_csia_START   (0)
#define SOC_CSI_WRAPPER_CSI_CGR_0_cg_csia_END     (0)
#define SOC_CSI_WRAPPER_CSI_CGR_0_cg_csib_START   (1)
#define SOC_CSI_WRAPPER_CSI_CGR_0_cg_csib_END     (1)
#define SOC_CSI_WRAPPER_CSI_CGR_0_cg_csic_START   (2)
#define SOC_CSI_WRAPPER_CSI_CGR_0_cg_csic_END     (2)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_CGR_0_SET_UNION
 struct description   : CSI_CGR_0_SET Register structure definition
                        Address Offset:0x004 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csia  : 1;  /* bit[0]   : When writing a one in a field, set the related bits */
        unsigned int  cg_csib  : 1;  /* bit[1]   : When writing a one in a field, set the related bits */
        unsigned int  cg_csic  : 1;  /* bit[2]   : When writing a one in a field, set the related bits */
        unsigned int  reserved : 29; /* bit[3-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_CGR_0_SET_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_CGR_0_SET_cg_csia_START   (0)
#define SOC_CSI_WRAPPER_CSI_CGR_0_SET_cg_csia_END     (0)
#define SOC_CSI_WRAPPER_CSI_CGR_0_SET_cg_csib_START   (1)
#define SOC_CSI_WRAPPER_CSI_CGR_0_SET_cg_csib_END     (1)
#define SOC_CSI_WRAPPER_CSI_CGR_0_SET_cg_csic_START   (2)
#define SOC_CSI_WRAPPER_CSI_CGR_0_SET_cg_csic_END     (2)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_CGR_0_CLEAR_UNION
 struct description   : CSI_CGR_0_CLEAR Register structure definition
                        Address Offset:0x008 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csia  : 1;  /* bit[0]   : When writing a one in a field, clear the related bits */
        unsigned int  cg_csib  : 1;  /* bit[1]   : When writing a one in a field, clear the related bits */
        unsigned int  cg_csic  : 1;  /* bit[2]   : When writing a one in a field, clear the related bits */
        unsigned int  reserved : 29; /* bit[3-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_CGR_0_CLEAR_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_CGR_0_CLEAR_cg_csia_START   (0)
#define SOC_CSI_WRAPPER_CSI_CGR_0_CLEAR_cg_csia_END     (0)
#define SOC_CSI_WRAPPER_CSI_CGR_0_CLEAR_cg_csib_START   (1)
#define SOC_CSI_WRAPPER_CSI_CGR_0_CLEAR_cg_csib_END     (1)
#define SOC_CSI_WRAPPER_CSI_CGR_0_CLEAR_cg_csic_START   (2)
#define SOC_CSI_WRAPPER_CSI_CGR_0_CLEAR_cg_csic_END     (2)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_RESET_0_UNION
 struct description   : CSI_RESET_0 Register structure definition
                        Address Offset:0x00C Initial:0x00000000 Width:32
 register description : Soft reset control for each module which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  soft_rst_csia : 1;  /* bit[0]   : Software reset control for CSIA, set to 1 to reset  */
        unsigned int  soft_rst_csib : 1;  /* bit[1]   : Software reset control for CSIB, set to 1 to reset  */
        unsigned int  soft_rst_csic : 1;  /* bit[2]   : Software reset control for CSIC, set to 1 to reset  */
        unsigned int  reserved      : 29; /* bit[3-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_RESET_0_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_RESET_0_soft_rst_csia_START  (0)
#define SOC_CSI_WRAPPER_CSI_RESET_0_soft_rst_csia_END    (0)
#define SOC_CSI_WRAPPER_CSI_RESET_0_soft_rst_csib_START  (1)
#define SOC_CSI_WRAPPER_CSI_RESET_0_soft_rst_csib_END    (1)
#define SOC_CSI_WRAPPER_CSI_RESET_0_soft_rst_csic_START  (2)
#define SOC_CSI_WRAPPER_CSI_RESET_0_soft_rst_csic_END    (2)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_PHY_CSI_A_DBG_UNION
 struct description   : PHY_CSI_A_DBG Register structure definition
                        Address Offset:0x010 Initial:0x00010F00 Width:32
 register description : PHY CSI-A debug status.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phya_rxactivehs_0      : 1;  /* bit[0]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 0. */
        unsigned int  phya_rxactivehs_1      : 1;  /* bit[1]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 1. */
        unsigned int  phya_rxactivehs_2      : 1;  /* bit[2]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 2. */
        unsigned int  phya_rxactivehs_3      : 1;  /* bit[3]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 3. */
        unsigned int  phya_rxlpdtesc_0       : 1;  /* bit[4]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phya_rxlpdtesc_1       : 1;  /* bit[5]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phya_rxlpdtesc_2       : 1;  /* bit[6]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phya_rxlpdtesc_3       : 1;  /* bit[7]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phya_ulpsactivenot_0   : 1;  /* bit[8]    : ctive Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phya_ulpsactivenot_1   : 1;  /* bit[9]    : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phya_ulpsactivenot_2   : 1;  /* bit[10]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phya_ulpsactivenot_3   : 1;  /* bit[11]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phya_errsyncesc_0      : 1;  /* bit[12]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phya_errsyncesc_1      : 1;  /* bit[13]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phya_errsyncesc_2      : 1;  /* bit[14]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phya_errsyncesc_3      : 1;  /* bit[15]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phya_ulpsactivenotclk  : 1;  /* bit[16]   : Active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSCLK. TXCLKESC must be supplied to the macro until ULPSACTIVENOTCLK is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted together with RXCLKULPSNOT; at the end of the ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSCLKNOT signal is deasserted. */
        unsigned int  reserved_0             : 3;  /* bit[17-19]:  */
        unsigned int  phya_rxinvalidcodehs_0 : 2;  /* bit[20-21]:  */
        unsigned int  phya_rxinvalidcodehs_1 : 2;  /* bit[22-23]:  */
        unsigned int  phya_rxinvalidcodehs_2 : 2;  /* bit[24-25]:  */
        unsigned int  reserved_1             : 6;  /* bit[26-31]:  */
    } reg;
} SOC_CSI_WRAPPER_PHY_CSI_A_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxactivehs_0_START       (0)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxactivehs_0_END         (0)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxactivehs_1_START       (1)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxactivehs_1_END         (1)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxactivehs_2_START       (2)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxactivehs_2_END         (2)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxactivehs_3_START       (3)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxactivehs_3_END         (3)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxlpdtesc_0_START        (4)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxlpdtesc_0_END          (4)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxlpdtesc_1_START        (5)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxlpdtesc_1_END          (5)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxlpdtesc_2_START        (6)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxlpdtesc_2_END          (6)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxlpdtesc_3_START        (7)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxlpdtesc_3_END          (7)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_ulpsactivenot_0_START    (8)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_ulpsactivenot_0_END      (8)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_ulpsactivenot_1_START    (9)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_ulpsactivenot_1_END      (9)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_ulpsactivenot_2_START    (10)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_ulpsactivenot_2_END      (10)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_ulpsactivenot_3_START    (11)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_ulpsactivenot_3_END      (11)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_errsyncesc_0_START       (12)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_errsyncesc_0_END         (12)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_errsyncesc_1_START       (13)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_errsyncesc_1_END         (13)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_errsyncesc_2_START       (14)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_errsyncesc_2_END         (14)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_errsyncesc_3_START       (15)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_errsyncesc_3_END         (15)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_ulpsactivenotclk_START   (16)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_ulpsactivenotclk_END     (16)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxinvalidcodehs_0_START  (20)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxinvalidcodehs_0_END    (21)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxinvalidcodehs_1_START  (22)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxinvalidcodehs_1_END    (23)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxinvalidcodehs_2_START  (24)
#define SOC_CSI_WRAPPER_PHY_CSI_A_DBG_phya_rxinvalidcodehs_2_END    (25)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_PHY_CSI_B_DBG_UNION
 struct description   : PHY_CSI_B_DBG Register structure definition
                        Address Offset:0x014 Initial:0x00010F00 Width:32
 register description : PHY CSI-B debug status.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyb_rxactivehs_0      : 1;  /* bit[0]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 0. */
        unsigned int  phyb_rxactivehs_1      : 1;  /* bit[1]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 1. */
        unsigned int  phyb_rxactivehs_2      : 1;  /* bit[2]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 2. */
        unsigned int  phyb_rxactivehs_3      : 1;  /* bit[3]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 3. */
        unsigned int  phyb_rxlpdtesc_0       : 1;  /* bit[4]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyb_rxlpdtesc_1       : 1;  /* bit[5]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyb_rxlpdtesc_2       : 1;  /* bit[6]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyb_rxlpdtesc_3       : 1;  /* bit[7]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyb_ulpsactivenot_0   : 1;  /* bit[8]    : ctive Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyb_ulpsactivenot_1   : 1;  /* bit[9]    : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyb_ulpsactivenot_2   : 1;  /* bit[10]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyb_ulpsactivenot_3   : 1;  /* bit[11]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyb_errsyncesc_0      : 1;  /* bit[12]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyb_errsyncesc_1      : 1;  /* bit[13]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyb_errsyncesc_2      : 1;  /* bit[14]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyb_errsyncesc_3      : 1;  /* bit[15]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyb_ulpsactivenotclk  : 1;  /* bit[16]   : Active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSCLK. TXCLKESC must be supplied to the macro until ULPSACTIVENOTCLK is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted together with RXCLKULPSNOT; at the end of the ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSCLKNOT signal is deasserted. */
        unsigned int  reserved_0             : 3;  /* bit[17-19]:  */
        unsigned int  phyb_rxinvalidcodehs_0 : 2;  /* bit[20-21]:  */
        unsigned int  phyb_rxinvalidcodehs_1 : 2;  /* bit[22-23]:  */
        unsigned int  phyb_rxinvalidcodehs_2 : 2;  /* bit[24-25]:  */
        unsigned int  reserved_1             : 6;  /* bit[26-31]:  */
    } reg;
} SOC_CSI_WRAPPER_PHY_CSI_B_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxactivehs_0_START       (0)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxactivehs_0_END         (0)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxactivehs_1_START       (1)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxactivehs_1_END         (1)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxactivehs_2_START       (2)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxactivehs_2_END         (2)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxactivehs_3_START       (3)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxactivehs_3_END         (3)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxlpdtesc_0_START        (4)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxlpdtesc_0_END          (4)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxlpdtesc_1_START        (5)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxlpdtesc_1_END          (5)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxlpdtesc_2_START        (6)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxlpdtesc_2_END          (6)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxlpdtesc_3_START        (7)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxlpdtesc_3_END          (7)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_ulpsactivenot_0_START    (8)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_ulpsactivenot_0_END      (8)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_ulpsactivenot_1_START    (9)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_ulpsactivenot_1_END      (9)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_ulpsactivenot_2_START    (10)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_ulpsactivenot_2_END      (10)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_ulpsactivenot_3_START    (11)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_ulpsactivenot_3_END      (11)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_errsyncesc_0_START       (12)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_errsyncesc_0_END         (12)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_errsyncesc_1_START       (13)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_errsyncesc_1_END         (13)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_errsyncesc_2_START       (14)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_errsyncesc_2_END         (14)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_errsyncesc_3_START       (15)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_errsyncesc_3_END         (15)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_ulpsactivenotclk_START   (16)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_ulpsactivenotclk_END     (16)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxinvalidcodehs_0_START  (20)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxinvalidcodehs_0_END    (21)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxinvalidcodehs_1_START  (22)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxinvalidcodehs_1_END    (23)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxinvalidcodehs_2_START  (24)
#define SOC_CSI_WRAPPER_PHY_CSI_B_DBG_phyb_rxinvalidcodehs_2_END    (25)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_PHY_CSI_C_DBG_UNION
 struct description   : PHY_CSI_C_DBG Register structure definition
                        Address Offset:0x018 Initial:0x00010F00 Width:32
 register description : PHY CSI-C debug status.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyc_rxactivehs_0      : 1;  /* bit[0]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 0. */
        unsigned int  phyc_rxactivehs_1      : 1;  /* bit[1]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 1. */
        unsigned int  phyc_rxactivehs_2      : 1;  /* bit[2]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 2. */
        unsigned int  phyc_rxactivehs_3      : 1;  /* bit[3]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 3. */
        unsigned int  phyc_rxlpdtesc_0       : 1;  /* bit[4]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyc_rxlpdtesc_1       : 1;  /* bit[5]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyc_rxlpdtesc_2       : 1;  /* bit[6]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyc_rxlpdtesc_3       : 1;  /* bit[7]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyc_ulpsactivenot_0   : 1;  /* bit[8]    : ctive Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyc_ulpsactivenot_1   : 1;  /* bit[9]    : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyc_ulpsactivenot_2   : 1;  /* bit[10]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyc_ulpsactivenot_3   : 1;  /* bit[11]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyc_errsyncesc_0      : 1;  /* bit[12]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyc_errsyncesc_1      : 1;  /* bit[13]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyc_errsyncesc_2      : 1;  /* bit[14]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyc_errsyncesc_3      : 1;  /* bit[15]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyc_ulpsactivenotclk  : 1;  /* bit[16]   : Active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSCLK. TXCLKESC must be supplied to the macro until ULPSACTIVENOTCLK is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted together with RXCLKULPSNOT; at the end of the ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSCLKNOT signal is deasserted. */
        unsigned int  reserved_0             : 3;  /* bit[17-19]:  */
        unsigned int  phyc_rxinvalidcodehs_0 : 2;  /* bit[20-21]:  */
        unsigned int  phyc_rxinvalidcodehs_1 : 2;  /* bit[22-23]:  */
        unsigned int  phyc_rxinvalidcodehs_2 : 2;  /* bit[24-25]:  */
        unsigned int  reserved_1             : 6;  /* bit[26-31]:  */
    } reg;
} SOC_CSI_WRAPPER_PHY_CSI_C_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxactivehs_0_START       (0)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxactivehs_0_END         (0)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxactivehs_1_START       (1)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxactivehs_1_END         (1)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxactivehs_2_START       (2)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxactivehs_2_END         (2)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxactivehs_3_START       (3)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxactivehs_3_END         (3)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxlpdtesc_0_START        (4)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxlpdtesc_0_END          (4)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxlpdtesc_1_START        (5)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxlpdtesc_1_END          (5)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxlpdtesc_2_START        (6)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxlpdtesc_2_END          (6)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxlpdtesc_3_START        (7)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxlpdtesc_3_END          (7)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_ulpsactivenot_0_START    (8)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_ulpsactivenot_0_END      (8)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_ulpsactivenot_1_START    (9)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_ulpsactivenot_1_END      (9)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_ulpsactivenot_2_START    (10)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_ulpsactivenot_2_END      (10)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_ulpsactivenot_3_START    (11)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_ulpsactivenot_3_END      (11)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_errsyncesc_0_START       (12)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_errsyncesc_0_END         (12)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_errsyncesc_1_START       (13)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_errsyncesc_1_END         (13)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_errsyncesc_2_START       (14)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_errsyncesc_2_END         (14)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_errsyncesc_3_START       (15)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_errsyncesc_3_END         (15)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_ulpsactivenotclk_START   (16)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_ulpsactivenotclk_END     (16)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxinvalidcodehs_0_START  (20)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxinvalidcodehs_0_END    (21)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxinvalidcodehs_1_START  (22)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxinvalidcodehs_1_END    (23)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxinvalidcodehs_2_START  (24)
#define SOC_CSI_WRAPPER_PHY_CSI_C_DBG_phyc_rxinvalidcodehs_2_END    (25)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_ABC_IDI_SEL_UNION
 struct description   : CSI_ABC_IDI_SEL Register structure definition
                        Address Offset:0x01C Initial:0x00000000 Width:32
 register description : csi and mudp idi intf sel
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  idi_sel_a : 1;  /* bit[0]   : 0: CSI A IDI
                                                    1: MUDP IDI */
        unsigned int  idi_sel_b : 1;  /* bit[1]   : 0: CSI B IDI
                                                    1: MUDP IDI */
        unsigned int  idi_sel_c : 1;  /* bit[2]   : 0: CSI C IDI
                                                    1: MUDP IDI */
        unsigned int  reserved  : 29; /* bit[3-31]: DUMMY */
    } reg;
} SOC_CSI_WRAPPER_CSI_ABC_IDI_SEL_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_ABC_IDI_SEL_idi_sel_a_START  (0)
#define SOC_CSI_WRAPPER_CSI_ABC_IDI_SEL_idi_sel_a_END    (0)
#define SOC_CSI_WRAPPER_CSI_ABC_IDI_SEL_idi_sel_b_START  (1)
#define SOC_CSI_WRAPPER_CSI_ABC_IDI_SEL_idi_sel_b_END    (1)
#define SOC_CSI_WRAPPER_CSI_ABC_IDI_SEL_idi_sel_c_START  (2)
#define SOC_CSI_WRAPPER_CSI_ABC_IDI_SEL_idi_sel_c_END    (2)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_ABC_FORCE_PCLKON_UNION
 struct description   : CSI_ABC_FORCE_PCLKON Register structure definition
                        Address Offset:0x020 Initial:0x00000007 Width:32
 register description : force pclk on of csi controller
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csia_force_pclk_on : 1;  /* bit[0]   : set 1 to force pclk always on of csi controller */
        unsigned int  csib_force_pclk_on : 1;  /* bit[1]   : set 1 to force pclk always on of csi controller */
        unsigned int  csic_force_pclk_on : 1;  /* bit[2]   : set 1 to force pclk always on of csi controller */
        unsigned int  reserved           : 29; /* bit[3-31]:  */
    } reg;
} SOC_CSI_WRAPPER_CSI_ABC_FORCE_PCLKON_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_ABC_FORCE_PCLKON_csia_force_pclk_on_START  (0)
#define SOC_CSI_WRAPPER_CSI_ABC_FORCE_PCLKON_csia_force_pclk_on_END    (0)
#define SOC_CSI_WRAPPER_CSI_ABC_FORCE_PCLKON_csib_force_pclk_on_START  (1)
#define SOC_CSI_WRAPPER_CSI_ABC_FORCE_PCLKON_csib_force_pclk_on_END    (1)
#define SOC_CSI_WRAPPER_CSI_ABC_FORCE_PCLKON_csic_force_pclk_on_START  (2)
#define SOC_CSI_WRAPPER_CSI_ABC_FORCE_PCLKON_csic_force_pclk_on_END    (2)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_SECURE_ST_UNION
 struct description   : SECURE_ST Register structure definition
                        Address Offset:0x300 Initial:0x00000000 Width:32
 register description : used to query security status
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csi_wrapper_secure_st : 32; /* bit[0-31]: Used to query security status
                                                                bit[31:14]:reserved
                                                                bit[13]:phy_f_secure DUMMY
                                                                bit[12]: phy_e_secure
                                                                bit[11]:phy_d_secure DUMMY
                                                                bit[10]: phy_c_secure
                                                                bit[9]: phy_b_secure
                                                                bit[8]: phy_a_secure
                                                                bit[7]:csi_g_secureDUMMY
                                                                bit[6]: csi_f_secureDUMMY
                                                                bit[5:4]: reserved
                                                                bit[3]: csi_dbg_secure
                                                                bit[2]: csi_e_secure
                                                                bit[1]: csi_d_secure
                                                                bit[0]: csi_abc_secure */
    } reg;
} SOC_CSI_WRAPPER_SECURE_ST_UNION;
#endif
#define SOC_CSI_WRAPPER_SECURE_ST_csi_wrapper_secure_st_START  (0)
#define SOC_CSI_WRAPPER_SECURE_ST_csi_wrapper_secure_st_END    (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_MUDP_RS_CLKRST_UNION
 struct description   : CSI_MUDP_RS_CLKRST Register structure definition
                        Address Offset:0x304 Initial:0x00000001 Width:32
 register description : mudp idi rs clk gate and soft rst
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  soft_rst_mudp : 1;  /* bit[0]   : Software reset control for mudp idi rs, set to 1 to reset  */
        unsigned int  cg_en_mudp    : 1;  /* bit[1]   : clock gate control for mudp idi rs, clock is gated when set to 0 */
        unsigned int  reserved      : 30; /* bit[2-31]: DUMMY */
    } reg;
} SOC_CSI_WRAPPER_CSI_MUDP_RS_CLKRST_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_MUDP_RS_CLKRST_soft_rst_mudp_START  (0)
#define SOC_CSI_WRAPPER_CSI_MUDP_RS_CLKRST_soft_rst_mudp_END    (0)
#define SOC_CSI_WRAPPER_CSI_MUDP_RS_CLKRST_cg_en_mudp_START     (1)
#define SOC_CSI_WRAPPER_CSI_MUDP_RS_CLKRST_cg_en_mudp_END       (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_CGR_1_UNION
 struct description   : CSI_CGR_1 Register structure definition
                        Address Offset:0x400 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csid  : 1;  /* bit[0]   : Functional clock gate control for CSID, clock is gated when set to 0
                                                   CSID is shared by FP and FD. */
        unsigned int  reserved : 31; /* bit[1-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_CGR_1_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_CGR_1_cg_csid_START   (0)
#define SOC_CSI_WRAPPER_CSI_CGR_1_cg_csid_END     (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_CGR_1_SET_UNION
 struct description   : CSI_CGR_1_SET Register structure definition
                        Address Offset:0x404 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csid  : 1;  /* bit[0]   : When writing a one in a field, set the related bits */
        unsigned int  reserved : 31; /* bit[1-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_CGR_1_SET_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_CGR_1_SET_cg_csid_START   (0)
#define SOC_CSI_WRAPPER_CSI_CGR_1_SET_cg_csid_END     (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_CGR_1_CLEAR_UNION
 struct description   : CSI_CGR_1_CLEAR Register structure definition
                        Address Offset:0x408 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csid  : 1;  /* bit[0]   : When writing a one in a field, clear the related bits */
        unsigned int  reserved : 31; /* bit[1-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_CGR_1_CLEAR_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_CGR_1_CLEAR_cg_csid_START   (0)
#define SOC_CSI_WRAPPER_CSI_CGR_1_CLEAR_cg_csid_END     (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_RESET_1_UNION
 struct description   : CSI_RESET_1 Register structure definition
                        Address Offset:0x40C Initial:0x00000000 Width:32
 register description : Soft reset control for each module which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  soft_rst_csid : 1;  /* bit[0]   : Software reset control for CSID, set to 1 to reset  */
        unsigned int  reserved      : 31; /* bit[1-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_RESET_1_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_RESET_1_soft_rst_csid_START  (0)
#define SOC_CSI_WRAPPER_CSI_RESET_1_soft_rst_csid_END    (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_PHY_CSI_D_DBG_UNION
 struct description   : PHY_CSI_D_DBG Register structure definition
                        Address Offset:0x410 Initial:0x00010F00 Width:32
 register description : PHY CSI-D debug status.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyd_rxactivehs_0      : 1;  /* bit[0]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 0. */
        unsigned int  phyd_rxactivehs_1      : 1;  /* bit[1]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 1. */
        unsigned int  phyd_rxactivehs_2      : 1;  /* bit[2]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 2. */
        unsigned int  phyd_rxactivehs_3      : 1;  /* bit[3]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 3. */
        unsigned int  phyd_rxlpdtesc_0       : 1;  /* bit[4]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyd_rxlpdtesc_1       : 1;  /* bit[5]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyd_rxlpdtesc_2       : 1;  /* bit[6]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyd_rxlpdtesc_3       : 1;  /* bit[7]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyd_ulpsactivenot_0   : 1;  /* bit[8]    : ctive Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyd_ulpsactivenot_1   : 1;  /* bit[9]    : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyd_ulpsactivenot_2   : 1;  /* bit[10]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyd_ulpsactivenot_3   : 1;  /* bit[11]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyd_errsyncesc_0      : 1;  /* bit[12]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyd_errsyncesc_1      : 1;  /* bit[13]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyd_errsyncesc_2      : 1;  /* bit[14]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyd_errsyncesc_3      : 1;  /* bit[15]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyd_ulpsactivenotclk  : 1;  /* bit[16]   : Active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSCLK. TXCLKESC must be supplied to the macro until ULPSACTIVENOTCLK is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted together with RXCLKULPSNOT; at the end of the ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSCLKNOT signal is deasserted. */
        unsigned int  reserved_0             : 3;  /* bit[17-19]:  */
        unsigned int  phyd_rxinvalidcodehs_0 : 2;  /* bit[20-21]:  */
        unsigned int  phyd_rxinvalidcodehs_1 : 2;  /* bit[22-23]:  */
        unsigned int  phyd_rxinvalidcodehs_2 : 2;  /* bit[24-25]:  */
        unsigned int  reserved_1             : 6;  /* bit[26-31]: DUMMY */
    } reg;
} SOC_CSI_WRAPPER_PHY_CSI_D_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxactivehs_0_START       (0)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxactivehs_0_END         (0)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxactivehs_1_START       (1)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxactivehs_1_END         (1)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxactivehs_2_START       (2)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxactivehs_2_END         (2)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxactivehs_3_START       (3)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxactivehs_3_END         (3)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxlpdtesc_0_START        (4)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxlpdtesc_0_END          (4)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxlpdtesc_1_START        (5)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxlpdtesc_1_END          (5)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxlpdtesc_2_START        (6)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxlpdtesc_2_END          (6)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxlpdtesc_3_START        (7)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxlpdtesc_3_END          (7)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_ulpsactivenot_0_START    (8)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_ulpsactivenot_0_END      (8)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_ulpsactivenot_1_START    (9)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_ulpsactivenot_1_END      (9)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_ulpsactivenot_2_START    (10)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_ulpsactivenot_2_END      (10)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_ulpsactivenot_3_START    (11)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_ulpsactivenot_3_END      (11)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_errsyncesc_0_START       (12)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_errsyncesc_0_END         (12)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_errsyncesc_1_START       (13)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_errsyncesc_1_END         (13)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_errsyncesc_2_START       (14)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_errsyncesc_2_END         (14)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_errsyncesc_3_START       (15)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_errsyncesc_3_END         (15)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_ulpsactivenotclk_START   (16)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_ulpsactivenotclk_END     (16)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxinvalidcodehs_0_START  (20)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxinvalidcodehs_0_END    (21)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxinvalidcodehs_1_START  (22)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxinvalidcodehs_1_END    (23)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxinvalidcodehs_2_START  (24)
#define SOC_CSI_WRAPPER_PHY_CSI_D_DBG_phyd_rxinvalidcodehs_2_END    (25)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_D_FORCE_PCLKON_UNION
 struct description   : CSI_D_FORCE_PCLKON Register structure definition
                        Address Offset:0x414 Initial:0x00000001 Width:32
 register description : force pclk on of csi controller
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csid_force_pclk_on : 1;  /* bit[0]   : set 1 to force pclk always on of csi controller */
        unsigned int  reserved           : 31; /* bit[1-31]:  */
    } reg;
} SOC_CSI_WRAPPER_CSI_D_FORCE_PCLKON_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_D_FORCE_PCLKON_csid_force_pclk_on_START  (0)
#define SOC_CSI_WRAPPER_CSI_D_FORCE_PCLKON_csid_force_pclk_on_END    (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_CGR_2_UNION
 struct description   : CSI_CGR_2 Register structure definition
                        Address Offset:0x500 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csie  : 1;  /* bit[0]   : Functional clock gate control for CSIE, clock is gated when set to 0 */
        unsigned int  reserved : 31; /* bit[1-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_CGR_2_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_CGR_2_cg_csie_START   (0)
#define SOC_CSI_WRAPPER_CSI_CGR_2_cg_csie_END     (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_CGR_2_SET_UNION
 struct description   : CSI_CGR_2_SET Register structure definition
                        Address Offset:0x504 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csie  : 1;  /* bit[0]   : When writing a one in a field, set the related bits */
        unsigned int  reserved : 31; /* bit[1-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_CGR_2_SET_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_CGR_2_SET_cg_csie_START   (0)
#define SOC_CSI_WRAPPER_CSI_CGR_2_SET_cg_csie_END     (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_CGR_2_CLEAR_UNION
 struct description   : CSI_CGR_2_CLEAR Register structure definition
                        Address Offset:0x508 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csie  : 1;  /* bit[0]   : When writing a one in a field, clear the related bits */
        unsigned int  reserved : 31; /* bit[1-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_CGR_2_CLEAR_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_CGR_2_CLEAR_cg_csie_START   (0)
#define SOC_CSI_WRAPPER_CSI_CGR_2_CLEAR_cg_csie_END     (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_RESET_2_UNION
 struct description   : CSI_RESET_2 Register structure definition
                        Address Offset:0x50C Initial:0x00000000 Width:32
 register description : Soft reset control for each module which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  soft_rst_csie : 1;  /* bit[0]   : Software reset control for CSIE, set to 1 to reset  */
        unsigned int  reserved      : 31; /* bit[1-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_RESET_2_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_RESET_2_soft_rst_csie_START  (0)
#define SOC_CSI_WRAPPER_CSI_RESET_2_soft_rst_csie_END    (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_PHY_CSI_E_DBG_UNION
 struct description   : PHY_CSI_E_DBG Register structure definition
                        Address Offset:0x510 Initial:0x00010F00 Width:32
 register description : PHY CSI-E debug status.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phye_rxactivehs_0      : 1;  /* bit[0]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 0. */
        unsigned int  phye_rxactivehs_1      : 1;  /* bit[1]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 1. */
        unsigned int  phye_rxactivehs_2      : 1;  /* bit[2]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 2. */
        unsigned int  phye_rxactivehs_3      : 1;  /* bit[3]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 3. */
        unsigned int  phye_rxlpdtesc_0       : 1;  /* bit[4]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phye_rxlpdtesc_1       : 1;  /* bit[5]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phye_rxlpdtesc_2       : 1;  /* bit[6]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phye_rxlpdtesc_3       : 1;  /* bit[7]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phye_ulpsactivenot_0   : 1;  /* bit[8]    : ctive Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phye_ulpsactivenot_1   : 1;  /* bit[9]    : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phye_ulpsactivenot_2   : 1;  /* bit[10]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phye_ulpsactivenot_3   : 1;  /* bit[11]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phye_errsyncesc_0      : 1;  /* bit[12]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phye_errsyncesc_1      : 1;  /* bit[13]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phye_errsyncesc_2      : 1;  /* bit[14]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phye_errsyncesc_3      : 1;  /* bit[15]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phye_ulpsactivenotclk  : 1;  /* bit[16]   : Active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSCLK. TXCLKESC must be supplied to the macro until ULPSACTIVENOTCLK is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted together with RXCLKULPSNOT; at the end of the ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSCLKNOT signal is deasserted. */
        unsigned int  reserved_0             : 3;  /* bit[17-19]:  */
        unsigned int  phye_rxinvalidcodehs_0 : 2;  /* bit[20-21]:  */
        unsigned int  phye_rxinvalidcodehs_1 : 2;  /* bit[22-23]:  */
        unsigned int  phye_rxinvalidcodehs_2 : 2;  /* bit[24-25]:  */
        unsigned int  reserved_1             : 6;  /* bit[26-31]: This used for phye cfg clock calculation.
                                                                  Phy_cfg_clk = apb_clk * 16/phy_clk_dbg_cnt
                                                                  apb_clk is the configuration clock for CSI WRAPPER */
    } reg;
} SOC_CSI_WRAPPER_PHY_CSI_E_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxactivehs_0_START       (0)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxactivehs_0_END         (0)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxactivehs_1_START       (1)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxactivehs_1_END         (1)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxactivehs_2_START       (2)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxactivehs_2_END         (2)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxactivehs_3_START       (3)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxactivehs_3_END         (3)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxlpdtesc_0_START        (4)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxlpdtesc_0_END          (4)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxlpdtesc_1_START        (5)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxlpdtesc_1_END          (5)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxlpdtesc_2_START        (6)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxlpdtesc_2_END          (6)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxlpdtesc_3_START        (7)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxlpdtesc_3_END          (7)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_ulpsactivenot_0_START    (8)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_ulpsactivenot_0_END      (8)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_ulpsactivenot_1_START    (9)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_ulpsactivenot_1_END      (9)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_ulpsactivenot_2_START    (10)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_ulpsactivenot_2_END      (10)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_ulpsactivenot_3_START    (11)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_ulpsactivenot_3_END      (11)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_errsyncesc_0_START       (12)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_errsyncesc_0_END         (12)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_errsyncesc_1_START       (13)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_errsyncesc_1_END         (13)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_errsyncesc_2_START       (14)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_errsyncesc_2_END         (14)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_errsyncesc_3_START       (15)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_errsyncesc_3_END         (15)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_ulpsactivenotclk_START   (16)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_ulpsactivenotclk_END     (16)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxinvalidcodehs_0_START  (20)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxinvalidcodehs_0_END    (21)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxinvalidcodehs_1_START  (22)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxinvalidcodehs_1_END    (23)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxinvalidcodehs_2_START  (24)
#define SOC_CSI_WRAPPER_PHY_CSI_E_DBG_phye_rxinvalidcodehs_2_END    (25)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_E_FORCE_PCLKON_UNION
 struct description   : CSI_E_FORCE_PCLKON Register structure definition
                        Address Offset:0x514 Initial:0x00000001 Width:32
 register description : force pclk on of csi controller
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csie_force_pclk_on : 1;  /* bit[0]   : set 1 to force pclk always on of csi controller */
        unsigned int  reserved           : 31; /* bit[1-31]:  */
    } reg;
} SOC_CSI_WRAPPER_CSI_E_FORCE_PCLKON_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_E_FORCE_PCLKON_csie_force_pclk_on_START  (0)
#define SOC_CSI_WRAPPER_CSI_E_FORCE_PCLKON_csie_force_pclk_on_END    (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIA_CTRL_UNION
 struct description   : CSIA_CTRL Register structure definition
                        Address Offset:0x600 Initial:0x20000000 Width:32
 register description : enables to control CSIA Host integration as well as the CDPHY attached to it.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  reserved_0                   : 25; /* bit[0-24] : - */
        unsigned int  csia_en                      : 1;  /* bit[25]   : Configure this bit to 0x1 when CSIA is enabled */
        unsigned int  csia_sensor                  : 1;  /* bit[26]   : Used to select the sensor connected to the CSI2 Host (used for DPHY mode since the correct clock has to be routed) when sensor_connection is set to 0x1
                                                                        0: Sensor A is used
                                                                        1: Sensor B is used  */
        unsigned int  csia_cdphy_sensor_connection : 1;  /* bit[27]   : Defines the number of sensors mounted on the CDPHY (has effect if cdphy_master=0x1)
                                                                        0: One sensor connected to the CDPHY
                                                                        1: Two sensor connected to the CDPHY */
        unsigned int  reserved_1                   : 1;  /* bit[28]   : reserved */
        unsigned int  csia_cdphy_source            : 3;  /* bit[29-31]: Enables to select the PHY to use to attach to the related CSI2 Host
                                                                        000: CSI Host attached to PHY A
                                                                        001: CSI Host attached to PHY B
                                                                        010: CSI Host attached to PHY C (forbidden)
                                                                        011: CSI Host attached to PHY D (forbidden) (DUMMY)
                                                                        100: CSI Host attached to PHY E
                                                                        101: CSI Host attached to PHY F (forbidden) (DUMMY)
                                                                        110~111: reserved, CSI Host not connected to any PHY (all signals tied 0)
                                                                        Notice that PHYA/PHYE support 2+2 mode, For PHYA/PHYE 2+2 mode, if CSIA select PHYA/PHYE, configure as following:
                                                                         csia_cdphy_sensor_connection=1 & csia_sensor =1 => SensorB(PHY2+2 mode) enable
                                                                         csia_cdphy_sensor_connection=0 & csia_sensor =1 => SensorA(PHY2+2 mode) enable
                                                                         PHY2+2 mode, Sensor A or Sensor B is mutually exclusive. */
    } reg;
} SOC_CSI_WRAPPER_CSIA_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIA_CTRL_csia_en_START                       (25)
#define SOC_CSI_WRAPPER_CSIA_CTRL_csia_en_END                         (25)
#define SOC_CSI_WRAPPER_CSIA_CTRL_csia_sensor_START                   (26)
#define SOC_CSI_WRAPPER_CSIA_CTRL_csia_sensor_END                     (26)
#define SOC_CSI_WRAPPER_CSIA_CTRL_csia_cdphy_sensor_connection_START  (27)
#define SOC_CSI_WRAPPER_CSIA_CTRL_csia_cdphy_sensor_connection_END    (27)
#define SOC_CSI_WRAPPER_CSIA_CTRL_csia_cdphy_source_START             (29)
#define SOC_CSI_WRAPPER_CSIA_CTRL_csia_cdphy_source_END               (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIB_CTRL_UNION
 struct description   : CSIB_CTRL Register structure definition
                        Address Offset:0x604 Initial:0x60000000 Width:32
 register description : enables to control CSIB Host integration as well as the CDPHY attached to it.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  reserved_0                   : 25; /* bit[0-24] : - */
        unsigned int  csib_en                      : 1;  /* bit[25]   : Configure this bit to 0x1 when CSIB is enabled */
        unsigned int  csib_sensor                  : 1;  /* bit[26]   : Used to select the sensor connected to the CSI2 Host (used for DPHY mode since the correct clock has to be routed) when sensor_connection is set to 0x1
                                                                        0: Sensor A is used
                                                                        1: Sensor B is used  */
        unsigned int  csib_cdphy_sensor_connection : 1;  /* bit[27]   : Defines the number of sensors mounted on the CDPHY (has effect if cdphy_master=0x1)
                                                                        0: One sensor connected to the CDPHY
                                                                        1: Two sensor connected to the CDPHY */
        unsigned int  reserved_1                   : 1;  /* bit[28]   : reserved */
        unsigned int  csib_cdphy_source            : 3;  /* bit[29-31]: Enables to select the PHY to use to attach to the related CSI2 Host
                                                                        000: CSI Host attached to PHY A
                                                                        001: CSI Host attached to PHY B (forbidden)
                                                                        010: CSI Host attached to PHY C
                                                                        011: CSI Host attached to PHY D (DUMMY)
                                                                        100: CSI Host attached to PHY E
                                                                        101: CSI Host attached to PHY F (forbidden) (DUMMY)
                                                                        110~111: reserved, CSI Host not connected to any PHY (all signals tied 0)
                                                                        Notice that PHYA/PHYE support 2+2 mode, For PHYA/PHYE 2+2 mode, if CSIB select PHYA/PHYE, configure as following:
                                                                         csib_cdphy_sensor_connection=1 & csib_sensor =1 => SensorB(PHY2+2 mode) enable
                                                                         csib_cdphy_sensor_connection=0 & csib_sensor =1 => SensorA(PHY2+2 mode) enable
                                                                         PHY2+2 mode, Sensor A or Sensor B is mutually exclusive. */
    } reg;
} SOC_CSI_WRAPPER_CSIB_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIB_CTRL_csib_en_START                       (25)
#define SOC_CSI_WRAPPER_CSIB_CTRL_csib_en_END                         (25)
#define SOC_CSI_WRAPPER_CSIB_CTRL_csib_sensor_START                   (26)
#define SOC_CSI_WRAPPER_CSIB_CTRL_csib_sensor_END                     (26)
#define SOC_CSI_WRAPPER_CSIB_CTRL_csib_cdphy_sensor_connection_START  (27)
#define SOC_CSI_WRAPPER_CSIB_CTRL_csib_cdphy_sensor_connection_END    (27)
#define SOC_CSI_WRAPPER_CSIB_CTRL_csib_cdphy_source_START             (29)
#define SOC_CSI_WRAPPER_CSIB_CTRL_csib_cdphy_source_END               (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIC_CTRL_UNION
 struct description   : CSIC_CTRL Register structure definition
                        Address Offset:0x608 Initial:0x40000000 Width:32
 register description : enables to control CSIC Host integration as well as the CDPHY attached to it.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  reserved_0                   : 25; /* bit[0-24] : - */
        unsigned int  csic_en                      : 1;  /* bit[25]   : Configure this bit to 0x1 when CSIC is enabled */
        unsigned int  csic_sensor                  : 1;  /* bit[26]   : Used to select the sensor connected to the CSI2 Host (used for DPHY mode since the correct clock has to be routed) when sensor_connection is set to 0x1
                                                                        0: Sensor A is used
                                                                        1: Sensor B is used  */
        unsigned int  csic_cdphy_sensor_connection : 1;  /* bit[27]   : Defines the number of sensors mounted on the CDPHY (has effect if cdphy_master=0x1)
                                                                        0: One sensor connected to the CDPHY
                                                                        1: Two sensor connected to the CDPHY */
        unsigned int  reserved_1                   : 1;  /* bit[28]   : reserved */
        unsigned int  csic_cdphy_source            : 3;  /* bit[29-31]: Enables to select the PHY to use to attach to the related CSI2 Host
                                                                        000: CSI Host attached to PHY A (forbidden)
                                                                        001: CSI Host attached to PHY B (forbidden)
                                                                        010: CSI Host attached to PHY C
                                                                        011: CSI Host attached to PHY D (DUMMY)
                                                                        100: CSI Host attached to PHY E
                                                                        101: CSI Host attached to PHY F (forbidden) (DUMMY)
                                                                        110~111: reserved, CSI Host not connected to any PHY (all signals tied 0)
                                                                        Notice that PHYA/PHYE support 2+2 mode, For PHYA/PHYE 2+2 mode, if CSIC select PHYA/PHYE, configure as following:
                                                                         csic_cdphy_sensor_connection=1 & csic_sensor =1 => SensorB(PHY2+2 mode) enable
                                                                         csic_cdphy_sensor_connection=0 & csic_sensor =1 => SensorA(PHY2+2 mode) enable
                                                                         PHY2+2 mode, Sensor A or Sensor B is mutually exclusive. */
    } reg;
} SOC_CSI_WRAPPER_CSIC_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIC_CTRL_csic_en_START                       (25)
#define SOC_CSI_WRAPPER_CSIC_CTRL_csic_en_END                         (25)
#define SOC_CSI_WRAPPER_CSIC_CTRL_csic_sensor_START                   (26)
#define SOC_CSI_WRAPPER_CSIC_CTRL_csic_sensor_END                     (26)
#define SOC_CSI_WRAPPER_CSIC_CTRL_csic_cdphy_sensor_connection_START  (27)
#define SOC_CSI_WRAPPER_CSIC_CTRL_csic_cdphy_sensor_connection_END    (27)
#define SOC_CSI_WRAPPER_CSIC_CTRL_csic_cdphy_source_START             (29)
#define SOC_CSI_WRAPPER_CSIC_CTRL_csic_cdphy_source_END               (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSID_CTRL_UNION
 struct description   : CSID_CTRL Register structure definition
                        Address Offset:0x60C Initial:0x80000000 Width:32
 register description : enables to control CSID Host integration as well as the CDPHY attached to it.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  reserved_0                   : 24; /* bit[0-23] : - */
        unsigned int  fp_fd_sel                    : 1;  /* bit[24]   : CSID is used by FD(Finger Print) and FD(Face detection)
                                                                        0x0: used by FP
                                                                        0x1: used by FD
                                                                        Note: only used for FP in V350 */
        unsigned int  csid_en                      : 1;  /* bit[25]   : Configure this bit to 0x1 when CSID is enabled */
        unsigned int  csid_sensor                  : 1;  /* bit[26]   : Used to select the sensor connected to the CSI2 Host (used for DPHY mode since the correct clock has to be routed) when sensor_connection is set to 0x1
                                                                        0: Sensor A is used
                                                                        1: Sensor B is used  */
        unsigned int  csid_cdphy_sensor_connection : 1;  /* bit[27]   : Defines the number of sensors mounted on the CDPHY (has effect if cdphy_master=0x1)
                                                                        0: One sensor connected to the CDPHY
                                                                        1: Two sensor connected to the CDPHY */
        unsigned int  reserved_1                   : 1;  /* bit[28]   : reserved */
        unsigned int  csid_cdphy_source            : 3;  /* bit[29-31]: Enables to select the PHY to use to attach to the related CSI2 Host
                                                                        000: CSI Host attached to PHY A 
                                                                        001: CSI Host attached to PHY B (forbidden)
                                                                        010: CSI Host attached to PHY C (forbidden)
                                                                        011: CSI Host attached to PHY D (forbidden) (DUMMY)
                                                                        100: CSI Host attached to PHY E
                                                                        101: CSI Host attached to PHY F (forbidden) (DUMMY)
                                                                        110~111: reserved, CSI Host not connected to any PHY (all signals tied 0)
                                                                        Notice that PHYA/PHYE support 2+2 mode, For PHYA/PHYE 2+2 mode, if CSID select PHYA/PHYE, configure as following:
                                                                         csid_cdphy_sensor_connection=1 & csid_sensor =1 => SensorB(PHY2+2 mode) enable
                                                                         csid_cdphy_sensor_connection=0 & csid_sensor =1 => SensorA(PHY2+2 mode) enable
                                                                         PHY2+2 mode, Sensor A or Sensor B is mutually exclusive. */
    } reg;
} SOC_CSI_WRAPPER_CSID_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CSID_CTRL_fp_fd_sel_START                     (24)
#define SOC_CSI_WRAPPER_CSID_CTRL_fp_fd_sel_END                       (24)
#define SOC_CSI_WRAPPER_CSID_CTRL_csid_en_START                       (25)
#define SOC_CSI_WRAPPER_CSID_CTRL_csid_en_END                         (25)
#define SOC_CSI_WRAPPER_CSID_CTRL_csid_sensor_START                   (26)
#define SOC_CSI_WRAPPER_CSID_CTRL_csid_sensor_END                     (26)
#define SOC_CSI_WRAPPER_CSID_CTRL_csid_cdphy_sensor_connection_START  (27)
#define SOC_CSI_WRAPPER_CSID_CTRL_csid_cdphy_sensor_connection_END    (27)
#define SOC_CSI_WRAPPER_CSID_CTRL_csid_cdphy_source_START             (29)
#define SOC_CSI_WRAPPER_CSID_CTRL_csid_cdphy_source_END               (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIE_CTRL_UNION
 struct description   : CSIE_CTRL Register structure definition
                        Address Offset:0x610 Initial:0x00540000 Width:32
 register description : enables to control CSIE Host integration as well as the CDPHY attached to it.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  ipi_cfg_vc                   : 4;  /* bit[0-3]  : Configure the virtual channel ID of IPI interface, only the channel which match ipi_cfg_vc is accept. */
        unsigned int  in_pixel_type                : 1;  /* bit[4]    : 0: raw8
                                                                        1: raw10 */
        unsigned int  round_type                   : 1;  /* bit[5]    : 0: do = din[9:2]
                                                                        1: round up */
        unsigned int  reorder_err_en               : 1;  /* bit[6]    : idi to ipi reorder status enable */
        unsigned int  reserved_0                   : 8;  /* bit[7-14] : reserved */
        unsigned int  phye_cfg_clk_mux             : 1;  /* bit[15]   : 
                                                                        0x0: PHY clk is shared with csi_glb_clk from AO CRG in suspend mode
                                                                        0x1: PHY clk is from peri CRG(80M or 19.2M)
                                                                        Note: SW need to switch to 0x1 when ISP front camera is enabled and using PHYE */
        unsigned int  phya_cfg_clk_mux             : 1;  /* bit[16]   : 
                                                                        0x0: PHY clk is shared with csi_glb_clk from AO CRG in suspend mode
                                                                        0x1: PHY clk is from peri CRG(80M or 19.2M)
                                                                        Note: SW need to switch to 0x1 when ISP front camera is enabled and using PHYA */
        unsigned int  ipi_cfg_dt                   : 6;  /* bit[17-22]: Configure the data type of IPI interface, only the data type which match ipi_cfg_dt is accept.
                                                                        Default data type is RAW8(0x2A). */
        unsigned int  reserved_1                   : 2;  /* bit[23-24]: reserved */
        unsigned int  csie_en                      : 1;  /* bit[25]   : Configure this bit to 0x1 when CSIE is enabled */
        unsigned int  csie_sensor                  : 1;  /* bit[26]   : Used to select the sensor connected to the CSI2 Host (used for DPHY mode since the correct clock has to be routed) when sensor_connection is set to 0x1
                                                                        0: Sensor A is used
                                                                        1: Sensor B is used  */
        unsigned int  csie_cdphy_sensor_connection : 1;  /* bit[27]   : Defines the number of sensors mounted on the CDPHY (has effect if cdphy_master=0x1)
                                                                        0: One sensor connected to the CDPHY
                                                                        1: Two sensor connected to the CDPHY */
        unsigned int  reserved_2                   : 1;  /* bit[28]   : reserved */
        unsigned int  csie_cdphy_source            : 3;  /* bit[29-31]: Enables to select the PHY to use to attach to the related CSI2 Host
                                                                        000: CSI Host attached to PHY A 
                                                                        001: CSI Host attached to PHY B (forbidden)
                                                                        010: CSI Host attached to PHY C
                                                                        011: CSI Host attached to PHY D (DUMMY)
                                                                        100: CSI Host attached to PHY E 
                                                                        101: CSI Host attached to PHY F (forbidden) (DUMMY)
                                                                        110~111: reserved, CSI Host not connected to any PHY (all signals tied 0)
                                                                        Notice that PHYA/PHYE support 2+2 mode, For PHYA/PHYE 2+2 mode, if CSIE select PHYA/PHYE, configure as following:
                                                                         csie_cdphy_sensor_connection=1 & csie_sensor =1 => SensorB(PHY2+2 mode) enable
                                                                         csie_cdphy_sensor_connection=0 & csie_sensor =1 => SensorA(PHY2+2 mode) enable
                                                                         PHY2+2 mode, Sensor A or Sensor B is mutually exclusive. */
    } reg;
} SOC_CSI_WRAPPER_CSIE_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIE_CTRL_ipi_cfg_vc_START                    (0)
#define SOC_CSI_WRAPPER_CSIE_CTRL_ipi_cfg_vc_END                      (3)
#define SOC_CSI_WRAPPER_CSIE_CTRL_in_pixel_type_START                 (4)
#define SOC_CSI_WRAPPER_CSIE_CTRL_in_pixel_type_END                   (4)
#define SOC_CSI_WRAPPER_CSIE_CTRL_round_type_START                    (5)
#define SOC_CSI_WRAPPER_CSIE_CTRL_round_type_END                      (5)
#define SOC_CSI_WRAPPER_CSIE_CTRL_reorder_err_en_START                (6)
#define SOC_CSI_WRAPPER_CSIE_CTRL_reorder_err_en_END                  (6)
#define SOC_CSI_WRAPPER_CSIE_CTRL_phye_cfg_clk_mux_START              (15)
#define SOC_CSI_WRAPPER_CSIE_CTRL_phye_cfg_clk_mux_END                (15)
#define SOC_CSI_WRAPPER_CSIE_CTRL_phya_cfg_clk_mux_START              (16)
#define SOC_CSI_WRAPPER_CSIE_CTRL_phya_cfg_clk_mux_END                (16)
#define SOC_CSI_WRAPPER_CSIE_CTRL_ipi_cfg_dt_START                    (17)
#define SOC_CSI_WRAPPER_CSIE_CTRL_ipi_cfg_dt_END                      (22)
#define SOC_CSI_WRAPPER_CSIE_CTRL_csie_en_START                       (25)
#define SOC_CSI_WRAPPER_CSIE_CTRL_csie_en_END                         (25)
#define SOC_CSI_WRAPPER_CSIE_CTRL_csie_sensor_START                   (26)
#define SOC_CSI_WRAPPER_CSIE_CTRL_csie_sensor_END                     (26)
#define SOC_CSI_WRAPPER_CSIE_CTRL_csie_cdphy_sensor_connection_START  (27)
#define SOC_CSI_WRAPPER_CSIE_CTRL_csie_cdphy_sensor_connection_END    (27)
#define SOC_CSI_WRAPPER_CSIE_CTRL_csie_cdphy_source_START             (29)
#define SOC_CSI_WRAPPER_CSIE_CTRL_csie_cdphy_source_END               (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIF_CTRL_UNION
 struct description   : CSIF_CTRL Register structure definition
                        Address Offset:0x614 Initial:0x60000000 Width:32
 register description : enables to control CSIF Host integration as well as the CDPHY attached to it.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  reserved_0                   : 25; /* bit[0-24] : - */
        unsigned int  csif_en                      : 1;  /* bit[25]   : Configure this bit to 0x1 when CSIF is enabled */
        unsigned int  csif_sensor                  : 1;  /* bit[26]   : Used to select the sensor connected to the CSI2 Host (used for DPHY mode since the correct clock has to be routed) when sensor_connection is set to 0x1
                                                                        0: Sensor A is used
                                                                        1: Sensor B is used  */
        unsigned int  csif_cdphy_sensor_connection : 1;  /* bit[27]   : Defines the number of sensors mounted on the CDPHY (has effect if cdphy_master=0x1)
                                                                        0: One sensor connected to the CDPHY
                                                                        1: Two sensor connected to the CDPHY */
        unsigned int  reserved_1                   : 1;  /* bit[28]   : - */
        unsigned int  csif_cdphy_source            : 3;  /* bit[29-31]: DUMMY
                                                                        Enables to select the PHY to use to attach to the related CSI2 Host
                                                                        000: CSI Host attached to PHY A 
                                                                        001: CSI Host attached to PHY B (forbidden)
                                                                        010: CSI Host attached to PHY C (forbidden)
                                                                        011: CSI Host attached to PHY D 
                                                                        100: CSI Host attached to PHY E (forbidden)
                                                                        101: CSI Host attached to PHY F 
                                                                        110~111: reserved, CSI Host not connected to any PHY (all signals tied 0) */
    } reg;
} SOC_CSI_WRAPPER_CSIF_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIF_CTRL_csif_en_START                       (25)
#define SOC_CSI_WRAPPER_CSIF_CTRL_csif_en_END                         (25)
#define SOC_CSI_WRAPPER_CSIF_CTRL_csif_sensor_START                   (26)
#define SOC_CSI_WRAPPER_CSIF_CTRL_csif_sensor_END                     (26)
#define SOC_CSI_WRAPPER_CSIF_CTRL_csif_cdphy_sensor_connection_START  (27)
#define SOC_CSI_WRAPPER_CSIF_CTRL_csif_cdphy_sensor_connection_END    (27)
#define SOC_CSI_WRAPPER_CSIF_CTRL_csif_cdphy_source_START             (29)
#define SOC_CSI_WRAPPER_CSIF_CTRL_csif_cdphy_source_END               (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIG_CTRL_UNION
 struct description   : CSIG_CTRL Register structure definition
                        Address Offset:0x618 Initial:0xA0000000 Width:32
 register description : enables to control CSIG Host integration as well as the CDPHY attached to it.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  reserved_0                   : 25; /* bit[0-24] : - */
        unsigned int  csig_en                      : 1;  /* bit[25]   : Configure this bit to 0x1 when CSIG is enabled */
        unsigned int  csig_sensor                  : 1;  /* bit[26]   : Used to select the sensor connected to the CSI2 Host (used for DPHY mode since the correct clock has to be routed) when sensor_connection is set to 0x1
                                                                        0: Sensor A is used
                                                                        1: Sensor B is used  */
        unsigned int  csig_cdphy_sensor_connection : 1;  /* bit[27]   : Defines the number of sensors mounted on the CDPHY (has effect if cdphy_master=0x1)
                                                                        0: One sensor connected to the CDPHY
                                                                        1: Two sensor connected to the CDPHY */
        unsigned int  reserved_1                   : 1;  /* bit[28]   : - */
        unsigned int  csig_cdphy_source            : 3;  /* bit[29-31]: DUMMY
                                                                        Enables to select the PHY to use to attach to the related CSI2 Host
                                                                        000: CSI Host attached to PHY A (forbidden)
                                                                        001: CSI Host attached to PHY B (forbidden)
                                                                        010: CSI Host attached to PHY C
                                                                        011: CSI Host attached to PHY D (forbidden)
                                                                        100: CSI Host attached to PHY E (forbidden)
                                                                        101: CSI Host attached to PHY F
                                                                        110~111: reserved, CSI Host not connected to any PHY (all signals tied 0)
                                                                        Notice that PHYA/PHYE support 2+2 mode, For PHYA/PHYE 2+2 mode, if CSIC select PHYA/PHYE, configure as following:
                                                                         csic_cdphy_sensor_connection=1 & csic_sensor =1 => SensorB(PHY2+2 mode) enable
                                                                         csic_cdphy_sensor_connection=0 & csic_sensor =1 => SensorA(PHY2+2 mode) enable
                                                                         PHY2+2 mode, Sensor A or Sensor B is mutually exclusive. */
    } reg;
} SOC_CSI_WRAPPER_CSIG_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIG_CTRL_csig_en_START                       (25)
#define SOC_CSI_WRAPPER_CSIG_CTRL_csig_en_END                         (25)
#define SOC_CSI_WRAPPER_CSIG_CTRL_csig_sensor_START                   (26)
#define SOC_CSI_WRAPPER_CSIG_CTRL_csig_sensor_END                     (26)
#define SOC_CSI_WRAPPER_CSIG_CTRL_csig_cdphy_sensor_connection_START  (27)
#define SOC_CSI_WRAPPER_CSIG_CTRL_csig_cdphy_sensor_connection_END    (27)
#define SOC_CSI_WRAPPER_CSIG_CTRL_csig_cdphy_source_START             (29)
#define SOC_CSI_WRAPPER_CSIG_CTRL_csig_cdphy_source_END               (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_DBG_UNION
 struct description   : CSI_DBG Register structure definition
                        Address Offset:0x800 Initial:0x00000000 Width:32
 register description : CSI Debug control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csi_debug_en  : 1;  /* bit[0]   : CSI IDI AFIFO overflow monitor enable.
                                                        0x1: enable CSI debug function
                                                        0x0: disable CSI debug function */
        unsigned int  csia_overflow : 1;  /* bit[1]   : CSIA IDI AFIFO overflow status, only valid when csi_debug_en=1
                                                        Set csi_debug_en=0 to clear the overflow status. */
        unsigned int  csib_overflow : 1;  /* bit[2]   : CSIB IDI AFIFO overflow status, only valid when csi_debug_en=1
                                                        Set csi_debug_en=0 to clear the overflow status. */
        unsigned int  csic_overflow : 1;  /* bit[3]   : CSIC IDI AFIFO overflow status, only valid when csi_debug_en=1
                                                        Set csi_debug_en=0 to clear the overflow status. */
        unsigned int  csid_overflow : 1;  /* bit[4]   : CSID IDI AFIFO overflow status, only valid when csi_debug_en=1
                                                        Set csi_debug_en=0 to clear the overflow status. */
        unsigned int  csie_overflow : 1;  /* bit[5]   : CSIE IDI AFIFO overflow status, only valid when csi_debug_en=1
                                                        Set csi_debug_en=0 to clear the overflow status. */
        unsigned int  csif_overflow : 1;  /* bit[6]   : DUMMY
                                                        CSIF IDI AFIFO overflow status, only valid when csi_debug_en=1
                                                        Set csi_debug_en=0 to clear the overflow status. */
        unsigned int  csig_overflow : 1;  /* bit[7]   : DUMMY
                                                        CSIG IDI AFIFO overflow status, only valid when csi_debug_en=1
                                                        Set csi_debug_en=0 to clear the overflow status. */
        unsigned int  reorder_err   : 1;  /* bit[8]   : only for raw10
                                                        0: Input data is legal.
                                                        1: When idi_vvalid is high, the number of input bytes is not a multiple of 5. */
        unsigned int  reserved      : 23; /* bit[9-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_DBG_csi_debug_en_START   (0)
#define SOC_CSI_WRAPPER_CSI_DBG_csi_debug_en_END     (0)
#define SOC_CSI_WRAPPER_CSI_DBG_csia_overflow_START  (1)
#define SOC_CSI_WRAPPER_CSI_DBG_csia_overflow_END    (1)
#define SOC_CSI_WRAPPER_CSI_DBG_csib_overflow_START  (2)
#define SOC_CSI_WRAPPER_CSI_DBG_csib_overflow_END    (2)
#define SOC_CSI_WRAPPER_CSI_DBG_csic_overflow_START  (3)
#define SOC_CSI_WRAPPER_CSI_DBG_csic_overflow_END    (3)
#define SOC_CSI_WRAPPER_CSI_DBG_csid_overflow_START  (4)
#define SOC_CSI_WRAPPER_CSI_DBG_csid_overflow_END    (4)
#define SOC_CSI_WRAPPER_CSI_DBG_csie_overflow_START  (5)
#define SOC_CSI_WRAPPER_CSI_DBG_csie_overflow_END    (5)
#define SOC_CSI_WRAPPER_CSI_DBG_csif_overflow_START  (6)
#define SOC_CSI_WRAPPER_CSI_DBG_csif_overflow_END    (6)
#define SOC_CSI_WRAPPER_CSI_DBG_csig_overflow_START  (7)
#define SOC_CSI_WRAPPER_CSI_DBG_csig_overflow_END    (7)
#define SOC_CSI_WRAPPER_CSI_DBG_reorder_err_START    (8)
#define SOC_CSI_WRAPPER_CSI_DBG_reorder_err_END      (8)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIA_DBG_UNION
 struct description   : CSIA_DBG Register structure definition
                        Address Offset:0x804 Initial:0x00000000 Width:32
 register description : CSIA Debug control2
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csia_dbg_hcnt     : 13; /* bit[0-12] : The current hcnt for current line, cyle unit */
        unsigned int  csia_dbg_hcnt_max : 13; /* bit[13-25]: The line width for one line, cycle unit, total_byte_cnt = hcnt_max * lane_num */
        unsigned int  csia_dbg_v_flag   : 1;  /* bit[26]   : The frame flag indicator, v_flag change every frame */
        unsigned int  reserved          : 5;  /* bit[27-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIA_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIA_DBG_csia_dbg_hcnt_START      (0)
#define SOC_CSI_WRAPPER_CSIA_DBG_csia_dbg_hcnt_END        (12)
#define SOC_CSI_WRAPPER_CSIA_DBG_csia_dbg_hcnt_max_START  (13)
#define SOC_CSI_WRAPPER_CSIA_DBG_csia_dbg_hcnt_max_END    (25)
#define SOC_CSI_WRAPPER_CSIA_DBG_csia_dbg_v_flag_START    (26)
#define SOC_CSI_WRAPPER_CSIA_DBG_csia_dbg_v_flag_END      (26)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIB_DBG_UNION
 struct description   : CSIB_DBG Register structure definition
                        Address Offset:0x808 Initial:0x00000000 Width:32
 register description : CSIB Debug control2
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csib_dbg_hcnt     : 13; /* bit[0-12] : The current hcnt for current line, cyle unit */
        unsigned int  csib_dbg_hcnt_max : 13; /* bit[13-25]: The line width for one line, cycle unit, total_byte_cnt = hcnt_max * lane_num */
        unsigned int  csib_dbg_v_flag   : 1;  /* bit[26]   : The frame flag indicator, v_flag change every frame */
        unsigned int  reserved          : 5;  /* bit[27-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIB_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIB_DBG_csib_dbg_hcnt_START      (0)
#define SOC_CSI_WRAPPER_CSIB_DBG_csib_dbg_hcnt_END        (12)
#define SOC_CSI_WRAPPER_CSIB_DBG_csib_dbg_hcnt_max_START  (13)
#define SOC_CSI_WRAPPER_CSIB_DBG_csib_dbg_hcnt_max_END    (25)
#define SOC_CSI_WRAPPER_CSIB_DBG_csib_dbg_v_flag_START    (26)
#define SOC_CSI_WRAPPER_CSIB_DBG_csib_dbg_v_flag_END      (26)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIC_DBG_UNION
 struct description   : CSIC_DBG Register structure definition
                        Address Offset:0x80C Initial:0x00000000 Width:32
 register description : CSIB Debug control2
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csic_dbg_hcnt     : 13; /* bit[0-12] : The current hcnt for current line, cyle unit */
        unsigned int  csic_dbg_hcnt_max : 13; /* bit[13-25]: The line width for one line, cycle unit, total_byte_cnt = hcnt_max * lane_num */
        unsigned int  csic_dbg_v_flag   : 1;  /* bit[26]   : The frame flag indicator, v_flag change every frame */
        unsigned int  reserved          : 5;  /* bit[27-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIC_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIC_DBG_csic_dbg_hcnt_START      (0)
#define SOC_CSI_WRAPPER_CSIC_DBG_csic_dbg_hcnt_END        (12)
#define SOC_CSI_WRAPPER_CSIC_DBG_csic_dbg_hcnt_max_START  (13)
#define SOC_CSI_WRAPPER_CSIC_DBG_csic_dbg_hcnt_max_END    (25)
#define SOC_CSI_WRAPPER_CSIC_DBG_csic_dbg_v_flag_START    (26)
#define SOC_CSI_WRAPPER_CSIC_DBG_csic_dbg_v_flag_END      (26)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSID_DBG_UNION
 struct description   : CSID_DBG Register structure definition
                        Address Offset:0x810 Initial:0x00000000 Width:32
 register description : CSIB Debug control2
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csid_dbg_hcnt     : 13; /* bit[0-12] : The current hcnt for current line, cyle unit */
        unsigned int  csid_dbg_hcnt_max : 13; /* bit[13-25]: The line width for one line, cycle unit, total_byte_cnt = hcnt_max * lane_num */
        unsigned int  csid_dbg_v_flag   : 1;  /* bit[26]   : The frame flag indicator, v_flag change every frame */
        unsigned int  reserved          : 5;  /* bit[27-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSID_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CSID_DBG_csid_dbg_hcnt_START      (0)
#define SOC_CSI_WRAPPER_CSID_DBG_csid_dbg_hcnt_END        (12)
#define SOC_CSI_WRAPPER_CSID_DBG_csid_dbg_hcnt_max_START  (13)
#define SOC_CSI_WRAPPER_CSID_DBG_csid_dbg_hcnt_max_END    (25)
#define SOC_CSI_WRAPPER_CSID_DBG_csid_dbg_v_flag_START    (26)
#define SOC_CSI_WRAPPER_CSID_DBG_csid_dbg_v_flag_END      (26)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIE_DBG_UNION
 struct description   : CSIE_DBG Register structure definition
                        Address Offset:0x814 Initial:0x00000000 Width:32
 register description : CSIB Debug control2
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csie_dbg_hcnt     : 13; /* bit[0-12] : The current hcnt for current line, cyle unit */
        unsigned int  csie_dbg_hcnt_max : 13; /* bit[13-25]: The line width for one line, cycle unit, total_byte_cnt = hcnt_max * lane_num */
        unsigned int  csie_dbg_v_flag   : 1;  /* bit[26]   : The frame flag indicator, v_flag change every frame */
        unsigned int  reserved          : 5;  /* bit[27-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIE_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIE_DBG_csie_dbg_hcnt_START      (0)
#define SOC_CSI_WRAPPER_CSIE_DBG_csie_dbg_hcnt_END        (12)
#define SOC_CSI_WRAPPER_CSIE_DBG_csie_dbg_hcnt_max_START  (13)
#define SOC_CSI_WRAPPER_CSIE_DBG_csie_dbg_hcnt_max_END    (25)
#define SOC_CSI_WRAPPER_CSIE_DBG_csie_dbg_v_flag_START    (26)
#define SOC_CSI_WRAPPER_CSIE_DBG_csie_dbg_v_flag_END      (26)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIF_DBG_UNION
 struct description   : CSIF_DBG Register structure definition
                        Address Offset:0x818 Initial:0x00000000 Width:32
 register description : CSIB Debug control2
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csif_dbg_hcnt     : 13; /* bit[0-12] : The current hcnt for current line, cyle unit */
        unsigned int  csif_dbg_hcnt_max : 13; /* bit[13-25]: The line width for one line, cycle unit, total_byte_cnt = hcnt_max * lane_num */
        unsigned int  csif_dbg_v_flag   : 1;  /* bit[26]   : The frame flag indicator, v_flag change every frame */
        unsigned int  reserved          : 5;  /* bit[27-31]: DUMMY
                                                             Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIF_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIF_DBG_csif_dbg_hcnt_START      (0)
#define SOC_CSI_WRAPPER_CSIF_DBG_csif_dbg_hcnt_END        (12)
#define SOC_CSI_WRAPPER_CSIF_DBG_csif_dbg_hcnt_max_START  (13)
#define SOC_CSI_WRAPPER_CSIF_DBG_csif_dbg_hcnt_max_END    (25)
#define SOC_CSI_WRAPPER_CSIF_DBG_csif_dbg_v_flag_START    (26)
#define SOC_CSI_WRAPPER_CSIF_DBG_csif_dbg_v_flag_END      (26)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIG_DBG_UNION
 struct description   : CSIG_DBG Register structure definition
                        Address Offset:0x81C Initial:0x00000000 Width:32
 register description : CSIB Debug control2
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csig_dbg_hcnt     : 13; /* bit[0-12] : The current hcnt for current line, cyle unit */
        unsigned int  csig_dbg_hcnt_max : 13; /* bit[13-25]: The line width for one line, cycle unit, total_byte_cnt = hcnt_max * lane_num */
        unsigned int  csig_dbg_v_flag   : 1;  /* bit[26]   : The frame flag indicator, v_flag change every frame */
        unsigned int  reserved          : 5;  /* bit[27-31]: DUMMY
                                                             Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIG_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIG_DBG_csig_dbg_hcnt_START      (0)
#define SOC_CSI_WRAPPER_CSIG_DBG_csig_dbg_hcnt_END        (12)
#define SOC_CSI_WRAPPER_CSIG_DBG_csig_dbg_hcnt_max_START  (13)
#define SOC_CSI_WRAPPER_CSIG_DBG_csig_dbg_hcnt_max_END    (25)
#define SOC_CSI_WRAPPER_CSIG_DBG_csig_dbg_v_flag_START    (26)
#define SOC_CSI_WRAPPER_CSIG_DBG_csig_dbg_v_flag_END      (26)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_PHY_DBG_TESTDOUT_SEL_UNION
 struct description   : PHY_DBG_TESTDOUT_SEL Register structure definition
                        Address Offset:0x820 Initial:0x00000000 Width:32
 register description : Dbg_out.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phy_dbg_testdout_sel : 3;  /* bit[0-2] : tp_dphy4l_testdout select
                                                               3'b000: tp_dphy4l_rx0_testdout
                                                               3'b001: tp_dphy4l_rx1_testdout
                                                               3'b010: tp_dphy4l_rx2_testdout
                                                               3'b011: tp_dphy4l_rx3_testdout DUMMY
                                                               3'b100: tp_dphy4l_rx4_testdout
                                                               3'b101: tp_dphy4l_rx5_testdout DUMMY */
        unsigned int  reserved             : 29; /* bit[3-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_PHY_DBG_TESTDOUT_SEL_UNION;
#endif
#define SOC_CSI_WRAPPER_PHY_DBG_TESTDOUT_SEL_phy_dbg_testdout_sel_START  (0)
#define SOC_CSI_WRAPPER_PHY_DBG_TESTDOUT_SEL_phy_dbg_testdout_sel_END    (2)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIF_CGR_UNION
 struct description   : CSIF_CGR Register structure definition
                        Address Offset:0x900 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csif  : 1;  /* bit[0]   : Functional clock gate control for CSIF, clock is gated when set to 0 */
        unsigned int  reserved : 31; /* bit[1-31]: CSIF DUMMY
                                                   Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIF_CGR_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIF_CGR_cg_csif_START   (0)
#define SOC_CSI_WRAPPER_CSIF_CGR_cg_csif_END     (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIF_CGR_SET_UNION
 struct description   : CSIF_CGR_SET Register structure definition
                        Address Offset:0x904 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csif  : 1;  /* bit[0]   : When writing a one in a field, set the related bits */
        unsigned int  reserved : 31; /* bit[1-31]: CSIF DUMMY
                                                   Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIF_CGR_SET_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIF_CGR_SET_cg_csif_START   (0)
#define SOC_CSI_WRAPPER_CSIF_CGR_SET_cg_csif_END     (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIF_CGR_CLEAR_UNION
 struct description   : CSIF_CGR_CLEAR Register structure definition
                        Address Offset:0x908 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csif  : 1;  /* bit[0]   : When writing a one in a field, clear the related bits */
        unsigned int  reserved : 31; /* bit[1-31]: CSIF DUMMY
                                                   Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIF_CGR_CLEAR_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIF_CGR_CLEAR_cg_csif_START   (0)
#define SOC_CSI_WRAPPER_CSIF_CGR_CLEAR_cg_csif_END     (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIF_RESET_UNION
 struct description   : CSIF_RESET Register structure definition
                        Address Offset:0x90C Initial:0x00000000 Width:32
 register description : Soft reset control for each module which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  soft_rst_csif : 1;  /* bit[0]   : Software reset control for CSIF, set to 1 to reset  */
        unsigned int  reserved      : 31; /* bit[1-31]: CSIF DUMMY
                                                        Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIF_RESET_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIF_RESET_soft_rst_csif_START  (0)
#define SOC_CSI_WRAPPER_CSIF_RESET_soft_rst_csif_END    (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_PHY_CSI_F_DBG_UNION
 struct description   : PHY_CSI_F_DBG Register structure definition
                        Address Offset:0x910 Initial:0x00010F00 Width:32
 register description : PHY CSI-F debug status.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyf_rxactivehs_0      : 1;  /* bit[0]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 0. */
        unsigned int  phyf_rxactivehs_1      : 1;  /* bit[1]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 1. */
        unsigned int  phyf_rxactivehs_2      : 1;  /* bit[2]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 2. */
        unsigned int  phyf_rxactivehs_3      : 1;  /* bit[3]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 3. */
        unsigned int  phyf_rxlpdtesc_0       : 1;  /* bit[4]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyf_rxlpdtesc_1       : 1;  /* bit[5]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyf_rxlpdtesc_2       : 1;  /* bit[6]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyf_rxlpdtesc_3       : 1;  /* bit[7]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyf_ulpsactivenot_0   : 1;  /* bit[8]    : ctive Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyf_ulpsactivenot_1   : 1;  /* bit[9]    : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyf_ulpsactivenot_2   : 1;  /* bit[10]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyf_ulpsactivenot_3   : 1;  /* bit[11]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyf_errsyncesc_0      : 1;  /* bit[12]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyf_errsyncesc_1      : 1;  /* bit[13]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyf_errsyncesc_2      : 1;  /* bit[14]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyf_errsyncesc_3      : 1;  /* bit[15]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyf_ulpsactivenotclk  : 1;  /* bit[16]   : Active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSCLK. TXCLKESC must be supplied to the macro until ULPSACTIVENOTCLK is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted together with RXCLKULPSNOT; at the end of the ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSCLKNOT signal is deasserted. */
        unsigned int  reserved_0             : 3;  /* bit[17-19]:  */
        unsigned int  phyf_rxinvalidcodehs_0 : 2;  /* bit[20-21]:  */
        unsigned int  phyf_rxinvalidcodehs_1 : 2;  /* bit[22-23]:  */
        unsigned int  phyf_rxinvalidcodehs_2 : 2;  /* bit[24-25]:  */
        unsigned int  reserved_1             : 6;  /* bit[26-31]: CSIF DUMMY
                                                                  Reserved */
    } reg;
} SOC_CSI_WRAPPER_PHY_CSI_F_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxactivehs_0_START       (0)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxactivehs_0_END         (0)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxactivehs_1_START       (1)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxactivehs_1_END         (1)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxactivehs_2_START       (2)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxactivehs_2_END         (2)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxactivehs_3_START       (3)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxactivehs_3_END         (3)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxlpdtesc_0_START        (4)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxlpdtesc_0_END          (4)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxlpdtesc_1_START        (5)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxlpdtesc_1_END          (5)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxlpdtesc_2_START        (6)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxlpdtesc_2_END          (6)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxlpdtesc_3_START        (7)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxlpdtesc_3_END          (7)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_ulpsactivenot_0_START    (8)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_ulpsactivenot_0_END      (8)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_ulpsactivenot_1_START    (9)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_ulpsactivenot_1_END      (9)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_ulpsactivenot_2_START    (10)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_ulpsactivenot_2_END      (10)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_ulpsactivenot_3_START    (11)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_ulpsactivenot_3_END      (11)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_errsyncesc_0_START       (12)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_errsyncesc_0_END         (12)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_errsyncesc_1_START       (13)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_errsyncesc_1_END         (13)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_errsyncesc_2_START       (14)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_errsyncesc_2_END         (14)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_errsyncesc_3_START       (15)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_errsyncesc_3_END         (15)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_ulpsactivenotclk_START   (16)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_ulpsactivenotclk_END     (16)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxinvalidcodehs_0_START  (20)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxinvalidcodehs_0_END    (21)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxinvalidcodehs_1_START  (22)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxinvalidcodehs_1_END    (23)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxinvalidcodehs_2_START  (24)
#define SOC_CSI_WRAPPER_PHY_CSI_F_DBG_phyf_rxinvalidcodehs_2_END    (25)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_F_IDI_SEL_UNION
 struct description   : CSI_F_IDI_SEL Register structure definition
                        Address Offset:0x914 Initial:0x00000000 Width:32
 register description : csi and mudp idi intf sel
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  idi_sel_f : 1;  /* bit[0]   : 0: CSI F IDI
                                                    1: MUDP IDI */
        unsigned int  reserved  : 31; /* bit[1-31]: DUMMY */
    } reg;
} SOC_CSI_WRAPPER_CSI_F_IDI_SEL_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_F_IDI_SEL_idi_sel_f_START  (0)
#define SOC_CSI_WRAPPER_CSI_F_IDI_SEL_idi_sel_f_END    (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_F_FORCE_PCLKON_UNION
 struct description   : CSI_F_FORCE_PCLKON Register structure definition
                        Address Offset:0x918 Initial:0x00000001 Width:32
 register description : force pclk on of csi controller
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csif_force_pclk_on : 1;  /* bit[0]   : set 1 to force pclk always on of csi controller */
        unsigned int  reserved           : 31; /* bit[1-31]: CSIF DUMMY
                                                             Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSI_F_FORCE_PCLKON_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_F_FORCE_PCLKON_csif_force_pclk_on_START  (0)
#define SOC_CSI_WRAPPER_CSI_F_FORCE_PCLKON_csif_force_pclk_on_END    (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIG_CGR_UNION
 struct description   : CSIG_CGR Register structure definition
                        Address Offset:0xA00 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csig  : 1;  /* bit[0]   : Functional clock gate control for CSIG, clock is gated when set to 0 */
        unsigned int  reserved : 31; /* bit[1-31]: CSIG DUMMY
                                                   Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIG_CGR_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIG_CGR_cg_csig_START   (0)
#define SOC_CSI_WRAPPER_CSIG_CGR_cg_csig_END     (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIG_CGR_SET_UNION
 struct description   : CSIG_CGR_SET Register structure definition
                        Address Offset:0xA04 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csig  : 1;  /* bit[0]   : When writing a one in a field, set the related bits */
        unsigned int  reserved : 31; /* bit[1-31]: CSIG DUMMY
                                                   Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIG_CGR_SET_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIG_CGR_SET_cg_csig_START   (0)
#define SOC_CSI_WRAPPER_CSIG_CGR_SET_cg_csig_END     (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIG_CGR_CLEAR_UNION
 struct description   : CSIG_CGR_CLEAR Register structure definition
                        Address Offset:0xA08 Initial:0x00000000 Width:32
 register description : used to gate the clock which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  cg_csig  : 1;  /* bit[0]   : When writing a one in a field, clear the related bits */
        unsigned int  reserved : 31; /* bit[1-31]: CSIG DUMMY
                                                   Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIG_CGR_CLEAR_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIG_CGR_CLEAR_cg_csig_START   (0)
#define SOC_CSI_WRAPPER_CSIG_CGR_CLEAR_cg_csig_END     (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSIG_RESET_UNION
 struct description   : CSIG_RESET Register structure definition
                        Address Offset:0xA0C Initial:0x00000000 Width:32
 register description : Soft reset control for each module which is generally controlled by HW
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  soft_rst_csig : 1;  /* bit[0]   : Software reset control for CSIG, set to 1 to reset  */
        unsigned int  reserved      : 31; /* bit[1-31]: CSIG DUMMY
                                                        Reserved */
    } reg;
} SOC_CSI_WRAPPER_CSIG_RESET_UNION;
#endif
#define SOC_CSI_WRAPPER_CSIG_RESET_soft_rst_csig_START  (0)
#define SOC_CSI_WRAPPER_CSIG_RESET_soft_rst_csig_END    (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_PHY_CSI_G_DBG_UNION
 struct description   : PHY_CSI_G_DBG Register structure definition
                        Address Offset:0xA10 Initial:0x00010F00 Width:32
 register description : PHY CSI-G debug status.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyg_rxactivehs_0      : 1;  /* bit[0]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 0. */
        unsigned int  phyg_rxactivehs_1      : 1;  /* bit[1]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 1. */
        unsigned int  phyg_rxactivehs_2      : 1;  /* bit[2]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 2. */
        unsigned int  phyg_rxactivehs_3      : 1;  /* bit[3]    : High speed interface.High-speed reception active. This signal indicates that the lane module is actively receiving a high-speed data transmission from lane interconnect 3. */
        unsigned int  phyg_rxlpdtesc_0       : 1;  /* bit[4]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyg_rxlpdtesc_1       : 1;  /* bit[5]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyg_rxlpdtesc_2       : 1;  /* bit[6]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyg_rxlpdtesc_3       : 1;  /* bit[7]    : Escape Low Power Data Receive Mode. This signal is asserted to indicate that the lane module is now in Low Power Data Receive Mode. While in this mode, received data is driven onto RXDATAESC output bus when RXVALIDESC is active. RXLPDTESC remains asserted until a STOP state is detected on the lane interconnect. */
        unsigned int  phyg_ulpsactivenot_0   : 1;  /* bit[8]    : ctive Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyg_ulpsactivenot_1   : 1;  /* bit[9]    : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyg_ulpsactivenot_2   : 1;  /* bit[10]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyg_ulpsactivenot_3   : 1;  /* bit[11]   : active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSESC and TXREQUESTESC (or TXULPSCLK) are asserted. TXCLKESC must be supplied to the macro until ULPSACTIVENOT is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXREQUESTESC or TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted; at the end of the
                                                                  ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSESC (or
                                                                  RXULPSCLKNOT) signal is deasserted. */
        unsigned int  phyg_errsyncesc_0      : 1;  /* bit[12]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyg_errsyncesc_1      : 1;  /* bit[13]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyg_errsyncesc_2      : 1;  /* bit[14]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyg_errsyncesc_3      : 1;  /* bit[15]   : Low Power Data Transmission Synchronization Error. If the number of bits received during low power data transmission mode is not a multiple of eight (8) when the transmission ends, this signal is asserted and remains high until the line returns to Stop state. */
        unsigned int  phyg_ulpsactivenotclk  : 1;  /* bit[16]   : Active Low. Indicates that the lane is in the Ultra Low Power state. For a Tx lane, this signal is asserted some time after TXULPSCLK. TXCLKESC must be supplied to the macro until ULPSACTIVENOTCLK is asserted.
                                                                  In order to leave ULP state, the transmitter first drives TXULPSEXIT high, then waits for ULPSACTIVENOT to become high (inactive). At that point, the macro is active and has started transmitting a Mark-1 on the Lines. The protocol waits for a time Twakeup and then drives TXULPSCLK inactive to return the Lane to Stop state.
                                                                  For a Rx lane, this signal indicates that the lane is in ULP state. At the beginning of ULP state, ULPSACTIVENOT is asserted together with RXCLKULPSNOT; at the end of the ULP state, this signal becomes inactive to indicate that the Mark-1 state has been observed. Later, after a period of time Twakeup, the RXULPSCLKNOT signal is deasserted. */
        unsigned int  reserved_0             : 3;  /* bit[17-19]:  */
        unsigned int  phyg_rxinvalidcodehs_0 : 2;  /* bit[20-21]:  */
        unsigned int  phyg_rxinvalidcodehs_1 : 2;  /* bit[22-23]:  */
        unsigned int  phyg_rxinvalidcodehs_2 : 2;  /* bit[24-25]:  */
        unsigned int  reserved_1             : 6;  /* bit[26-31]: CSIG DUMMY
                                                                  Reserved
                                                                  
                                                                  This used for phyg cfg clock calculation.
                                                                  Phy_cfg_clk = apb_clk * 16/phy_clk_dbg_cnt
                                                                  apb_clk is the configuration clock for CSI WRAPPER */
    } reg;
} SOC_CSI_WRAPPER_PHY_CSI_G_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxactivehs_0_START       (0)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxactivehs_0_END         (0)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxactivehs_1_START       (1)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxactivehs_1_END         (1)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxactivehs_2_START       (2)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxactivehs_2_END         (2)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxactivehs_3_START       (3)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxactivehs_3_END         (3)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxlpdtesc_0_START        (4)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxlpdtesc_0_END          (4)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxlpdtesc_1_START        (5)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxlpdtesc_1_END          (5)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxlpdtesc_2_START        (6)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxlpdtesc_2_END          (6)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxlpdtesc_3_START        (7)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxlpdtesc_3_END          (7)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_ulpsactivenot_0_START    (8)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_ulpsactivenot_0_END      (8)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_ulpsactivenot_1_START    (9)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_ulpsactivenot_1_END      (9)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_ulpsactivenot_2_START    (10)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_ulpsactivenot_2_END      (10)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_ulpsactivenot_3_START    (11)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_ulpsactivenot_3_END      (11)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_errsyncesc_0_START       (12)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_errsyncesc_0_END         (12)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_errsyncesc_1_START       (13)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_errsyncesc_1_END         (13)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_errsyncesc_2_START       (14)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_errsyncesc_2_END         (14)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_errsyncesc_3_START       (15)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_errsyncesc_3_END         (15)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_ulpsactivenotclk_START   (16)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_ulpsactivenotclk_END     (16)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxinvalidcodehs_0_START  (20)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxinvalidcodehs_0_END    (21)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxinvalidcodehs_1_START  (22)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxinvalidcodehs_1_END    (23)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxinvalidcodehs_2_START  (24)
#define SOC_CSI_WRAPPER_PHY_CSI_G_DBG_phyg_rxinvalidcodehs_2_END    (25)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_G_IDI_SEL_UNION
 struct description   : CSI_G_IDI_SEL Register structure definition
                        Address Offset:0xA14 Initial:0x00000000 Width:32
 register description : csi and mudp idi intf sel
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  idi_sel_g : 1;  /* bit[0]   : 0: CSI G IDI
                                                    1: MUDP IDI */
        unsigned int  reserved  : 31; /* bit[1-31]: DUMMY */
    } reg;
} SOC_CSI_WRAPPER_CSI_G_IDI_SEL_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_G_IDI_SEL_idi_sel_g_START  (0)
#define SOC_CSI_WRAPPER_CSI_G_IDI_SEL_idi_sel_g_END    (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_G_FORCE_PCLKON_UNION
 struct description   : CSI_G_FORCE_PCLKON Register structure definition
                        Address Offset:0xA18 Initial:0x00000001 Width:32
 register description : force pclk on of csi controller
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csig_force_pclk_on : 1;  /* bit[0]   : set 1 to force pclk always on of csi controller */
        unsigned int  reserved           : 31; /* bit[1-31]: CSIG DUMMY */
    } reg;
} SOC_CSI_WRAPPER_CSI_G_FORCE_PCLKON_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_G_FORCE_PCLKON_csig_force_pclk_on_START  (0)
#define SOC_CSI_WRAPPER_CSI_G_FORCE_PCLKON_csig_force_pclk_on_END    (0)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_UNION
 struct description   : CDPHY_A_TEST_CTRL Register structure definition
                        Address Offset:0xB00 Initial:0x00000800 Width:32
 register description : PHY Test interface control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phya_testdin : 10; /* bit[0-9]  : PHY test interface input 10-bit data bus for internal register programming and test functionalities access. */
        unsigned int  phya_testen  : 1;  /* bit[10]   : PHY test interface operation selector:
                                                        - 1: Configures address write operation on the falling edge of TESTCLK
                                                        - 0: Configures a data write operation on the rising edge of TESTCLK. */
        unsigned int  phya_testclr : 1;  /* bit[11]   : PHY test interface clear
                                                        It is used when active performs vendor specific interface initialization, Active High. */
        unsigned int  phya_testclk : 1;  /* bit[12]   : test interface strobe signal
                                                        It is used to clock TESTDIN bus into the PHY. In conjunction with TESTEN signal controls the operation selection. */
        unsigned int  reserved     : 3;  /* bit[13-15]:  */
        unsigned int  bitmasken    : 16; /* bit[16-31]: reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_phya_testdin_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_phya_testdin_END    (9)
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_phya_testen_START   (10)
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_phya_testen_END     (10)
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_phya_testclr_START  (11)
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_phya_testclr_END    (11)
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_phya_testclk_START  (12)
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_phya_testclk_END    (12)
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_bitmasken_START     (16)
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_CTRL_bitmasken_END       (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_A_TEST_DOUT_UNION
 struct description   : CDPHY_A_TEST_DOUT Register structure definition
                        Address Offset:0xB04 Initial:0x00000000 Width:32
 register description : PHY Test interface dout
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phya_testdout : 10; /* bit[0-9]  : PHY output 10-bit data bus for read-back and internal probing functionalities. */
        unsigned int  reserved      : 22; /* bit[10-31]:  */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_A_TEST_DOUT_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_DOUT_phya_testdout_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_A_TEST_DOUT_phya_testdout_END    (9)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_A_SHUTDOWN_RST_CTRL_UNION
 struct description   : CDPHY_A_SHUTDOWN_RST_CTRL Register structure definition
                        Address Offset:0xB08 Initial:0x00000000 Width:32
 register description : PHY reset control.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phya_rstz      : 1;  /* bit[0]   : PHY reset output. Active Low. */
        unsigned int  phya_shutdownz : 1;  /* bit[1]   : Shutdown input
                                                         This line is used to place the complete macro in power down. All
                                                         analog blocks are in power down mode and digital logic is cleared.
                                                         Active Low. */
        unsigned int  reserved       : 30; /* bit[2-31]: reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_A_SHUTDOWN_RST_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_A_SHUTDOWN_RST_CTRL_phya_rstz_START       (0)
#define SOC_CSI_WRAPPER_CDPHY_A_SHUTDOWN_RST_CTRL_phya_rstz_END         (0)
#define SOC_CSI_WRAPPER_CDPHY_A_SHUTDOWN_RST_CTRL_phya_shutdownz_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_A_SHUTDOWN_RST_CTRL_phya_shutdownz_END    (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_A_CTRL_UNION
 struct description   : CDPHY_A_CTRL Register structure definition
                        Address Offset:0xB0C Initial:0x00000000 Width:32
 register description : PHY mode and enable control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phya_enable_0             : 1;  /* bit[0]    : Enable lane 0 module */
        unsigned int  phya_enable_1             : 1;  /* bit[1]    : Enable lane 1 module */
        unsigned int  phya_enable_2             : 1;  /* bit[2]    : Enable lane 2 module */
        unsigned int  phya_enable_3             : 1;  /* bit[3]    : Enable lane 3 module */
        unsigned int  phya_enableclk_0          : 1;  /* bit[4]    : Enable clock lane 0 module */
        unsigned int  phya_enableclk_1          : 1;  /* bit[5]    : Enable clock lane 1 module */
        unsigned int  phya_cdphy_rx_sel         : 1;  /* bit[6]    : select DPHY/CPHY mode
                                                                     0: DPHY mode
                                                                     1: CPHY mode */
        unsigned int  phya_lane1_clk_en         : 1;  /* bit[7]    : Indicate whether lane 1 as a clock lane. When active high means data lane3 is synchronized to clock lane 1.
                                                                     used for DPHY 1+2 mode only */
        unsigned int  phya_rxdatawidthhs_0_cphy : 2;  /* bit[8-9]  : High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phya_rxdatawidthhs_1_cphy : 2;  /* bit[10-11]: High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phya_rxdatawidthhs_2_cphy : 2;  /* bit[12-13]: High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phya_protocol_sel         : 1;  /* bit[14]   : Config interface sel
                                                                     0: test 
                                                                     1: apb */
        unsigned int  reserved_0                : 1;  /* bit[15]   : Reserved */
        unsigned int  phya_rxdatawidthhs_0_dphy : 2;  /* bit[16-17]: High-speed receive data width select, DPHY mode only
                                                                     00: 8-bit
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phya_rxdatawidthhs_1_dphy : 2;  /* bit[18-19]: High-speed receive data width select. Used by data lane 3 for DPHY 1+2 mode only
                                                                     00: 8-bit
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phya_vote_cnt             : 2;  /* bit[20-21]: Master num by software voting */
        unsigned int  reserved_1                : 10; /* bit[22-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_A_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_enable_0_START              (0)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_enable_0_END                (0)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_enable_1_START              (1)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_enable_1_END                (1)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_enable_2_START              (2)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_enable_2_END                (2)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_enable_3_START              (3)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_enable_3_END                (3)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_enableclk_0_START           (4)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_enableclk_0_END             (4)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_enableclk_1_START           (5)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_enableclk_1_END             (5)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_cdphy_rx_sel_START          (6)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_cdphy_rx_sel_END            (6)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_lane1_clk_en_START          (7)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_lane1_clk_en_END            (7)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_rxdatawidthhs_0_cphy_START  (8)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_rxdatawidthhs_0_cphy_END    (9)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_rxdatawidthhs_1_cphy_START  (10)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_rxdatawidthhs_1_cphy_END    (11)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_rxdatawidthhs_2_cphy_START  (12)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_rxdatawidthhs_2_cphy_END    (13)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_protocol_sel_START          (14)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_protocol_sel_END            (14)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_rxdatawidthhs_0_dphy_START  (16)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_rxdatawidthhs_0_dphy_END    (17)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_rxdatawidthhs_1_dphy_START  (18)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_rxdatawidthhs_1_dphy_END    (19)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_vote_cnt_START              (20)
#define SOC_CSI_WRAPPER_CDPHY_A_CTRL_phya_vote_cnt_END                (21)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_A_LOCK_CTRL_UNION
 struct description   : CDPHY_A_LOCK_CTRL Register structure definition
                        Address Offset:0xB10 Initial:0x00000000 Width:32
 register description : PHY lock  control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phya_lock_wr_vld : 1;  /* bit[0]   : write valid. When wr_vld asserted PHY can be changed to lock state */
        unsigned int  phya_lock_mst_id : 3;  /* bit[1-3] : indicate which master occupied PHY. Lock is only available when PHY is in unlock state  */
        unsigned int  reserved         : 28; /* bit[4-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_A_LOCK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_A_LOCK_CTRL_phya_lock_wr_vld_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_A_LOCK_CTRL_phya_lock_wr_vld_END    (0)
#define SOC_CSI_WRAPPER_CDPHY_A_LOCK_CTRL_phya_lock_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_A_LOCK_CTRL_phya_lock_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_A_UNLOCK_CTRL_UNION
 struct description   : CDPHY_A_UNLOCK_CTRL Register structure definition
                        Address Offset:0xB14 Initial:0x00000000 Width:32
 register description : PHY unlock  control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phya_unlock_wr_vld   : 1;  /* bit[0]   : write valid. When wr_vld asserted PHY can be change to unlock state */
        unsigned int  phya_unlocked_mst_id : 3;  /* bit[1-3] : unlocked_mst_indicator should be equal to previous master's indicator who locked PHY when unlock the PHY */
        unsigned int  reserved             : 28; /* bit[4-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_A_UNLOCK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_A_UNLOCK_CTRL_phya_unlock_wr_vld_START    (0)
#define SOC_CSI_WRAPPER_CDPHY_A_UNLOCK_CTRL_phya_unlock_wr_vld_END      (0)
#define SOC_CSI_WRAPPER_CDPHY_A_UNLOCK_CTRL_phya_unlocked_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_A_UNLOCK_CTRL_phya_unlocked_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_A_LOCK_STATE_UNION
 struct description   : CDPHY_A_LOCK_STATE Register structure definition
                        Address Offset:0xB18 Initial:0x00000000 Width:32
 register description : PHY lock state
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phya_lock_status   : 1;  /* bit[0]   : PHY lock state.
                                                             1'b0: unlock
                                                             1'b1: lock */
        unsigned int  phya_locked_mst_id : 3;  /* bit[1-3] : which master occupied PHY now */
        unsigned int  reserved           : 28; /* bit[4-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_A_LOCK_STATE_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_A_LOCK_STATE_phya_lock_status_START    (0)
#define SOC_CSI_WRAPPER_CDPHY_A_LOCK_STATE_phya_lock_status_END      (0)
#define SOC_CSI_WRAPPER_CDPHY_A_LOCK_STATE_phya_locked_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_A_LOCK_STATE_phya_locked_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_A_DBG_UNION
 struct description   : CDPHY_A_DBG Register structure definition
                        Address Offset:0xB1C Initial:0x00000000 Width:32
 register description : Dbg_out.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phya_rx_dbg_out  : 24; /* bit[0-23] :  */
        unsigned int  phya_clk_dbg_cnt : 8;  /* bit[24-31]: This used for phya cfg clock calculation.
                                                            Phy_cfg_clk = apb_clk * 16/phy_clk_dbg_cnt
                                                            apb_clk is the configuration clock for CSI WRAPPER */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_A_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_A_DBG_phya_rx_dbg_out_START   (0)
#define SOC_CSI_WRAPPER_CDPHY_A_DBG_phya_rx_dbg_out_END     (23)
#define SOC_CSI_WRAPPER_CDPHY_A_DBG_phya_clk_dbg_cnt_START  (24)
#define SOC_CSI_WRAPPER_CDPHY_A_DBG_phya_clk_dbg_cnt_END    (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_A_CLKRST_UNION
 struct description   : CDPHY_A_CLKRST Register structure definition
                        Address Offset:0xB20 Initial:0x00000001 Width:32
 register description : PHY clk gate and soft rst
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  soft_rst_phya : 1;  /* bit[0]   : Software reset control for PHY, set to 1 to reset  */
        unsigned int  cg_phya       : 1;  /* bit[1]   : clock gate control for PHY, clock is gated when set to 0 */
        unsigned int  reserved      : 30; /* bit[2-31]:  */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_A_CLKRST_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_A_CLKRST_soft_rst_phya_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_A_CLKRST_soft_rst_phya_END    (0)
#define SOC_CSI_WRAPPER_CDPHY_A_CLKRST_cg_phya_START        (1)
#define SOC_CSI_WRAPPER_CDPHY_A_CLKRST_cg_phya_END          (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_UNION
 struct description   : CDPHY_B_TEST_CTRL Register structure definition
                        Address Offset:0xB40 Initial:0x00000800 Width:32
 register description : PHY Test interface control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyb_testdin : 10; /* bit[0-9]  : PHY test interface input 10-bit data bus for internal register programming and test functionalities access. */
        unsigned int  phyb_testen  : 1;  /* bit[10]   : PHY test interface operation selector:
                                                        - 1: Configures address write operation on the falling edge of TESTCLK
                                                        - 0: Configures a data write operation on the rising edge of TESTCLK. */
        unsigned int  phyb_testclr : 1;  /* bit[11]   : PHY test interface clear
                                                        It is used when active performs vendor specific interface initialization, Active High. */
        unsigned int  phyb_testclk : 1;  /* bit[12]   : test interface strobe signal
                                                        It is used to clock TESTDIN bus into the PHY. In conjunction with TESTEN signal controls the operation selection. */
        unsigned int  reserved     : 3;  /* bit[13-15]:  */
        unsigned int  bitmasken    : 16; /* bit[16-31]: reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_phyb_testdin_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_phyb_testdin_END    (9)
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_phyb_testen_START   (10)
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_phyb_testen_END     (10)
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_phyb_testclr_START  (11)
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_phyb_testclr_END    (11)
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_phyb_testclk_START  (12)
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_phyb_testclk_END    (12)
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_bitmasken_START     (16)
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_CTRL_bitmasken_END       (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_B_TEST_DOUT_UNION
 struct description   : CDPHY_B_TEST_DOUT Register structure definition
                        Address Offset:0xB44 Initial:0x00000000 Width:32
 register description : PHY Test interface dout
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyb_testdout : 10; /* bit[0-9]  : PHY output 10-bit data bus for read-back and internal probing functionalities. */
        unsigned int  reserved      : 22; /* bit[10-31]:  */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_B_TEST_DOUT_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_DOUT_phyb_testdout_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_B_TEST_DOUT_phyb_testdout_END    (9)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_B_SHUTDOWN_RST_CTRL_UNION
 struct description   : CDPHY_B_SHUTDOWN_RST_CTRL Register structure definition
                        Address Offset:0xB48 Initial:0x00000000 Width:32
 register description : PHY reset control.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyb_rstz      : 1;  /* bit[0]   : PHY reset output. Active Low. */
        unsigned int  phyb_shutdownz : 1;  /* bit[1]   : Shutdown input
                                                         This line is used to place the complete macro in power down. All
                                                         analog blocks are in power down mode and digital logic is cleared.
                                                         Active Low. */
        unsigned int  reserved       : 30; /* bit[2-31]: reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_B_SHUTDOWN_RST_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_B_SHUTDOWN_RST_CTRL_phyb_rstz_START       (0)
#define SOC_CSI_WRAPPER_CDPHY_B_SHUTDOWN_RST_CTRL_phyb_rstz_END         (0)
#define SOC_CSI_WRAPPER_CDPHY_B_SHUTDOWN_RST_CTRL_phyb_shutdownz_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_B_SHUTDOWN_RST_CTRL_phyb_shutdownz_END    (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_B_CTRL_UNION
 struct description   : CDPHY_B_CTRL Register structure definition
                        Address Offset:0xB4C Initial:0x00000000 Width:32
 register description : PHY mode and enable control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyb_enable_0             : 1;  /* bit[0]    : Enable lane 0 module */
        unsigned int  phyb_enable_1             : 1;  /* bit[1]    : Enable lane 1 module */
        unsigned int  phyb_enable_2             : 1;  /* bit[2]    : Enable lane 2 module */
        unsigned int  phyb_enable_3             : 1;  /* bit[3]    : Enable lane 3 module */
        unsigned int  phyb_enableclk_0          : 1;  /* bit[4]    : Enable clock lane 0 module */
        unsigned int  phyb_enableclk_1          : 1;  /* bit[5]    : Enable clock lane 1 module */
        unsigned int  phyb_cdphy_rx_sel         : 1;  /* bit[6]    : select DPHY/CPHY mode
                                                                     0: DPHY mode
                                                                     1: CPHY mode */
        unsigned int  phyb_lane1_clk_en         : 1;  /* bit[7]    : Indicate whether lane 1 as a clock lane. When active high means data lane3 is synchronized to clock lane 1.
                                                                     used for DPHY 1+2 mode only */
        unsigned int  phyb_rxdatawidthhs_0_cphy : 2;  /* bit[8-9]  : High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyb_rxdatawidthhs_1_cphy : 2;  /* bit[10-11]: High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyb_rxdatawidthhs_2_cphy : 2;  /* bit[12-13]: High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyb_protocol_sel         : 1;  /* bit[14]   : Config interface sel
                                                                     0: test 
                                                                     1: apb */
        unsigned int  reserved_0                : 1;  /* bit[15]   : Reserved */
        unsigned int  phyb_rxdatawidthhs_0_dphy : 2;  /* bit[16-17]: High-speed receive data width select, DPHY mode only
                                                                     00: 8-bit
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyb_rxdatawidthhs_1_dphy : 2;  /* bit[18-19]: High-speed receive data width select. Used by data lane 3 for DPHY 1+2 mode only
                                                                     00: 8-bit
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyb_vote_cnt             : 2;  /* bit[20-21]: Master num by software voting */
        unsigned int  reserved_1                : 10; /* bit[22-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_B_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_enable_0_START              (0)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_enable_0_END                (0)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_enable_1_START              (1)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_enable_1_END                (1)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_enable_2_START              (2)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_enable_2_END                (2)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_enable_3_START              (3)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_enable_3_END                (3)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_enableclk_0_START           (4)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_enableclk_0_END             (4)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_enableclk_1_START           (5)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_enableclk_1_END             (5)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_cdphy_rx_sel_START          (6)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_cdphy_rx_sel_END            (6)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_lane1_clk_en_START          (7)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_lane1_clk_en_END            (7)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_rxdatawidthhs_0_cphy_START  (8)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_rxdatawidthhs_0_cphy_END    (9)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_rxdatawidthhs_1_cphy_START  (10)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_rxdatawidthhs_1_cphy_END    (11)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_rxdatawidthhs_2_cphy_START  (12)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_rxdatawidthhs_2_cphy_END    (13)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_protocol_sel_START          (14)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_protocol_sel_END            (14)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_rxdatawidthhs_0_dphy_START  (16)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_rxdatawidthhs_0_dphy_END    (17)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_rxdatawidthhs_1_dphy_START  (18)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_rxdatawidthhs_1_dphy_END    (19)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_vote_cnt_START              (20)
#define SOC_CSI_WRAPPER_CDPHY_B_CTRL_phyb_vote_cnt_END                (21)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_B_LOCK_CTRL_UNION
 struct description   : CDPHY_B_LOCK_CTRL Register structure definition
                        Address Offset:0xB50 Initial:0x00000000 Width:32
 register description : PHY lock  control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyb_lock_wr_vld : 1;  /* bit[0]   : write valid. When wr_vld asserted PHY can be changed to lock state */
        unsigned int  phyb_lock_mst_id : 3;  /* bit[1-3] : indicate which master occupied PHY. Lock is only available when PHY is in unlock state  */
        unsigned int  reserved         : 28; /* bit[4-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_B_LOCK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_B_LOCK_CTRL_phyb_lock_wr_vld_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_B_LOCK_CTRL_phyb_lock_wr_vld_END    (0)
#define SOC_CSI_WRAPPER_CDPHY_B_LOCK_CTRL_phyb_lock_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_B_LOCK_CTRL_phyb_lock_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_B_UNLOCK_CTRL_UNION
 struct description   : CDPHY_B_UNLOCK_CTRL Register structure definition
                        Address Offset:0xB54 Initial:0x00000000 Width:32
 register description : PHY unlock  control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyb_unlock_wr_vld   : 1;  /* bit[0]   : write valid. When wr_vld asserted PHY can be change to unlock state */
        unsigned int  phyb_unlocked_mst_id : 3;  /* bit[1-3] : unlocked_mst_indicator should be equal to previous master's indicator who locked PHY when unlock the PHY */
        unsigned int  reserved             : 28; /* bit[4-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_B_UNLOCK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_B_UNLOCK_CTRL_phyb_unlock_wr_vld_START    (0)
#define SOC_CSI_WRAPPER_CDPHY_B_UNLOCK_CTRL_phyb_unlock_wr_vld_END      (0)
#define SOC_CSI_WRAPPER_CDPHY_B_UNLOCK_CTRL_phyb_unlocked_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_B_UNLOCK_CTRL_phyb_unlocked_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_B_LOCK_STATE_UNION
 struct description   : CDPHY_B_LOCK_STATE Register structure definition
                        Address Offset:0xB58 Initial:0x00000000 Width:32
 register description : PHY lock state
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyb_lock_status   : 1;  /* bit[0]   : PHY lock state.
                                                             1'b0: unlock
                                                             1'b1: lock */
        unsigned int  phyb_locked_mst_id : 3;  /* bit[1-3] : which master occupied PHY now */
        unsigned int  reserved           : 28; /* bit[4-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_B_LOCK_STATE_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_B_LOCK_STATE_phyb_lock_status_START    (0)
#define SOC_CSI_WRAPPER_CDPHY_B_LOCK_STATE_phyb_lock_status_END      (0)
#define SOC_CSI_WRAPPER_CDPHY_B_LOCK_STATE_phyb_locked_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_B_LOCK_STATE_phyb_locked_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_B_DBG_UNION
 struct description   : CDPHY_B_DBG Register structure definition
                        Address Offset:0xB5C Initial:0x00000000 Width:32
 register description : Dbg_out.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyb_rx_dbg_out  : 24; /* bit[0-23] :  */
        unsigned int  phyb_clk_dbg_cnt : 8;  /* bit[24-31]: This used for phyb cfg clock calculation.
                                                            Phy_cfg_clk = apb_clk * 16/phy_clk_dbg_cnt
                                                            apb_clk is the configuration clock for CSI WRAPPER */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_B_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_B_DBG_phyb_rx_dbg_out_START   (0)
#define SOC_CSI_WRAPPER_CDPHY_B_DBG_phyb_rx_dbg_out_END     (23)
#define SOC_CSI_WRAPPER_CDPHY_B_DBG_phyb_clk_dbg_cnt_START  (24)
#define SOC_CSI_WRAPPER_CDPHY_B_DBG_phyb_clk_dbg_cnt_END    (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_B_CLKRST_UNION
 struct description   : CDPHY_B_CLKRST Register structure definition
                        Address Offset:0xB60 Initial:0x00000001 Width:32
 register description : PHY clk gate and soft rst
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  soft_rst_phyb : 1;  /* bit[0]   : Software reset control for PHY, set to 1 to reset  */
        unsigned int  cg_phyb       : 1;  /* bit[1]   : clock gate control for PHY, clock is gated when set to 0 */
        unsigned int  reserved      : 30; /* bit[2-31]:  */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_B_CLKRST_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_B_CLKRST_soft_rst_phyb_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_B_CLKRST_soft_rst_phyb_END    (0)
#define SOC_CSI_WRAPPER_CDPHY_B_CLKRST_cg_phyb_START        (1)
#define SOC_CSI_WRAPPER_CDPHY_B_CLKRST_cg_phyb_END          (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_UNION
 struct description   : CDPHY_C_TEST_CTRL Register structure definition
                        Address Offset:0xB80 Initial:0x00000800 Width:32
 register description : PHY Test interface control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyc_testdin : 10; /* bit[0-9]  : PHY test interface input 10-bit data bus for internal register programming and test functionalities access. */
        unsigned int  phyc_testen  : 1;  /* bit[10]   : PHY test interface operation selector:
                                                        - 1: Configures address write operation on the falling edge of TESTCLK
                                                        - 0: Configures a data write operation on the rising edge of TESTCLK. */
        unsigned int  phyc_testclr : 1;  /* bit[11]   : PHY test interface clear
                                                        It is used when active performs vendor specific interface initialization, Active High. */
        unsigned int  phyc_testclk : 1;  /* bit[12]   : test interface strobe signal
                                                        It is used to clock TESTDIN bus into the PHY. In conjunction with TESTEN signal controls the operation selection. */
        unsigned int  reserved     : 3;  /* bit[13-15]:  */
        unsigned int  bitmasken    : 16; /* bit[16-31]: reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_phyc_testdin_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_phyc_testdin_END    (9)
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_phyc_testen_START   (10)
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_phyc_testen_END     (10)
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_phyc_testclr_START  (11)
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_phyc_testclr_END    (11)
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_phyc_testclk_START  (12)
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_phyc_testclk_END    (12)
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_bitmasken_START     (16)
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_CTRL_bitmasken_END       (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_C_TEST_DOUT_UNION
 struct description   : CDPHY_C_TEST_DOUT Register structure definition
                        Address Offset:0xB84 Initial:0x00000000 Width:32
 register description : PHY Test interface dout
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyc_testdout : 10; /* bit[0-9]  : PHY output 10-bit data bus for read-back and internal probing functionalities. */
        unsigned int  reserved      : 22; /* bit[10-31]:  */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_C_TEST_DOUT_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_DOUT_phyc_testdout_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_C_TEST_DOUT_phyc_testdout_END    (9)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_C_SHUTDOWN_RST_CTRL_UNION
 struct description   : CDPHY_C_SHUTDOWN_RST_CTRL Register structure definition
                        Address Offset:0xB88 Initial:0x00000000 Width:32
 register description : PHY reset control.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyc_rstz      : 1;  /* bit[0]   : PHY reset output. Active Low. */
        unsigned int  phyc_shutdownz : 1;  /* bit[1]   : Shutdown input
                                                         This line is used to place the complete macro in power down. All
                                                         analog blocks are in power down mode and digital logic is cleared.
                                                         Active Low. */
        unsigned int  reserved       : 30; /* bit[2-31]: reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_C_SHUTDOWN_RST_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_C_SHUTDOWN_RST_CTRL_phyc_rstz_START       (0)
#define SOC_CSI_WRAPPER_CDPHY_C_SHUTDOWN_RST_CTRL_phyc_rstz_END         (0)
#define SOC_CSI_WRAPPER_CDPHY_C_SHUTDOWN_RST_CTRL_phyc_shutdownz_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_C_SHUTDOWN_RST_CTRL_phyc_shutdownz_END    (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_C_CTRL_UNION
 struct description   : CDPHY_C_CTRL Register structure definition
                        Address Offset:0xB8C Initial:0x00000000 Width:32
 register description : PHY mode and enable control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyc_enable_0             : 1;  /* bit[0]    : Enable lane 0 module */
        unsigned int  phyc_enable_1             : 1;  /* bit[1]    : Enable lane 1 module */
        unsigned int  phyc_enable_2             : 1;  /* bit[2]    : Enable lane 2 module */
        unsigned int  phyc_enable_3             : 1;  /* bit[3]    : Enable lane 3 module */
        unsigned int  phyc_enableclk_0          : 1;  /* bit[4]    : Enable clock lane 0 module */
        unsigned int  phyc_enableclk_1          : 1;  /* bit[5]    : Enable clock lane 1 module */
        unsigned int  phyc_cdphy_rx_sel         : 1;  /* bit[6]    : select DPHY/CPHY mode
                                                                     0: DPHY mode
                                                                     1: CPHY mode */
        unsigned int  phyc_lane1_clk_en         : 1;  /* bit[7]    : Indicate whether lane 1 as a clock lane. When active high means data lane3 is synchronized to clock lane 1.
                                                                     used for DPHY 1+2 mode only */
        unsigned int  phyc_rxdatawidthhs_0_cphy : 2;  /* bit[8-9]  : High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyc_rxdatawidthhs_1_cphy : 2;  /* bit[10-11]: High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyc_rxdatawidthhs_2_cphy : 2;  /* bit[12-13]: High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyc_protocol_sel         : 1;  /* bit[14]   : Config interface sel
                                                                     0: test 
                                                                     1: apb */
        unsigned int  reserved_0                : 1;  /* bit[15]   : Reserved */
        unsigned int  phyc_rxdatawidthhs_0_dphy : 2;  /* bit[16-17]: High-speed receive data width select, DPHY mode only
                                                                     00: 8-bit
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyc_rxdatawidthhs_1_dphy : 2;  /* bit[18-19]: High-speed receive data width select. Used by data lane 3 for DPHY 1+2 mode only
                                                                     00: 8-bit
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyc_vote_cnt             : 2;  /* bit[20-21]: Master num by software voting */
        unsigned int  reserved_1                : 10; /* bit[22-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_C_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_enable_0_START              (0)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_enable_0_END                (0)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_enable_1_START              (1)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_enable_1_END                (1)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_enable_2_START              (2)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_enable_2_END                (2)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_enable_3_START              (3)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_enable_3_END                (3)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_enableclk_0_START           (4)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_enableclk_0_END             (4)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_enableclk_1_START           (5)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_enableclk_1_END             (5)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_cdphy_rx_sel_START          (6)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_cdphy_rx_sel_END            (6)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_lane1_clk_en_START          (7)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_lane1_clk_en_END            (7)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_rxdatawidthhs_0_cphy_START  (8)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_rxdatawidthhs_0_cphy_END    (9)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_rxdatawidthhs_1_cphy_START  (10)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_rxdatawidthhs_1_cphy_END    (11)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_rxdatawidthhs_2_cphy_START  (12)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_rxdatawidthhs_2_cphy_END    (13)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_protocol_sel_START          (14)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_protocol_sel_END            (14)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_rxdatawidthhs_0_dphy_START  (16)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_rxdatawidthhs_0_dphy_END    (17)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_rxdatawidthhs_1_dphy_START  (18)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_rxdatawidthhs_1_dphy_END    (19)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_vote_cnt_START              (20)
#define SOC_CSI_WRAPPER_CDPHY_C_CTRL_phyc_vote_cnt_END                (21)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_C_LOCK_CTRL_UNION
 struct description   : CDPHY_C_LOCK_CTRL Register structure definition
                        Address Offset:0xB90 Initial:0x00000000 Width:32
 register description : PHY lock  control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyc_lock_wr_vld : 1;  /* bit[0]   : write valid. When wr_vld asserted PHY can be changed to lock state */
        unsigned int  phyc_lock_mst_id : 3;  /* bit[1-3] : indicate which master occupied PHY. Lock is only available when PHY is in unlock state  */
        unsigned int  reserved         : 28; /* bit[4-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_C_LOCK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_C_LOCK_CTRL_phyc_lock_wr_vld_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_C_LOCK_CTRL_phyc_lock_wr_vld_END    (0)
#define SOC_CSI_WRAPPER_CDPHY_C_LOCK_CTRL_phyc_lock_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_C_LOCK_CTRL_phyc_lock_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_C_UNLOCK_CTRL_UNION
 struct description   : CDPHY_C_UNLOCK_CTRL Register structure definition
                        Address Offset:0xB94 Initial:0x00000000 Width:32
 register description : PHY unlock  control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyc_unlock_wr_vld   : 1;  /* bit[0]   : write valid. When wr_vld asserted PHY can be change to unlock state */
        unsigned int  phyc_unlocked_mst_id : 3;  /* bit[1-3] : unlocked_mst_indicator should be equal to previous master's indicator who locked PHY when unlock the PHY */
        unsigned int  reserved             : 28; /* bit[4-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_C_UNLOCK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_C_UNLOCK_CTRL_phyc_unlock_wr_vld_START    (0)
#define SOC_CSI_WRAPPER_CDPHY_C_UNLOCK_CTRL_phyc_unlock_wr_vld_END      (0)
#define SOC_CSI_WRAPPER_CDPHY_C_UNLOCK_CTRL_phyc_unlocked_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_C_UNLOCK_CTRL_phyc_unlocked_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_C_LOCK_STATE_UNION
 struct description   : CDPHY_C_LOCK_STATE Register structure definition
                        Address Offset:0xB98 Initial:0x00000000 Width:32
 register description : PHY lock state
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyc_lock_status   : 1;  /* bit[0]   : PHY lock state.
                                                             1'b0: unlock
                                                             1'b1: lock */
        unsigned int  phyc_locked_mst_id : 3;  /* bit[1-3] : which master occupied PHY now */
        unsigned int  reserved           : 28; /* bit[4-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_C_LOCK_STATE_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_C_LOCK_STATE_phyc_lock_status_START    (0)
#define SOC_CSI_WRAPPER_CDPHY_C_LOCK_STATE_phyc_lock_status_END      (0)
#define SOC_CSI_WRAPPER_CDPHY_C_LOCK_STATE_phyc_locked_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_C_LOCK_STATE_phyc_locked_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_C_DBG_UNION
 struct description   : CDPHY_C_DBG Register structure definition
                        Address Offset:0xB9C Initial:0x00000000 Width:32
 register description : Dbg_out.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyc_rx_dbg_out  : 24; /* bit[0-23] :  */
        unsigned int  phyc_clk_dbg_cnt : 8;  /* bit[24-31]: This used for phyc cfg clock calculation.
                                                            Phy_cfg_clk = apb_clk * 16/phy_clk_dbg_cnt
                                                            apb_clk is the configuration clock for CSI WRAPPER */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_C_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_C_DBG_phyc_rx_dbg_out_START   (0)
#define SOC_CSI_WRAPPER_CDPHY_C_DBG_phyc_rx_dbg_out_END     (23)
#define SOC_CSI_WRAPPER_CDPHY_C_DBG_phyc_clk_dbg_cnt_START  (24)
#define SOC_CSI_WRAPPER_CDPHY_C_DBG_phyc_clk_dbg_cnt_END    (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_C_CLKRST_UNION
 struct description   : CDPHY_C_CLKRST Register structure definition
                        Address Offset:0xBA0 Initial:0x00000001 Width:32
 register description : PHY clk gate and soft rst
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  soft_rst_phyc : 1;  /* bit[0]   : Software reset control for PHY, set to 1 to reset  */
        unsigned int  cg_phyc       : 1;  /* bit[1]   : clock gate control for PHY, clock is gated when set to 0 */
        unsigned int  reserved      : 30; /* bit[2-31]:  */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_C_CLKRST_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_C_CLKRST_soft_rst_phyc_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_C_CLKRST_soft_rst_phyc_END    (0)
#define SOC_CSI_WRAPPER_CDPHY_C_CLKRST_cg_phyc_START        (1)
#define SOC_CSI_WRAPPER_CDPHY_C_CLKRST_cg_phyc_END          (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_UNION
 struct description   : CDPHY_D_TEST_CTRL Register structure definition
                        Address Offset:0xBC0 Initial:0x00000800 Width:32
 register description : PHY Test interface control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyd_testdin : 10; /* bit[0-9]  : PHY test interface input 10-bit data bus for internal register programming and test functionalities access. */
        unsigned int  phyd_testen  : 1;  /* bit[10]   : PHY test interface operation selector:
                                                        - 1: Configures address write operation on the falling edge of TESTCLK
                                                        - 0: Configures a data write operation on the rising edge of TESTCLK. */
        unsigned int  phyd_testclr : 1;  /* bit[11]   : PHY test interface clear
                                                        It is used when active performs vendor specific interface initialization, Active High. */
        unsigned int  phyd_testclk : 1;  /* bit[12]   : test interface strobe signal
                                                        It is used to clock TESTDIN bus into the PHY. In conjunction with TESTEN signal controls the operation selection. */
        unsigned int  reserved     : 3;  /* bit[13-15]:  */
        unsigned int  bitmasken    : 16; /* bit[16-31]: PHYD DUMMY
                                                        reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_phyd_testdin_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_phyd_testdin_END    (9)
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_phyd_testen_START   (10)
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_phyd_testen_END     (10)
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_phyd_testclr_START  (11)
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_phyd_testclr_END    (11)
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_phyd_testclk_START  (12)
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_phyd_testclk_END    (12)
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_bitmasken_START     (16)
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_CTRL_bitmasken_END       (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_D_TEST_DOUT_UNION
 struct description   : CDPHY_D_TEST_DOUT Register structure definition
                        Address Offset:0xBC4 Initial:0x00000000 Width:32
 register description : PHY Test interface dout
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyd_testdout : 10; /* bit[0-9]  : PHY output 10-bit data bus for read-back and internal probing functionalities. */
        unsigned int  reserved      : 22; /* bit[10-31]: PHYD DUMMY
                                                         reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_D_TEST_DOUT_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_DOUT_phyd_testdout_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_D_TEST_DOUT_phyd_testdout_END    (9)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_D_SHUTDOWN_RST_CTRL_UNION
 struct description   : CDPHY_D_SHUTDOWN_RST_CTRL Register structure definition
                        Address Offset:0xBC8 Initial:0x00000000 Width:32
 register description : PHY reset control.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyd_rstz      : 1;  /* bit[0]   : PHY reset output. Active Low. */
        unsigned int  phyd_shutdownz : 1;  /* bit[1]   : Shutdown input
                                                         This line is used to place the complete macro in power down. All
                                                         analog blocks are in power down mode and digital logic is cleared.
                                                         Active Low. */
        unsigned int  reserved       : 30; /* bit[2-31]: PHYD DUMMY
                                                         reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_D_SHUTDOWN_RST_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_D_SHUTDOWN_RST_CTRL_phyd_rstz_START       (0)
#define SOC_CSI_WRAPPER_CDPHY_D_SHUTDOWN_RST_CTRL_phyd_rstz_END         (0)
#define SOC_CSI_WRAPPER_CDPHY_D_SHUTDOWN_RST_CTRL_phyd_shutdownz_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_D_SHUTDOWN_RST_CTRL_phyd_shutdownz_END    (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_D_CTRL_UNION
 struct description   : CDPHY_D_CTRL Register structure definition
                        Address Offset:0xBCC Initial:0x00000000 Width:32
 register description : PHY mode and enable control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyd_enable_0             : 1;  /* bit[0]    : Enable lane 0 module */
        unsigned int  phyd_enable_1             : 1;  /* bit[1]    : Enable lane 1 module */
        unsigned int  phyd_enable_2             : 1;  /* bit[2]    : Enable lane 2 module */
        unsigned int  phyd_enable_3             : 1;  /* bit[3]    : Enable lane 3 module */
        unsigned int  phyd_enableclk_0          : 1;  /* bit[4]    : Enable clock lane 0 module */
        unsigned int  phyd_enableclk_1          : 1;  /* bit[5]    : Enable clock lane 1 module */
        unsigned int  phyd_cdphy_rx_sel         : 1;  /* bit[6]    : select DPHY/CPHY mode
                                                                     0: DPHY mode
                                                                     1: CPHY mode */
        unsigned int  phyd_lane1_clk_en         : 1;  /* bit[7]    : Indicate whether lane 1 as a clock lane. When active high means data lane3 is synchronized to clock lane 1.
                                                                     used for DPHY 1+2 mode only */
        unsigned int  phyd_rxdatawidthhs_0_cphy : 2;  /* bit[8-9]  : High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyd_rxdatawidthhs_1_cphy : 2;  /* bit[10-11]: High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyd_rxdatawidthhs_2_cphy : 2;  /* bit[12-13]: High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyd_protocol_sel         : 1;  /* bit[14]   : Config interface sel
                                                                     0: test 
                                                                     1: apb */
        unsigned int  reserved_0                : 1;  /* bit[15]   : Reserved */
        unsigned int  phyd_rxdatawidthhs_0_dphy : 2;  /* bit[16-17]: High-speed receive data width select, DPHY mode only
                                                                     00: 8-bit
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyd_rxdatawidthhs_1_dphy : 2;  /* bit[18-19]: High-speed receive data width select. Used by data lane 3 for DPHY 1+2 mode only
                                                                     00: 8-bit
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyd_vote_cnt             : 2;  /* bit[20-21]: Master num by software voting */
        unsigned int  reserved_1                : 10; /* bit[22-31]: PHYD DUMMY
                                                                     reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_D_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_enable_0_START              (0)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_enable_0_END                (0)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_enable_1_START              (1)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_enable_1_END                (1)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_enable_2_START              (2)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_enable_2_END                (2)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_enable_3_START              (3)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_enable_3_END                (3)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_enableclk_0_START           (4)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_enableclk_0_END             (4)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_enableclk_1_START           (5)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_enableclk_1_END             (5)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_cdphy_rx_sel_START          (6)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_cdphy_rx_sel_END            (6)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_lane1_clk_en_START          (7)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_lane1_clk_en_END            (7)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_rxdatawidthhs_0_cphy_START  (8)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_rxdatawidthhs_0_cphy_END    (9)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_rxdatawidthhs_1_cphy_START  (10)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_rxdatawidthhs_1_cphy_END    (11)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_rxdatawidthhs_2_cphy_START  (12)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_rxdatawidthhs_2_cphy_END    (13)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_protocol_sel_START          (14)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_protocol_sel_END            (14)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_rxdatawidthhs_0_dphy_START  (16)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_rxdatawidthhs_0_dphy_END    (17)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_rxdatawidthhs_1_dphy_START  (18)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_rxdatawidthhs_1_dphy_END    (19)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_vote_cnt_START              (20)
#define SOC_CSI_WRAPPER_CDPHY_D_CTRL_phyd_vote_cnt_END                (21)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_D_LOCK_CTRL_UNION
 struct description   : CDPHY_D_LOCK_CTRL Register structure definition
                        Address Offset:0xBD0 Initial:0x00000000 Width:32
 register description : PHY lock  control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyd_lock_wr_vld : 1;  /* bit[0]   : write valid. When wr_vld asserted PHY can be changed to lock state */
        unsigned int  phyd_lock_mst_id : 3;  /* bit[1-3] : indicate which master occupied PHY. Lock is only available when PHY is in unlock state  */
        unsigned int  reserved         : 28; /* bit[4-31]: PHYD DUMMY
                                                           reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_D_LOCK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_D_LOCK_CTRL_phyd_lock_wr_vld_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_D_LOCK_CTRL_phyd_lock_wr_vld_END    (0)
#define SOC_CSI_WRAPPER_CDPHY_D_LOCK_CTRL_phyd_lock_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_D_LOCK_CTRL_phyd_lock_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_D_UNLOCK_CTRL_UNION
 struct description   : CDPHY_D_UNLOCK_CTRL Register structure definition
                        Address Offset:0xBD4 Initial:0x00000000 Width:32
 register description : PHY unlock  control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyd_unlock_wr_vld   : 1;  /* bit[0]   : write valid. When wr_vld asserted PHY can be change to unlock state */
        unsigned int  phyd_unlocked_mst_id : 3;  /* bit[1-3] : unlocked_mst_indicator should be equal to previous master's indicator who locked PHY when unlock the PHY */
        unsigned int  reserved             : 28; /* bit[4-31]: PHYD DUMMY
                                                               reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_D_UNLOCK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_D_UNLOCK_CTRL_phyd_unlock_wr_vld_START    (0)
#define SOC_CSI_WRAPPER_CDPHY_D_UNLOCK_CTRL_phyd_unlock_wr_vld_END      (0)
#define SOC_CSI_WRAPPER_CDPHY_D_UNLOCK_CTRL_phyd_unlocked_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_D_UNLOCK_CTRL_phyd_unlocked_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_D_LOCK_STATE_UNION
 struct description   : CDPHY_D_LOCK_STATE Register structure definition
                        Address Offset:0xBD8 Initial:0x00000000 Width:32
 register description : PHY lock state
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyd_lock_status   : 1;  /* bit[0]   : PHY lock state.
                                                             1'b0: unlock
                                                             1'b1: lock */
        unsigned int  phyd_locked_mst_id : 3;  /* bit[1-3] : which master occupied PHY now */
        unsigned int  reserved           : 28; /* bit[4-31]: PHYD DUMMY
                                                             reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_D_LOCK_STATE_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_D_LOCK_STATE_phyd_lock_status_START    (0)
#define SOC_CSI_WRAPPER_CDPHY_D_LOCK_STATE_phyd_lock_status_END      (0)
#define SOC_CSI_WRAPPER_CDPHY_D_LOCK_STATE_phyd_locked_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_D_LOCK_STATE_phyd_locked_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_D_DBG_UNION
 struct description   : CDPHY_D_DBG Register structure definition
                        Address Offset:0xBDC Initial:0x00000000 Width:32
 register description : Dbg_out.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyd_rx_dbg_out  : 24; /* bit[0-23] : PHYD DUMMY */
        unsigned int  phyd_clk_dbg_cnt : 8;  /* bit[24-31]: PHYD DUMMY
                                                            This used for phyd cfg clock calculation.
                                                            Phy_cfg_clk = apb_clk * 16/phy_clk_dbg_cnt
                                                            apb_clk is the configuration clock for CSI WRAPPER */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_D_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_D_DBG_phyd_rx_dbg_out_START   (0)
#define SOC_CSI_WRAPPER_CDPHY_D_DBG_phyd_rx_dbg_out_END     (23)
#define SOC_CSI_WRAPPER_CDPHY_D_DBG_phyd_clk_dbg_cnt_START  (24)
#define SOC_CSI_WRAPPER_CDPHY_D_DBG_phyd_clk_dbg_cnt_END    (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_D_CLKRST_UNION
 struct description   : CDPHY_D_CLKRST Register structure definition
                        Address Offset:0xBE0 Initial:0x00000001 Width:32
 register description : PHY clk gate and soft rst
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  soft_rst_phyd : 1;  /* bit[0]   : Software reset control for PHY, set to 1 to reset  */
        unsigned int  cg_phyd       : 1;  /* bit[1]   : clock gate control for PHY, clock is gated when set to 0 */
        unsigned int  reserved      : 30; /* bit[2-31]: PHYD DUMMY
                                                        reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_D_CLKRST_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_D_CLKRST_soft_rst_phyd_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_D_CLKRST_soft_rst_phyd_END    (0)
#define SOC_CSI_WRAPPER_CDPHY_D_CLKRST_cg_phyd_START        (1)
#define SOC_CSI_WRAPPER_CDPHY_D_CLKRST_cg_phyd_END          (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_UNION
 struct description   : CDPHY_E_TEST_CTRL Register structure definition
                        Address Offset:0xC00 Initial:0x00000800 Width:32
 register description : PHY Test interface control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phye_testdin : 10; /* bit[0-9]  : PHY test interface input 10-bit data bus for internal register programming and test functionalities access. */
        unsigned int  phye_testen  : 1;  /* bit[10]   : PHY test interface operation selector:
                                                        - 1: Configures address write operation on the falling edge of TESTCLK
                                                        - 0: Configures a data write operation on the rising edge of TESTCLK. */
        unsigned int  phye_testclr : 1;  /* bit[11]   : PHY test interface clear
                                                        It is used when active performs vendor specific interface initialization, Active High. */
        unsigned int  phye_testclk : 1;  /* bit[12]   : test interface strobe signal
                                                        It is used to clock TESTDIN bus into the PHY. In conjunction with TESTEN signal controls the operation selection. */
        unsigned int  reserved     : 3;  /* bit[13-15]:  */
        unsigned int  bitmasken    : 16; /* bit[16-31]: reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_phye_testdin_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_phye_testdin_END    (9)
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_phye_testen_START   (10)
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_phye_testen_END     (10)
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_phye_testclr_START  (11)
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_phye_testclr_END    (11)
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_phye_testclk_START  (12)
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_phye_testclk_END    (12)
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_bitmasken_START     (16)
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_CTRL_bitmasken_END       (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_E_TEST_DOUT_UNION
 struct description   : CDPHY_E_TEST_DOUT Register structure definition
                        Address Offset:0xC04 Initial:0x00000000 Width:32
 register description : PHY Test interface dout
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phye_testdout : 10; /* bit[0-9]  : PHY output 10-bit data bus for read-back and internal probing functionalities. */
        unsigned int  reserved      : 22; /* bit[10-31]:  */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_E_TEST_DOUT_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_DOUT_phye_testdout_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_E_TEST_DOUT_phye_testdout_END    (9)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_E_SHUTDOWN_RST_CTRL_UNION
 struct description   : CDPHY_E_SHUTDOWN_RST_CTRL Register structure definition
                        Address Offset:0xC08 Initial:0x00000000 Width:32
 register description : PHY reset control.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phye_rstz      : 1;  /* bit[0]   : PHY reset output. Active Low. */
        unsigned int  phye_shutdownz : 1;  /* bit[1]   : Shutdown input
                                                         This line is used to place the complete macro in power down. All
                                                         analog blocks are in power down mode and digital logic is cleared.
                                                         Active Low. */
        unsigned int  reserved       : 30; /* bit[2-31]: reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_E_SHUTDOWN_RST_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_E_SHUTDOWN_RST_CTRL_phye_rstz_START       (0)
#define SOC_CSI_WRAPPER_CDPHY_E_SHUTDOWN_RST_CTRL_phye_rstz_END         (0)
#define SOC_CSI_WRAPPER_CDPHY_E_SHUTDOWN_RST_CTRL_phye_shutdownz_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_E_SHUTDOWN_RST_CTRL_phye_shutdownz_END    (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_E_CTRL_UNION
 struct description   : CDPHY_E_CTRL Register structure definition
                        Address Offset:0xC0C Initial:0x00000000 Width:32
 register description : PHY mode and enable control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phye_enable_0             : 1;  /* bit[0]    : Enable lane 0 module */
        unsigned int  phye_enable_1             : 1;  /* bit[1]    : Enable lane 1 module */
        unsigned int  phye_enable_2             : 1;  /* bit[2]    : Enable lane 2 module */
        unsigned int  phye_enable_3             : 1;  /* bit[3]    : Enable lane 3 module */
        unsigned int  phye_enableclk_0          : 1;  /* bit[4]    : Enable clock lane 0 module, DPHY mode only */
        unsigned int  phye_enableclk_1          : 1;  /* bit[5]    : Enable clock lane 1 module, DPHY mode only */
        unsigned int  phye_cdphy_rx_sel         : 1;  /* bit[6]    : select DPHY/CPHY mode
                                                                     0: DPHY mode
                                                                     1: CPHY mode */
        unsigned int  phye_lane1_clk_en         : 1;  /* bit[7]    : Indicate whether lane 1 as a clock lane. When active high means data lane3 is synchronized to clock lane 1.
                                                                     used for DPHY 1+2 mode only */
        unsigned int  phye_rxdatawidthhs_0_cphy : 2;  /* bit[8-9]  : High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phye_rxdatawidthhs_1_cphy : 2;  /* bit[10-11]: High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phye_rxdatawidthhs_2_cphy : 2;  /* bit[12-13]: High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phye_protocol_sel         : 1;  /* bit[14]   : Config interface sel
                                                                     0: test 
                                                                     1: apb */
        unsigned int  reserved_0                : 1;  /* bit[15]   : Reserved */
        unsigned int  phye_rxdatawidthhs_0_dphy : 2;  /* bit[16-17]: High-speed receive data width select, DPHY mode only
                                                                     00: 8-bit
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phye_rxdatawidthhs_1_dphy : 2;  /* bit[18-19]: High-speed receive data width select. Used by data lane 3 for DPHY 1+2 mode only
                                                                     00: 8-bit
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phye_vote_cnt             : 2;  /* bit[20-21]: Master num by software voting */
        unsigned int  reserved_1                : 10; /* bit[22-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_E_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_enable_0_START              (0)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_enable_0_END                (0)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_enable_1_START              (1)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_enable_1_END                (1)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_enable_2_START              (2)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_enable_2_END                (2)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_enable_3_START              (3)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_enable_3_END                (3)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_enableclk_0_START           (4)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_enableclk_0_END             (4)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_enableclk_1_START           (5)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_enableclk_1_END             (5)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_cdphy_rx_sel_START          (6)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_cdphy_rx_sel_END            (6)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_lane1_clk_en_START          (7)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_lane1_clk_en_END            (7)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_rxdatawidthhs_0_cphy_START  (8)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_rxdatawidthhs_0_cphy_END    (9)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_rxdatawidthhs_1_cphy_START  (10)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_rxdatawidthhs_1_cphy_END    (11)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_rxdatawidthhs_2_cphy_START  (12)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_rxdatawidthhs_2_cphy_END    (13)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_protocol_sel_START          (14)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_protocol_sel_END            (14)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_rxdatawidthhs_0_dphy_START  (16)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_rxdatawidthhs_0_dphy_END    (17)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_rxdatawidthhs_1_dphy_START  (18)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_rxdatawidthhs_1_dphy_END    (19)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_vote_cnt_START              (20)
#define SOC_CSI_WRAPPER_CDPHY_E_CTRL_phye_vote_cnt_END                (21)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_E_LOCK_CTRL_UNION
 struct description   : CDPHY_E_LOCK_CTRL Register structure definition
                        Address Offset:0xC10 Initial:0x00000000 Width:32
 register description : PHY lock  control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phye_lock_wr_vld : 1;  /* bit[0]   : write valid. When wr_vld asserted PHY can be changed to lock state */
        unsigned int  phye_lock_mst_id : 3;  /* bit[1-3] : indicate which master occupied PHY. Lock is only available when PHY is in unlock state  */
        unsigned int  reserved         : 28; /* bit[4-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_E_LOCK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_E_LOCK_CTRL_phye_lock_wr_vld_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_E_LOCK_CTRL_phye_lock_wr_vld_END    (0)
#define SOC_CSI_WRAPPER_CDPHY_E_LOCK_CTRL_phye_lock_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_E_LOCK_CTRL_phye_lock_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_E_UNLOCK_CTRL_UNION
 struct description   : CDPHY_E_UNLOCK_CTRL Register structure definition
                        Address Offset:0xC14 Initial:0x00000000 Width:32
 register description : PHY unlock  control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phye_unlock_wr_vld   : 1;  /* bit[0]   : write valid. When wr_vld asserted PHY can be change to unlock state */
        unsigned int  phye_unlocked_mst_id : 3;  /* bit[1-3] : unlocked_mst_indicator should be equal to previous master's indicator who locked PHY when unlock the PHY */
        unsigned int  reserved             : 28; /* bit[4-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_E_UNLOCK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_E_UNLOCK_CTRL_phye_unlock_wr_vld_START    (0)
#define SOC_CSI_WRAPPER_CDPHY_E_UNLOCK_CTRL_phye_unlock_wr_vld_END      (0)
#define SOC_CSI_WRAPPER_CDPHY_E_UNLOCK_CTRL_phye_unlocked_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_E_UNLOCK_CTRL_phye_unlocked_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_E_LOCK_STATE_UNION
 struct description   : CDPHY_E_LOCK_STATE Register structure definition
                        Address Offset:0xC18 Initial:0x00000000 Width:32
 register description : PHY lock state
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phye_lock_status   : 1;  /* bit[0]   : PHY lock state.
                                                             1'b0: unlock
                                                             1'b1: lock */
        unsigned int  phye_locked_mst_id : 3;  /* bit[1-3] : which master occupied PHY now */
        unsigned int  reserved           : 28; /* bit[4-31]: Reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_E_LOCK_STATE_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_E_LOCK_STATE_phye_lock_status_START    (0)
#define SOC_CSI_WRAPPER_CDPHY_E_LOCK_STATE_phye_lock_status_END      (0)
#define SOC_CSI_WRAPPER_CDPHY_E_LOCK_STATE_phye_locked_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_E_LOCK_STATE_phye_locked_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_E_DBG_UNION
 struct description   : CDPHY_E_DBG Register structure definition
                        Address Offset:0xC1C Initial:0x00000000 Width:32
 register description : Dbg_out.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phye_rx_dbg_out  : 24; /* bit[0-23] :  */
        unsigned int  phye_clk_dbg_cnt : 8;  /* bit[24-31]: This used for phyd cfg clock calculation.
                                                            Phy_cfg_clk = apb_clk * 16/phy_clk_dbg_cnt
                                                            apb_clk is the configuration clock for CSI WRAPPER */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_E_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_E_DBG_phye_rx_dbg_out_START   (0)
#define SOC_CSI_WRAPPER_CDPHY_E_DBG_phye_rx_dbg_out_END     (23)
#define SOC_CSI_WRAPPER_CDPHY_E_DBG_phye_clk_dbg_cnt_START  (24)
#define SOC_CSI_WRAPPER_CDPHY_E_DBG_phye_clk_dbg_cnt_END    (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_E_CLKRST_UNION
 struct description   : CDPHY_E_CLKRST Register structure definition
                        Address Offset:0xC20 Initial:0x00000001 Width:32
 register description : PHY clk gate and soft rst
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  soft_rst_phye : 1;  /* bit[0]   : Software reset control for PHY, set to 1 to reset  */
        unsigned int  cg_phye       : 1;  /* bit[1]   : clock gate control for PHY, clock is gated when set to 0 */
        unsigned int  reserved      : 30; /* bit[2-31]:  */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_E_CLKRST_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_E_CLKRST_soft_rst_phye_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_E_CLKRST_soft_rst_phye_END    (0)
#define SOC_CSI_WRAPPER_CDPHY_E_CLKRST_cg_phye_START        (1)
#define SOC_CSI_WRAPPER_CDPHY_E_CLKRST_cg_phye_END          (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_UNION
 struct description   : CDPHY_F_TEST_CTRL Register structure definition
                        Address Offset:0xC40 Initial:0x00000800 Width:32
 register description : PHY Test interface control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyf_testdin : 10; /* bit[0-9]  : PHY test interface input 10-bit data bus for internal register programming and test functionalities access. */
        unsigned int  phyf_testen  : 1;  /* bit[10]   : PHY test interface operation selector:
                                                        - 1: Configures address write operation on the falling edge of TESTCLK
                                                        - 0: Configures a data write operation on the rising edge of TESTCLK. */
        unsigned int  phyf_testclr : 1;  /* bit[11]   : PHY test interface clear
                                                        It is used when active performs vendor specific interface initialization, Active High. */
        unsigned int  phyf_testclk : 1;  /* bit[12]   : test interface strobe signal
                                                        It is used to clock TESTDIN bus into the PHY. In conjunction with TESTEN signal controls the operation selection. */
        unsigned int  reserved     : 3;  /* bit[13-15]:  */
        unsigned int  bitmasken    : 16; /* bit[16-31]: PHYF DUMMY
                                                        reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_phyf_testdin_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_phyf_testdin_END    (9)
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_phyf_testen_START   (10)
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_phyf_testen_END     (10)
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_phyf_testclr_START  (11)
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_phyf_testclr_END    (11)
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_phyf_testclk_START  (12)
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_phyf_testclk_END    (12)
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_bitmasken_START     (16)
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_CTRL_bitmasken_END       (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_F_TEST_DOUT_UNION
 struct description   : CDPHY_F_TEST_DOUT Register structure definition
                        Address Offset:0xC44 Initial:0x00000000 Width:32
 register description : PHY Test interface dout
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyf_testdout : 10; /* bit[0-9]  : PHY output 10-bit data bus for read-back and internal probing functionalities. */
        unsigned int  reserved      : 22; /* bit[10-31]: PHYF DUMMY
                                                         reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_F_TEST_DOUT_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_DOUT_phyf_testdout_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_F_TEST_DOUT_phyf_testdout_END    (9)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_F_SHUTDOWN_RST_CTRL_UNION
 struct description   : CDPHY_F_SHUTDOWN_RST_CTRL Register structure definition
                        Address Offset:0xC48 Initial:0x00000000 Width:32
 register description : PHY reset control.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyf_rstz      : 1;  /* bit[0]   : PHY reset output. Active Low. */
        unsigned int  phyf_shutdownz : 1;  /* bit[1]   : Shutdown input
                                                         This line is used to place the complete macro in power down. All
                                                         analog blocks are in power down mode and digital logic is cleared.
                                                         Active Low. */
        unsigned int  reserved       : 30; /* bit[2-31]: PHYF DUMMY
                                                         reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_F_SHUTDOWN_RST_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_F_SHUTDOWN_RST_CTRL_phyf_rstz_START       (0)
#define SOC_CSI_WRAPPER_CDPHY_F_SHUTDOWN_RST_CTRL_phyf_rstz_END         (0)
#define SOC_CSI_WRAPPER_CDPHY_F_SHUTDOWN_RST_CTRL_phyf_shutdownz_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_F_SHUTDOWN_RST_CTRL_phyf_shutdownz_END    (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_F_CTRL_UNION
 struct description   : CDPHY_F_CTRL Register structure definition
                        Address Offset:0xC4C Initial:0x00000000 Width:32
 register description : PHY mode and enable control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyf_enable_0             : 1;  /* bit[0]    : Enable lane 0 module */
        unsigned int  phyf_enable_1             : 1;  /* bit[1]    : Enable lane 1 module */
        unsigned int  phyf_enable_2             : 1;  /* bit[2]    : Enable lane 2 module */
        unsigned int  phyf_enable_3             : 1;  /* bit[3]    : Enable lane 3 module */
        unsigned int  phyf_enableclk_0          : 1;  /* bit[4]    : Enable clock lane 0 module */
        unsigned int  phyf_enableclk_1          : 1;  /* bit[5]    : Enable clock lane 1 module */
        unsigned int  phyf_cdphy_rx_sel         : 1;  /* bit[6]    : select DPHY/CPHY mode
                                                                     0: DPHY mode
                                                                     1: CPHY mode */
        unsigned int  phyf_lane1_clk_en         : 1;  /* bit[7]    : Indicate whether lane 1 as a clock lane. When active high means data lane3 is synchronized to clock lane 1.
                                                                     used for DPHY 1+2 mode only */
        unsigned int  phyf_rxdatawidthhs_0_cphy : 2;  /* bit[8-9]  : High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyf_rxdatawidthhs_1_cphy : 2;  /* bit[10-11]: High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyf_rxdatawidthhs_2_cphy : 2;  /* bit[12-13]: High-speed receive data width select, CPHY mode only
                                                                     00: not used, reserved
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyf_protocol_sel         : 1;  /* bit[14]   : Config interface sel
                                                                     0: test 
                                                                     1: apb */
        unsigned int  reserved_0                : 1;  /* bit[15]   : Reserved */
        unsigned int  phyf_rxdatawidthhs_0_dphy : 2;  /* bit[16-17]: High-speed receive data width select, DPHY mode only
                                                                     00: 8-bit
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyf_rxdatawidthhs_1_dphy : 2;  /* bit[18-19]: High-speed receive data width select. Used by data lane 3 for DPHY 1+2 mode only
                                                                     00: 8-bit
                                                                     01: 16-bit
                                                                     10: 32-bit
                                                                     11: not used, reserved */
        unsigned int  phyf_vote_cnt             : 2;  /* bit[20-21]: Master num by software voting */
        unsigned int  reserved_1                : 10; /* bit[22-31]: PHYF DUMMY
                                                                     reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_F_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_enable_0_START              (0)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_enable_0_END                (0)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_enable_1_START              (1)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_enable_1_END                (1)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_enable_2_START              (2)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_enable_2_END                (2)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_enable_3_START              (3)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_enable_3_END                (3)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_enableclk_0_START           (4)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_enableclk_0_END             (4)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_enableclk_1_START           (5)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_enableclk_1_END             (5)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_cdphy_rx_sel_START          (6)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_cdphy_rx_sel_END            (6)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_lane1_clk_en_START          (7)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_lane1_clk_en_END            (7)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_rxdatawidthhs_0_cphy_START  (8)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_rxdatawidthhs_0_cphy_END    (9)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_rxdatawidthhs_1_cphy_START  (10)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_rxdatawidthhs_1_cphy_END    (11)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_rxdatawidthhs_2_cphy_START  (12)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_rxdatawidthhs_2_cphy_END    (13)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_protocol_sel_START          (14)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_protocol_sel_END            (14)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_rxdatawidthhs_0_dphy_START  (16)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_rxdatawidthhs_0_dphy_END    (17)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_rxdatawidthhs_1_dphy_START  (18)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_rxdatawidthhs_1_dphy_END    (19)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_vote_cnt_START              (20)
#define SOC_CSI_WRAPPER_CDPHY_F_CTRL_phyf_vote_cnt_END                (21)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_F_LOCK_CTRL_UNION
 struct description   : CDPHY_F_LOCK_CTRL Register structure definition
                        Address Offset:0xC50 Initial:0x00000000 Width:32
 register description : PHY lock  control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyf_lock_wr_vld : 1;  /* bit[0]   : write valid. When wr_vld asserted PHY can be changed to lock state */
        unsigned int  phyf_lock_mst_id : 3;  /* bit[1-3] : indicate which master occupied PHY. Lock is only available when PHY is in unlock state  */
        unsigned int  reserved         : 28; /* bit[4-31]: PHYF DUMMY
                                                           reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_F_LOCK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_F_LOCK_CTRL_phyf_lock_wr_vld_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_F_LOCK_CTRL_phyf_lock_wr_vld_END    (0)
#define SOC_CSI_WRAPPER_CDPHY_F_LOCK_CTRL_phyf_lock_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_F_LOCK_CTRL_phyf_lock_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_F_UNLOCK_CTRL_UNION
 struct description   : CDPHY_F_UNLOCK_CTRL Register structure definition
                        Address Offset:0xC54 Initial:0x00000000 Width:32
 register description : PHY unlock  control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyf_unlock_wr_vld   : 1;  /* bit[0]   : write valid. When wr_vld asserted PHY can be change to unlock state */
        unsigned int  phyf_unlocked_mst_id : 3;  /* bit[1-3] : unlocked_mst_indicator should be equal to previous master's indicator who locked PHY when unlock the PHY */
        unsigned int  reserved             : 28; /* bit[4-31]: PHYF DUMMY
                                                               reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_F_UNLOCK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_F_UNLOCK_CTRL_phyf_unlock_wr_vld_START    (0)
#define SOC_CSI_WRAPPER_CDPHY_F_UNLOCK_CTRL_phyf_unlock_wr_vld_END      (0)
#define SOC_CSI_WRAPPER_CDPHY_F_UNLOCK_CTRL_phyf_unlocked_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_F_UNLOCK_CTRL_phyf_unlocked_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_F_LOCK_STATE_UNION
 struct description   : CDPHY_F_LOCK_STATE Register structure definition
                        Address Offset:0xC58 Initial:0x00000000 Width:32
 register description : PHY lock state
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyf_lock_status   : 1;  /* bit[0]   : PHY lock state.
                                                             1'b0: unlock
                                                             1'b1: lock */
        unsigned int  phyf_locked_mst_id : 3;  /* bit[1-3] : which master occupied PHY now */
        unsigned int  reserved           : 28; /* bit[4-31]: PHYF DUMMY
                                                             reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_F_LOCK_STATE_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_F_LOCK_STATE_phyf_lock_status_START    (0)
#define SOC_CSI_WRAPPER_CDPHY_F_LOCK_STATE_phyf_lock_status_END      (0)
#define SOC_CSI_WRAPPER_CDPHY_F_LOCK_STATE_phyf_locked_mst_id_START  (1)
#define SOC_CSI_WRAPPER_CDPHY_F_LOCK_STATE_phyf_locked_mst_id_END    (3)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_F_DBG_UNION
 struct description   : CDPHY_F_DBG Register structure definition
                        Address Offset:0xC5C Initial:0x00000000 Width:32
 register description : Dbg_out.
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  phyf_rx_dbg_out  : 24; /* bit[0-23] :  */
        unsigned int  phyf_clk_dbg_cnt : 8;  /* bit[24-31]: PHYF DUMMY
                                                            reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_F_DBG_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_F_DBG_phyf_rx_dbg_out_START   (0)
#define SOC_CSI_WRAPPER_CDPHY_F_DBG_phyf_rx_dbg_out_END     (23)
#define SOC_CSI_WRAPPER_CDPHY_F_DBG_phyf_clk_dbg_cnt_START  (24)
#define SOC_CSI_WRAPPER_CDPHY_F_DBG_phyf_clk_dbg_cnt_END    (31)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CDPHY_F_CLKRST_UNION
 struct description   : CDPHY_F_CLKRST Register structure definition
                        Address Offset:0xC60 Initial:0x00000001 Width:32
 register description : PHY clk gate and soft rst
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  soft_rst_phyf : 1;  /* bit[0]   : Software reset control for PHY, set to 1 to reset  */
        unsigned int  cg_phyf       : 1;  /* bit[1]   : clock gate control for PHY, clock is gated when set to 0 */
        unsigned int  reserved      : 30; /* bit[2-31]: PHYF DUMMY
                                                        reserved */
    } reg;
} SOC_CSI_WRAPPER_CDPHY_F_CLKRST_UNION;
#endif
#define SOC_CSI_WRAPPER_CDPHY_F_CLKRST_soft_rst_phyf_START  (0)
#define SOC_CSI_WRAPPER_CDPHY_F_CLKRST_soft_rst_phyf_END    (0)
#define SOC_CSI_WRAPPER_CDPHY_F_CLKRST_cg_phyf_START        (1)
#define SOC_CSI_WRAPPER_CDPHY_F_CLKRST_cg_phyf_END          (1)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_S_UNION
 struct description   : S Register structure definition
                        Address Offset:0xE00 Initial:0x00000000 Width:32
 register description : secure cfg register
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csi_abc_secure : 1;  /* bit[0]    : security attribute for 0x0~0x2ff, 0 is security, CSIA/B/C and CSIA/B/C related control and debug register is located in this region
                                                          0x600~0x7ff securety is controled by both csi_abc_secure&csi_d_secure & csi_e_secure&csi_f_secure & csi_g_secure ,This is used for commen part(eg:CSI MUX control) used by both between CSI and CDPHY  */
        unsigned int  csi_d_secure   : 1;  /* bit[1]    : security attribute for 0x400~0x4ff, 0 is security,CSID and CSID related control and debug register is located in this region.
                                                          0x600~0x7ff securety is controled by both csi_abc_secure&csi_d_secure & csi_e_secure&csi_f_secure & csi_g_secure,This is used for commen part(eg:CSI MUX control) used by both between CSI and CDPHY  */
        unsigned int  csi_e_secure   : 1;  /* bit[2]    : security attribute for 0x500~0x5ff, 0 is security,CSIE and CSIE related control and debug register is located in this region.
                                                          0x600~0x7ff securety is controled by both csi_abc_secure&csi_d_secure & csi_e_secure&csi_f_secure & csi_g_secure,This is used for commen part(eg:CSI MUX control) used by both between CSI and CDPHY  */
        unsigned int  csi_dbg_secure : 1;  /* bit[3]    : security attribute for 0x800~0x8ff, 0 is security. CSI debug registers are located in the region */
        unsigned int  reserved_0     : 1;  /* bit[4]    : Reserved */
        unsigned int  reserved_1     : 1;  /* bit[5]    : Reserved  */
        unsigned int  csi_f_secure   : 1;  /* bit[6]    : CSIF DUMMY
                                                          security attribute for 0x900~0x9ff, 0 is security,CSIF and CSIF related control and debug register is located in this region.
                                                          0x600~0x7ff securety is controled by both csi_abc_secure&csi_d_secure & csi_e_secure&csi_f_secure & csi_g_secure,This is used for commen part(eg:CSI MUX control) used by both between CSI and CDPHY  */
        unsigned int  csi_g_secure   : 1;  /* bit[7]    : CSIG DUMMY
                                                          security attribute for 0xa00~0xaff, 0 is security, CSIG and CSIG related control and debug register is located in this region
                                                          0x600~0x7ff securety is controled by both csi_abc_secure&csi_d_secure & csi_e_secure&csi_f_secure & csi_g_secure ,This is used for commen part(eg:CSI MUX control) used by both between CSI and CDPHY  */
        unsigned int  phy_a_secure   : 1;  /* bit[8]    : security attribute for 0xb00~0xb3f, 0 is security, PHY A configuration register is located in this region */
        unsigned int  phy_b_secure   : 1;  /* bit[9]    : security attribute for 0xb40~0xb7f, 0 is security, PHY B configuration register is located in this region */
        unsigned int  phy_c_secure   : 1;  /* bit[10]   : security attribute for 0xb80~0xbbf, 0 is security, PHY C configuration register is located in this region */
        unsigned int  phy_d_secure   : 1;  /* bit[11]   : security attribute for 0xbc0~0xbff, 0 is security, PHY D configuration register is located in this region */
        unsigned int  phy_e_secure   : 1;  /* bit[12]   : PHYD DUMMY
                                                          security attribute for 0xc00~0xc3f, 0 is security, PHY E configuration register is located in this region */
        unsigned int  phy_f_secure   : 1;  /* bit[13]   : PHYF DUMMY
                                                          security attribute for 0xc40~0xc7f, 0 is security, PHY F configuration register is located in this region */
        unsigned int  reserved_2     : 18; /* bit[14-31]: 0xc80~0xfff, secure region,only secure operation can access this region */
    } reg;
} SOC_CSI_WRAPPER_S_UNION;
#endif
#define SOC_CSI_WRAPPER_S_csi_abc_secure_START  (0)
#define SOC_CSI_WRAPPER_S_csi_abc_secure_END    (0)
#define SOC_CSI_WRAPPER_S_csi_d_secure_START    (1)
#define SOC_CSI_WRAPPER_S_csi_d_secure_END      (1)
#define SOC_CSI_WRAPPER_S_csi_e_secure_START    (2)
#define SOC_CSI_WRAPPER_S_csi_e_secure_END      (2)
#define SOC_CSI_WRAPPER_S_csi_dbg_secure_START  (3)
#define SOC_CSI_WRAPPER_S_csi_dbg_secure_END    (3)
#define SOC_CSI_WRAPPER_S_csi_f_secure_START    (6)
#define SOC_CSI_WRAPPER_S_csi_f_secure_END      (6)
#define SOC_CSI_WRAPPER_S_csi_g_secure_START    (7)
#define SOC_CSI_WRAPPER_S_csi_g_secure_END      (7)
#define SOC_CSI_WRAPPER_S_phy_a_secure_START    (8)
#define SOC_CSI_WRAPPER_S_phy_a_secure_END      (8)
#define SOC_CSI_WRAPPER_S_phy_b_secure_START    (9)
#define SOC_CSI_WRAPPER_S_phy_b_secure_END      (9)
#define SOC_CSI_WRAPPER_S_phy_c_secure_START    (10)
#define SOC_CSI_WRAPPER_S_phy_c_secure_END      (10)
#define SOC_CSI_WRAPPER_S_phy_d_secure_START    (11)
#define SOC_CSI_WRAPPER_S_phy_d_secure_END      (11)
#define SOC_CSI_WRAPPER_S_phy_e_secure_START    (12)
#define SOC_CSI_WRAPPER_S_phy_e_secure_END      (12)
#define SOC_CSI_WRAPPER_S_phy_f_secure_START    (13)
#define SOC_CSI_WRAPPER_S_phy_f_secure_END      (13)


/*****************************************************************************
 struct               : SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_UNION
 struct description   : CSI_WRAP_CLK_CTRL Register structure definition
                        Address Offset:0xE80 Initial:0x00000000 Width:32
 register description : CSI wrapper idi clock control
*****************************************************************************/
#ifndef __SOC_H_FOR_ASM__
typedef union {
    unsigned int      value;
    struct {
        unsigned int  csia_idi_clk_sel : 1;  /* bit[0]   : CSIA idi clock select */
        unsigned int  csib_idi_clk_sel : 1;  /* bit[1]   : CSIB idi clock select */
        unsigned int  csic_idi_clk_sel : 1;  /* bit[2]   : CSIC idi clock select */
        unsigned int  csid_idi_clk_sel : 1;  /* bit[3]   : CSID idi clock select */
        unsigned int  csie_idi_clk_sel : 1;  /* bit[4]   : CSIE idi clock select */
        unsigned int  csif_idi_clk_sel : 1;  /* bit[5]   : CSIF idi clock selectDUMMY */
        unsigned int  csig_idi_clk_sel : 1;  /* bit[6]   : CSIG idi clock selectDUMMY */
        unsigned int  reserved_0       : 1;  /* bit[7]   :  */
        unsigned int  reserved_1       : 24; /* bit[8-31]: CSI idi clock select:
                                                           0: idi clock
                                                           1: csi lane 0 clock
                                                           Dynamic configuration is not supported */
    } reg;
} SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_UNION;
#endif
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csia_idi_clk_sel_START  (0)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csia_idi_clk_sel_END    (0)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csib_idi_clk_sel_START  (1)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csib_idi_clk_sel_END    (1)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csic_idi_clk_sel_START  (2)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csic_idi_clk_sel_END    (2)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csid_idi_clk_sel_START  (3)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csid_idi_clk_sel_END    (3)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csie_idi_clk_sel_START  (4)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csie_idi_clk_sel_END    (4)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csif_idi_clk_sel_START  (5)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csif_idi_clk_sel_END    (5)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csig_idi_clk_sel_START  (6)
#define SOC_CSI_WRAPPER_CSI_WRAP_CLK_CTRL_csig_idi_clk_sel_END    (6)






/*****************************************************************************
  8 others
*****************************************************************************/



/*****************************************************************************
  9 global values
*****************************************************************************/



/*****************************************************************************
  10 global functions
*****************************************************************************/


#ifdef __cplusplus
#if __cplusplus
    }
#endif
#endif

#endif /* end of soc_csi_wrapper_interface.h */
