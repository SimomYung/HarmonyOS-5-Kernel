From a0fb514271a2f17d46b033c990e503e0ba1c8849 Mon Sep 17 00:00:00 2001
From: w30063796 <w30063796@notesmail.huawei.com/>
Date: Thu, 26 Sep 2024 16:39:14 +0800
Subject: [PATCH] TicketNo:AR20240314850539 Description:modify strongswan for
 system vpn Team:OTHERS Feature or Bugfix:Feature Binary Source:No
 PrivateCode(Yes/No):No

Change-Id: I86ec70be8008961040fbd7a0b0501426d031a6c3
---
 config.h                                      | 427 ++++++++++++++++++++++++++
 src/_updown/_updown.in                        |   2 +-
 src/ipsec/_ipsec.in                           |  65 +++-
 src/libcharon/plugins/stroke/stroke_control.c |  16 +
 src/libcharon/plugins/stroke/stroke_cred.c    |  15 +
 src/libstrongswan/networking/tun_device.c     |   9 +
 src/libstrongswan/processing/scheduler.c      |   2 +
 src/libstrongswan/threading/thread.c          |   4 +
 src/libstrongswan/utils/capabilities.c        |   4 +
 src/libstrongswan/utils/ipc_load_sa.cpp       |  21 ++
 src/libstrongswan/utils/ipc_load_sa.h         |  36 +++
 src/libstrongswan/utils/ipc_request.cpp       | 103 +++++++
 src/libstrongswan/utils/ipc_request.h         |  31 ++
 src/libstrongswan/utils/sysvpn_utils.c        |  48 +++
 src/libstrongswan/utils/sysvpn_utils.h        |  36 +++
 src/starter/files.h                           |   5 +
 src/starter/starter.c                         |  24 +-
 src/swanctl/commands/load_conns.c             |   7 +
 src/swanctl/swanctl.h                         |   4 +
 19 files changed, 847 insertions(+), 12 deletions(-)
 create mode 100755 config.h
 create mode 100644 src/libstrongswan/utils/ipc_load_sa.cpp
 create mode 100644 src/libstrongswan/utils/ipc_load_sa.h
 create mode 100644 src/libstrongswan/utils/ipc_request.cpp
 create mode 100644 src/libstrongswan/utils/ipc_request.h
 create mode 100755 src/libstrongswan/utils/sysvpn_utils.c
 create mode 100755 src/libstrongswan/utils/sysvpn_utils.h

diff --git a/config.h b/config.h
new file mode 100755
index 0000000..686139b
--- /dev/null
+++ b/config.h
@@ -0,0 +1,427 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* capability dropping support */
+/* #undef CAPABILITIES */
+
+/* have libpcap library */
+/* #undef CAPABILITIES_LIBCAP */
+
+/* have native linux capset() */
+/* #undef CAPABILITIES_NATIVE */
+
+/* UDP post used by charon locally in case a NAT is detected */
+/* #undef CHARON_NATT_PORT */
+
+/* UDP port used by charon locally */
+/* #undef CHARON_UDP_PORT */
+
+/* defined if config.h included */
+#define CONFIG_H_INCLUDED /**/
+
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+/* #undef CRAY_STACKSEG_END */
+
+/* Define to 1 if using `alloca.c'. */
+/* #undef C_ALLOCA */
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+#define HAVE_ALLOCA 1
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+#define HAVE_ALLOCA_H 1
+
+/* Define to 1 if you have the `backtrace' function. */
+#define HAVE_BACKTRACE 1
+
+/* have binutils bfd.h */
+/* #undef HAVE_BFD_H */
+
+/* Define to 1 if you have the `botan_rng_init_custom' function. */
+/* #undef HAVE_BOTAN_RNG_INIT_CUSTOM */
+
+/* Define to 1 if you have the `chown' function. */
+#define HAVE_CHOWN 1
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define HAVE_CLOCK_GETTIME 1
+
+/* Define to 1 if you have the `closefrom' function. */
+/* #undef HAVE_CLOSEFROM */
+
+/* pthread_condattr_setclock supports CLOCK_MONOTONIC */
+#define HAVE_CONDATTR_CLOCK_MONOTONIC /**/
+
+/* Define to 1 if you have the declaration of `bfd_get_section_flags', and to
+   0 if you don't. */
+/* #undef HAVE_DECL_BFD_GET_SECTION_FLAGS */
+
+/* Define to 1 if you have the declaration of `bfd_get_section_size', and to 0
+   if you don't. */
+/* #undef HAVE_DECL_BFD_GET_SECTION_SIZE */
+
+/* Define to 1 if you have the declaration of `bfd_get_section_vma', and to 0
+   if you don't. */
+/* #undef HAVE_DECL_BFD_GET_SECTION_VMA */
+
+/* Define to 1 if you have the declaration of `bfd_section_flags', and to 0 if
+   you don't. */
+/* #undef HAVE_DECL_BFD_SECTION_FLAGS */
+
+/* Define to 1 if you have the declaration of `bfd_section_size', and to 0 if
+   you don't. */
+/* #undef HAVE_DECL_BFD_SECTION_SIZE */
+
+/* Define to 1 if you have the declaration of `bfd_section_vma', and to 0 if
+   you don't. */
+/* #undef HAVE_DECL_BFD_SECTION_VMA */
+
+/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRERROR_R 1
+
+/* Define to 1 if you have the `dirfd' function. */
+#define HAVE_DIRFD 1
+
+/* have dladdr() */
+#define HAVE_DLADDR /**/
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the `explicit_bzero' function. */
+#define HAVE_EXPLICIT_BZERO 1
+
+/* Define to 1 if you have the `fmemopen' function. */
+#define HAVE_FMEMOPEN 1
+
+/* Define to 1 if you have the `funopen' function. */
+/* #undef HAVE_FUNOPEN */
+
+/* have GCC __sync_* operations */
+/* #undef HAVE_GCC_SYNC_OPERATIONS */
+
+/* have GCRY_CIPHER_CAMELLIA128 */
+/* #undef HAVE_GCRY_CIPHER_CAMELLIA */
+
+/* Define to 1 if you have the `getgrnam_r' function. */
+#define HAVE_GETGRNAM_R 1
+
+/* Define to 1 if you have the `getpass' function. */
+#define HAVE_GETPASS 1
+
+/* Define to 1 if you have the `getpwnam_r' function. */
+#define HAVE_GETPWNAM_R 1
+
+/* Define to 1 if you have the `getpwuid_r' function. */
+#define HAVE_GETPWUID_R 1
+
+/* have gettid() */
+#define HAVE_GETTID /**/
+
+/* Define to 1 if you have the <glob.h> header file. */
+#define HAVE_GLOB_H 1
+
+/* have struct in6_addr in6addr_any */
+#define HAVE_IN6ADDR_ANY /**/
+
+/* have struct in6_pktinfo.ipi6_ifindex */
+#define HAVE_IN6_PKTINFO /**/
+
+/* have __int128 type support */
+/* #undef HAVE_INT128 */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* have IPSEC_DIR_FWD defined */
+#define HAVE_IPSEC_DIR_FWD /**/
+
+/* have IPSEC_MODE_BEET defined */
+#define HAVE_IPSEC_MODE_BEET /**/
+
+/* Define to 1 if you have the `gmp' library (-lgmp). */
+/* #undef HAVE_LIBGMP */
+
+/* have libunwind.h */
+/* #undef HAVE_LIBUNWIND_H */
+
+/* Define to 1 if you have the <linux/fib_rules.h> header file. */
+/* #undef HAVE_LINUX_FIB_RULES_H */
+
+/* Define to 1 if you have the <linux/udp.h> header file. */
+#define HAVE_LINUX_UDP_H 1
+
+/* Define to 1 if you have the `mallinfo' function. */
+#define HAVE_MALLINFO 1
+
+/* Define to 1 if you have the `mallinfo2' function. */
+#define HAVE_MALLINFO2 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `memrchr' function. */
+#define HAVE_MEMRCHR 1
+
+/* Define to 1 if you have the `mmap' function. */
+#define HAVE_MMAP 1
+
+/* have mpz_powm_sec() */
+/* #undef HAVE_MPZ_POWM_SEC */
+
+/* Define to 1 if you have the <netinet6/ipsec.h> header file. */
+/* #undef HAVE_NETINET6_IPSEC_H */
+
+/* Define to 1 if you have the <netinet/ip6.h> header file. */
+#define HAVE_NETINET_IP6_H 1
+
+/* Define to 1 if you have the <netipsec/ipsec.h> header file. */
+/* #undef HAVE_NETIPSEC_IPSEC_H */
+
+/* Define to 1 if you have the <net/if_tun.h> header file. */
+/* #undef HAVE_NET_IF_TUN_H */
+
+/* Define to 1 if you have the <net/pfkeyv2.h> header file. */
+/* #undef HAVE_NET_PFKEYV2_H */
+
+/* Define to 1 if you have the `prctl' function. */
+#define HAVE_PRCTL 1
+
+/* have register_printf_function() */
+/* #undef HAVE_PRINTF_FUNCTION */
+
+/* have register_printf_specifier() */
+/* #undef HAVE_PRINTF_SPECIFIER */
+
+/* Define to 1 if you have the `pthread_cancel' function. */
+/* #undef HAVE_PTHREAD_CANCEL */
+
+/* Define to 1 if you have the `pthread_condattr_init' function. */
+#define HAVE_PTHREAD_CONDATTR_INIT 1
+
+/* Define to 1 if you have the `pthread_condattr_setclock' function. */
+#define HAVE_PTHREAD_CONDATTR_SETCLOCK 1
+
+/* Define to 1 if you have the `pthread_cond_timedwait_monotonic' function. */
+/* #undef HAVE_PTHREAD_COND_TIMEDWAIT_MONOTONIC */
+
+/* Define to 1 if you have the `pthread_rwlock_init' function. */
+#define HAVE_PTHREAD_RWLOCK_INIT 1
+
+/* Define to 1 if you have the `pthread_spin_init' function. */
+#define HAVE_PTHREAD_SPIN_INIT 1
+
+/* have qsort_r() */
+/* #undef HAVE_QSORT_R */
+
+/* have BSD-style qsort_r() */
+/* #undef HAVE_QSORT_R_BSD */
+
+/* have GNU-style qsort_r() */
+/* #undef HAVE_QSORT_R_GNU */
+
+/* have netlink RTA_TABLE defined */
+/* #undef HAVE_RTA_TABLE */
+
+/* have PF_ROUTE RTM_IFANNOUNCE defined */
+/* #undef HAVE_RTM_IFANNOUNCE */
+
+/* Define to 1 if you have the `sd_listen_fds_with_names' function. */
+/* #undef HAVE_SD_LISTEN_FDS_WITH_NAMES */
+
+/* Define to 1 if you have the `sem_timedwait' function. */
+#define HAVE_SEM_TIMEDWAIT 1
+
+/* Define to 1 if you have the `setlinebuf' function. */
+#define HAVE_SETLINEBUF 1
+
+/* Define to 1 if you have the `sigwaitinfo' function. */
+#define HAVE_SIGWAITINFO 1
+
+/* have sqlite3_prepare_v2() */
+/* #undef HAVE_SQLITE3_PREPARE_V2 */
+
+/* Define to 1 if stdbool.h conforms to C99. */
+#define HAVE_STDBOOL_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strerror_r' function. */
+#define HAVE_STRERROR_R 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strptime' function. */
+#define HAVE_STRPTIME 1
+
+/* Define to 1 if `sadb_x_policy_priority' is a member of `struct
+   sadb_x_policy'. */
+#define HAVE_STRUCT_SADB_X_POLICY_SADB_X_POLICY_PRIORITY 1
+
+/* Define to 1 if `sa_len' is a member of `struct sockaddr'. */
+/* #undef HAVE_STRUCT_SOCKADDR_SA_LEN */
+
+/* have syslog(3) and friends */
+#define HAVE_SYSLOG /**/
+
+/* have sys/capability.h */
+/* #undef HAVE_SYS_CAPABILITY_H */
+
+/* have syscall(SYS_gettid) */
+/* #undef HAVE_SYS_GETTID */
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/sockio.h> header file. */
+/* #undef HAVE_SYS_SOCKIO_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/syscall.h> header file. */
+#define HAVE_SYS_SYSCALL_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if the system has the type `_Bool'. */
+#define HAVE__BOOL 1
+
+/* groupname to run daemon with */
+/* #undef IPSEC_GROUP */
+
+/* username to run daemon with */
+/* #undef IPSEC_USER */
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* mediation extension support */
+/* #undef ME */
+
+/* monolithic build embedding plugins */
+#define MONOLITHIC /**/
+
+/* Name of package */
+#define PACKAGE "strongswan"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "strongSwan"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "strongSwan 5.9.10"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "strongswan"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "5.9.10"
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at runtime.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+/* #undef STACK_DIRECTION */
+
+/* static plugin constructors */
+#define STATIC_PLUGIN_CONSTRUCTORS /**/
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if strerror_r returns char *. */
+/* #undef STRERROR_R_CHAR_P */
+
+/* use TSS2 v2 Extended System API */
+/* #undef TSS2_ESYS */
+
+/* use TSS2 v2 System API */
+/* #undef TSS2_SYS */
+
+/* use TCTI Sockets */
+/* #undef TSS2_TCTI_SOCKET */
+
+/* use TCTI Access Broker and Resource Manager */
+/* #undef TSS2_TCTI_TABRMD */
+
+/* use TrouSerS library libtspi */
+/* #undef TSS_TROUSERS */
+
+/* use TSS 2.0 v1 libraries */
+/* #undef TSS_TSS2_V1 */
+
+/* use TSS 2.0 v2 libraries */
+/* #undef TSS_TSS2_V2 */
+
+/* using builtin printf for printf hooks */
+#define USE_BUILTIN_PRINTF /**/
+
+/* build code for fuzzing */
+/* #undef USE_FUZZING */
+
+/* support for IKEv1 protocol */
+#define USE_IKEV1 /**/
+
+/* support for IKEv2 protocol */
+#define USE_IKEV2 /**/
+
+/* build code for JSON */
+/* #undef USE_JSON */
+
+/* build with support for SELinux */
+/* #undef USE_SELINUX */
+
+/* use thread ID for thread identification, if available */
+/* #undef USE_THREAD_IDS */
+
+/* use Vstr string library for printf hooks */
+/* #undef USE_VSTR */
+
+/* Version number of package */
+#define VERSION "5.9.10"
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
+   `char[]'. */
+/* #undef YYTEXT_POINTER */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
diff --git a/src/_updown/_updown.in b/src/_updown/_updown.in
index 34eaf68..afe20e9 100644
--- a/src/_updown/_updown.in
+++ b/src/_updown/_updown.in
@@ -137,7 +137,7 @@
 #
 
 # define a minimum PATH environment in case it is not set
-PATH="/sbin:/bin:/usr/sbin:/usr/bin:@sbindir@"
+PATH="/sbin:/bin:/usr/sbin:/usr/bin"
 export PATH
 
 # comment to disable logging VPN connections to syslog
diff --git a/src/ipsec/_ipsec.in b/src/ipsec/_ipsec.in
index 5bce25e..febf136 100644
--- a/src/ipsec/_ipsec.in
+++ b/src/ipsec/_ipsec.in
@@ -1,4 +1,4 @@
-#! @IPSEC_SHELL@
+#! /bin/sh
 # prefix command to run stuff from our programs directory
 # Copyright (C) 1998-2002  Henry Spencer.
 # Copyright (C) 2006-2014 Andreas Steffen
@@ -23,24 +23,25 @@ export PATH
 
 # name and version of the ipsec implementation
 OS_NAME=`uname -s`
-IPSEC_NAME="@IPSEC_NAME@"
-IPSEC_VERSION="U@IPSEC_VERSION@/K`uname -r`"
+IPSEC_NAME="strongSwan"
+IPSEC_VERSION="U5.9.10/K`uname -r`"
 
 # where the private directory and the config files are
-IPSEC_DIR="@IPSEC_DIR@"
-IPSEC_BINDIR="@IPSEC_BINDIR@"
-IPSEC_SBINDIR="@IPSEC_SBINDIR@"
-IPSEC_CONFDIR="@IPSEC_CONFDIR@"
-IPSEC_PIDDIR="@IPSEC_PIDDIR@"
-IPSEC_SCRIPT="@IPSEC_SCRIPT@"
+IPSEC_DIR="/system/bin"
+IPSEC_BINDIR="/system/bin"
+IPSEC_SBINDIR="/system/bin"
+IPSEC_CONFDIR="/system/etc/strongswan"
+IPSEC_PIDDIR="/data/service/el1/public/vpn"
+IPSEC_SCRIPT="ipsec"
 
 IPSEC_STARTER_PID="${IPSEC_PIDDIR}/starter.${DAEMON_NAME}.pid"
 IPSEC_CHARON_PID="${IPSEC_PIDDIR}/${DAEMON_NAME}.pid"
+XL2TPD_PID="${IPSEC_PIDDIR}/xl2tpd.pid"
 
 IPSEC_STROKE="${IPSEC_DIR}/stroke"
 IPSEC_STARTER="${IPSEC_DIR}/starter"
 
-export IPSEC_DIR IPSEC_BINDIR IPSEC_SBINDIR IPSEC_CONFDIR IPSEC_PIDDIR IPSEC_SCRIPT IPSEC_VERSION IPSEC_NAME IPSEC_STARTER_PID IPSEC_CHARON_PID
+export IPSEC_DIR IPSEC_BINDIR IPSEC_SBINDIR IPSEC_CONFDIR IPSEC_PIDDIR IPSEC_SCRIPT IPSEC_VERSION IPSEC_NAME IPSEC_STARTER_PID IPSEC_CHARON_PID XL2TPD_PID
 
 IPSEC_DISTRO="University of Applied Sciences Rapperswil, Switzerland"
 
@@ -247,6 +248,34 @@ status|statusall)
 	;;
 stop)
 	# stopping a not-running service is considered as success
+	if [ -e $XL2TPD_PID ]
+	then
+		echo "Stopping xl2tpd ..." >&2
+		xl2tpd_pid=`cat $XL2TPD_PID`
+		if [ -n "$xl2tpd_pid" ]
+		then
+			kill $xl2tpd_pid 2>/dev/null
+			loop=110
+			while [ $loop -gt 0 ] ; do
+				kill -0 $xl2tpd_pid 2>/dev/null || break
+				sleep 0.1 2>/dev/null
+				if [ $? -ne 0 ]
+				then
+					sleep 1
+					loop=$(($loop - 9))
+				fi
+				loop=$(($loop - 1))
+			done
+			if [ $loop -le 0 ]
+			then
+				kill -KILL $xl2tpd_pid 2>/dev/null
+				rm -f $XL2TPD_PID
+			fi
+		fi
+	else
+		echo "Stopping xl2tpd ignored: xl2tpd is not running" >&2
+	fi
+
 	if [ -e $IPSEC_STARTER_PID ]
 	then
 		echo "Stopping strongSwan IPsec..." >&2
@@ -320,6 +349,22 @@ version|--version)
 	printf "$IPSEC_DISTRO\n"
 	exit 0
 	;;
+l2tpctl)
+	shift
+	touch ${IPSEC_PIDDIR}/l2tp-control
+	echo "c myVPN" > ${IPSEC_PIDDIR}/l2tp-control
+	exit 0
+	;;
+swanctl)
+	shift
+	exec $IPSEC_SBINDIR/swanctl "$@"
+	exit 0
+	;;
+xl2tpd)
+	shift
+	exec $IPSEC_SBINDIR/xl2tpd "$@"
+	exit 0
+	;;
 --*)
 	echo "$0: unknown option \`$1' (perhaps command name was omitted?)" >&2
 	exit 2
diff --git a/src/libcharon/plugins/stroke/stroke_control.c b/src/libcharon/plugins/stroke/stroke_control.c
index ba4e5bf..e7702c3 100644
--- a/src/libcharon/plugins/stroke/stroke_control.c
+++ b/src/libcharon/plugins/stroke/stroke_control.c
@@ -23,6 +23,10 @@
 #include <processing/jobs/rekey_ike_sa_job.h>
 #include <processing/jobs/rekey_child_sa_job.h>
 
+#ifdef SUPPORT_SYSVPN
+#include "utils/sysvpn_utils.h"
+#endif //SUPPORT_SYSVPN
+
 typedef struct private_stroke_control_t private_stroke_control_t;
 
 /**
@@ -124,15 +128,24 @@ static void charon_initiate(private_stroke_control_t *this, peer_cfg_t *peer_cfg
 			case SUCCESS:
 				fprintf(out, "connection '%s' established successfully\n",
 						msg->initiate.name);
+#ifdef SUPPORT_SYSVPN
+				WriteStageAndStatus("connect", 100);
+#endif // SUPPORT_SYSVPN
 				break;
 			case OUT_OF_RES:
 				fprintf(out, "connection '%s' not established after %dms, "
 						"detaching\n", msg->initiate.name, this->timeout);
+#ifdef SUPPORT_SYSVPN
+				WriteStageAndStatus("connect", 200);
+#endif // SUPPORT_SYSVPN
 				break;
 			default:
 			case FAILED:
 				fprintf(out, "establishing connection '%s' failed\n",
 						msg->initiate.name);
+#ifdef SUPPORT_SYSVPN
+				WriteStageAndStatus("connect", 201);
+#endif // SUPPORT_SYSVPN
 				break;
 		}
 	}
@@ -286,6 +299,9 @@ static void report_terminate_status(private_stroke_control_t *this,
 	{
 		case SUCCESS:
 			fprintf(out, "%s%d%s closed successfully\n", prefix, id, postfix);
+#ifdef SUPPORT_SYSVPN
+			WriteStageAndStatus("closed", 100);
+#endif // SUPPORT_SYSVPN
 			break;
 		case OUT_OF_RES:
 			fprintf(out, "%s%d%s not closed after %dms, detaching\n",
diff --git a/src/libcharon/plugins/stroke/stroke_cred.c b/src/libcharon/plugins/stroke/stroke_cred.c
index 2233617..ff964aa 100644
--- a/src/libcharon/plugins/stroke/stroke_cred.c
+++ b/src/libcharon/plugins/stroke/stroke_cred.c
@@ -39,17 +39,32 @@
 #include <threading/rwlock.h>
 #include <daemon.h>
 
+#ifdef SUPPORT_SYSVPN
+#include "utils/sysvpn_utils.h"
+#endif // SUPPORT_SYSVPN
+
 /* configuration directories and files */
 #define CONFIG_DIR IPSEC_CONFDIR
 #define IPSEC_D_DIR CONFIG_DIR "/ipsec.d"
 #define PRIVATE_KEY_DIR IPSEC_D_DIR "/private"
 #define CERTIFICATE_DIR IPSEC_D_DIR "/certs"
+
+#ifdef SUPPORT_SYSVPN
+#define CA_CERTIFICATE_DIR IPSEC_PIDDIR
+#else
 #define CA_CERTIFICATE_DIR IPSEC_D_DIR "/cacerts"
+#endif // SUPPORT_SYSVPN
+
 #define AA_CERTIFICATE_DIR IPSEC_D_DIR "/aacerts"
 #define ATTR_CERTIFICATE_DIR IPSEC_D_DIR "/acerts"
 #define OCSP_CERTIFICATE_DIR IPSEC_D_DIR "/ocspcerts"
 #define CRL_DIR IPSEC_D_DIR "/crls"
+
+#ifdef SUPPORT_SYSVPN
+#define SECRETS_FILE IPSEC_PIDDIR "/ipsec.secrets.conf"
+#else
 #define SECRETS_FILE CONFIG_DIR "/ipsec.secrets"
+#endif // SUPPORT_SYSVPN
 
 #define MAX_SECRETS_RECURSION 10
 
diff --git a/src/libstrongswan/networking/tun_device.c b/src/libstrongswan/networking/tun_device.c
index 39fac4e..3cac4da 100644
--- a/src/libstrongswan/networking/tun_device.c
+++ b/src/libstrongswan/networking/tun_device.c
@@ -469,12 +469,21 @@ static bool init_tun(private_tun_device_t *this, const char *name_tmpl)
 	strncpy(this->if_name, name_tmpl ?: "tun%d", IFNAMSIZ-1);
 	this->if_name[IFNAMSIZ-1] = '\0';
 
+#ifdef SUPPORT_SYSVPN
+	this->tunfd = open("/dev/tun", O_RDWR);
+	if (this->tunfd < 0)
+	{
+		DBG1(DBG_LIB, "failed to open /dev/tun: %s", strerror(errno));
+		return FALSE;
+	}
+#else
 	this->tunfd = open("/dev/net/tun", O_RDWR);
 	if (this->tunfd < 0)
 	{
 		DBG1(DBG_LIB, "failed to open /dev/net/tun: %s", strerror(errno));
 		return FALSE;
 	}
+#endif // SUPPORT_SYSVPN
 
 	memset(&ifr, 0, sizeof(ifr));
 
diff --git a/src/libstrongswan/processing/scheduler.c b/src/libstrongswan/processing/scheduler.c
index c5e5dd8..319047f 100644
--- a/src/libstrongswan/processing/scheduler.c
+++ b/src/libstrongswan/processing/scheduler.c
@@ -290,7 +290,9 @@ METHOD(scheduler_t, flush, void,
 	{
 		event_destroy(event);
 	}
+#ifndef SUPPORT_SYSVPN
 	this->condvar->signal(this->condvar);
+#endif // SUPPORT_SYSVPN
 	this->mutex->unlock(this->mutex);
 }
 
diff --git a/src/libstrongswan/threading/thread.c b/src/libstrongswan/threading/thread.c
index b8e2ce4..087941f 100644
--- a/src/libstrongswan/threading/thread.c
+++ b/src/libstrongswan/threading/thread.c
@@ -127,7 +127,11 @@ static thread_value_t *current_thread;
 #ifdef ANDROID
 #define SIG_CANCEL SIGUSR2
 #else
+#ifdef SUPPORT_SYSVPN
+#define SIG_CANCEL SIGUSR2
+#else
 #define SIG_CANCEL (SIGRTMIN+7)
+#endif // SUPPORT_SYSVPN
 #endif
 
 /* the signal handler for SIG_CANCEL uses pthread_exit to terminate the
diff --git a/src/libstrongswan/utils/capabilities.c b/src/libstrongswan/utils/capabilities.c
index 9836fc9..1d587d6 100644
--- a/src/libstrongswan/utils/capabilities.c
+++ b/src/libstrongswan/utils/capabilities.c
@@ -146,7 +146,11 @@ static bool has_capability(private_capabilities_t *this, u_int cap,
 	}
 #ifndef CAPABILITIES
 	/* if we can't check the actual capabilities assume only root has it */
+#ifdef SUPPORT_SYSVPN
+	return TRUE;
+#else
 	return geteuid() == 0;
+#endif // SUPPORT_SYSVPN
 #endif /* !CAPABILITIES */
 #ifdef CAPABILITIES_LIBCAP
 	cap_flag_value_t val;
diff --git a/src/libstrongswan/utils/ipc_load_sa.cpp b/src/libstrongswan/utils/ipc_load_sa.cpp
new file mode 100644
index 0000000..4bddc29
--- /dev/null
+++ b/src/libstrongswan/utils/ipc_load_sa.cpp
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "ipc_load_sa.h"
+
+using namespace std;
+
+OnDemandLoadCertManagerCallback::OnDemandLoadCertManagerCallback(string servers) : servers(servers)
+{
+}
diff --git a/src/libstrongswan/utils/ipc_load_sa.h b/src/libstrongswan/utils/ipc_load_sa.h
new file mode 100644
index 0000000..4590ea8
--- /dev/null
+++ b/src/libstrongswan/utils/ipc_load_sa.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef IPC_LOAD_SA_H
+#define IPC_LOAD_SA_H
+
+#include <future>
+#include <string>
+#include "iremote_object.h"
+#include "system_ability_load_callback_stub.h"
+
+class OnDemandLoadCertManagerCallback : public OHOS::SystemAbilityLoadCallbackStub {
+public:
+    OnDemandLoadCertManagerCallback(std::string servers);
+    void OnLoadSystemAbilitySuccess(int32_t systemAbilityId,
+        const OHOS::sptr<IRemoteObject>& remoteObject) override;
+    void OnLoadSystemAbilityFail(int32_t systemAbilityId) override;
+    OHOS::sptr<IRemoteObject> Promise(void);
+private:
+    std::string servers;
+    std::promise<OHOS::sptr<IRemoteObject>> promise_;
+};
+
+#endif /* IPC_LOAD_SA_H */
\ No newline at end of file
diff --git a/src/libstrongswan/utils/ipc_request.cpp b/src/libstrongswan/utils/ipc_request.cpp
new file mode 100644
index 0000000..4c97b57
--- /dev/null
+++ b/src/libstrongswan/utils/ipc_request.cpp
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "ipc_request.h"
+
+#include <chrono>
+#include <string>
+#include <thread>
+
+#include "securec.h"
+#include "ipc_load_sa.h"
+#include "iservice_registry.h"
+#include "system_ability_definition.h"
+
+using namespace std;
+using namespace OHOS;
+
+namespace {
+    constexpr int SA_ID_VPN_SERVICE = COMM_VPN_MANAGER_SYS_ABILITY_ID;
+    constexpr int CMD_NOTIFY_CONNECT_STAGE = 14;
+    constexpr uint32_t MAX_SA_BOOT_DELAY_TIME = 30;
+    const std::u16string SA_VPN_SERVICE_DESCRIPTOR = u"OHOS.NetManagerStandard.INetworkVpnService";
+}
+
+static sptr<IRemoteObject> ProcessLoadSystemAbility(void)
+{
+    auto saManager = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();
+    if (saManager == nullptr) {
+        return {};
+    }
+
+    auto object = saManager->CheckSystemAbility(SA_ID_VPN_SERVICE);
+    if (object != nullptr) {
+        return object;
+    }
+
+    string servers = "NetManager";
+    sptr<OnDemandLoadCertManagerCallback> loadCallBack = new (std::nothrow)OnDemandLoadCertManagerCallback(servers);
+    if (loadCallBack == nullptr) {
+        return {};
+    }
+
+    int32_t ret = saManager->LoadSystemAbility(SA_ID_VPN_SERVICE, loadCallBack);
+    if (ret != ERR_OK) {
+        return {};
+    }
+
+    return loadCallBack->Promise();
+}
+
+int32_t SendRequest(char *stage, int32_t state)
+{
+    uint32_t i = 0;
+    sptr<IRemoteObject> targetProxy = ProcessLoadSystemAbility();
+    while ((targetProxy == nullptr) && i < MAX_SA_BOOT_DELAY_TIME) {
+        std::this_thread::sleep_for(std::chrono::milliseconds(100)); /* 100 is time */
+        i++;
+    }
+
+    targetProxy = ProcessLoadSystemAbility();
+    if (targetProxy == nullptr) {
+        return -1;
+    }
+
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option = MessageOption::TF_SYNC;
+
+    data.WriteInterfaceToken(SA_VPN_SERVICE_DESCRIPTOR);
+    data.WriteString(stage);
+    data.WriteInt32(state);
+
+    int error = targetProxy->SendRequest(static_cast<uint32_t>(CMD_NOTIFY_CONNECT_STAGE), data, reply, option);
+    return error;
+}
+
+void OnDemandLoadCertManagerCallback::OnLoadSystemAbilitySuccess(int32_t systemAbilityId,
+    const sptr<IRemoteObject> &remoteObject)
+{
+    promise_.set_value(remoteObject);
+}
+
+void OnDemandLoadCertManagerCallback::OnLoadSystemAbilityFail(int32_t systemAbilityId)
+{
+    promise_.set_value(nullptr);
+}
+
+sptr<IRemoteObject> OnDemandLoadCertManagerCallback::Promise(void)
+{
+    return promise_.get_future().get();
+}
diff --git a/src/libstrongswan/utils/ipc_request.h b/src/libstrongswan/utils/ipc_request.h
new file mode 100644
index 0000000..b25dc22
--- /dev/null
+++ b/src/libstrongswan/utils/ipc_request.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef IPC_REQUEST_H
+#define IPC_REQUEST_H
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int32_t SendRequest(char *stage, int32_t state);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* IPC_REQUEST_H */
\ No newline at end of file
diff --git a/src/libstrongswan/utils/sysvpn_utils.c b/src/libstrongswan/utils/sysvpn_utils.c
new file mode 100755
index 0000000..a2df0b0
--- /dev/null
+++ b/src/libstrongswan/utils/sysvpn_utils.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "sysvpn_utils.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <utils/debug.h>
+#include "ipc_request.h"
+
+void WriteStageAndStatus(char *stage, int32_t status)
+{
+  if (!stage) {
+    return;
+  }
+
+  if (fork() == 0) {
+    SendRequest(stage, status);
+    _exit(0);
+  }
+}
+
+/**
+ * check ipsec.conf file exist function for starter
+ */
+bool checkIpsecFile()
+{
+  bool bret = false;
+  if (access(IPSECCONFFILE, F_OK) != -1) {
+    bret = true;
+  } else {
+    bret = false;
+  }
+  return bret;
+}
diff --git a/src/libstrongswan/utils/sysvpn_utils.h b/src/libstrongswan/utils/sysvpn_utils.h
new file mode 100755
index 0000000..c1dd906
--- /dev/null
+++ b/src/libstrongswan/utils/sysvpn_utils.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @defgroup util
+ * @{ @ingroup util
+ */
+
+#ifndef UTIL_H_
+#define UTIL_H_
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#define IPSECCONFFILE IPSEC_PIDDIR "/ipsec.conf"
+
+void WriteStageAndStatus(char *stage, int32_t status);
+
+/**
+ * check ipsec.conf file exist function for starter
+ */
+bool checkIpsecFile();
+
+#endif /** UTIL_H_*/
diff --git a/src/starter/files.h b/src/starter/files.h
index f2f8225..4ff9527 100644
--- a/src/starter/files.h
+++ b/src/starter/files.h
@@ -16,7 +16,12 @@
 #define _STARTER_FILES_H_
 
 #define CONFIG_FILE     IPSEC_CONFDIR "/ipsec.conf"
+
+#ifdef SUPPORT_SYSVPN
+#define SECRETS_FILE    IPSEC_CONFDIR "/ipsec.secrets.conf"
+#else
 #define SECRETS_FILE    IPSEC_CONFDIR "/ipsec.secrets"
+#endif // SUPPORT_SYSVPN
 
 #define CHARON_CTL_FILE IPSEC_PIDDIR "/charon.ctl"
 
diff --git a/src/starter/starter.c b/src/starter/starter.c
index ade88bb..f2f8afd 100644
--- a/src/starter/starter.c
+++ b/src/starter/starter.c
@@ -43,12 +43,20 @@
 #include "invokecharon.h"
 #include "cmp.h"
 
+#ifdef SUPPORT_SYSVPN
+#include "utils/sysvpn_utils.h"
+#endif // SUPPORT_SYSVPN
+
 #ifndef LOG_AUTHPRIV
 #define LOG_AUTHPRIV LOG_AUTH
 #endif
 
 #define CHARON_RESTART_DELAY 5
 
+#ifdef SUPPORT_SYSVPN
+#define STARTER_ALLOW_NON_ROOT
+#endif // SUPPORT_SYSVPN
+
 static const char* cmd_default = IPSEC_DIR "/charon";
 static const char* pid_file_default = IPSEC_PIDDIR "/charon.pid";
 static const char* starter_pid_file_default = IPSEC_PIDDIR "/starter.pid";
@@ -421,8 +429,17 @@ int main (int argc, char **argv)
 	}
 	if (!config_file)
 	{
+#ifdef SUPPORT_SYSVPN
+		if (checkIpsecFile()) {
+			config_file = IPSECCONFFILE;
+		} else {
+			config_file = lib->settings->get_str(lib->settings,
+												"starter.config_file", CONFIG_FILE);
+		}
+#else
 		config_file = lib->settings->get_str(lib->settings,
 											 "starter.config_file", CONFIG_FILE);
+#endif // SUPPORT_SYSVPN
 	}
 
 	init_log("ipsec_starter");
@@ -460,7 +477,6 @@ int main (int argc, char **argv)
 		lib->settings->get_bool(lib->settings,
 			"charon.i_dont_care_about_security_and_use_aggressive_mode_psk",
 				FALSE) ? "weak" : "strong");
-
 #ifdef LOAD_WARNING
 	load_warning = TRUE;
 #endif
@@ -627,6 +643,9 @@ int main (int argc, char **argv)
 			cleanup();
 			DBG1(DBG_APP, "ipsec starter stopped");
 			close_log();
+#ifdef SUPPORT_SYSVPN
+			WriteStageAndStatus("stop", 100);
+#endif // SUPPORT_SYSVPN
 			exit(LSB_RC_SUCCESS);
 		}
 
@@ -788,6 +807,9 @@ int main (int argc, char **argv)
 					conn->state = STATE_TO_ADD;
 				}
 			}
+#ifdef SUPPORT_SYSVPN
+			WriteStageAndStatus("start", 100);
+#endif // SUPPORT_SYSVPN
 		}
 
 		/*
diff --git a/src/swanctl/commands/load_conns.c b/src/swanctl/commands/load_conns.c
index 92be167..c04a138 100644
--- a/src/swanctl/commands/load_conns.c
+++ b/src/swanctl/commands/load_conns.c
@@ -23,6 +23,10 @@
 #include "swanctl.h"
 #include "load_conns.h"
 
+#ifdef SUPPORT_SYSVPN
+#include "utils/sysvpn_utils.h"
+#endif // SUPPORT_SYSVPN
+
 /**
  * Check if we should handle a key as a list of comma separated values
  */
@@ -418,6 +422,9 @@ int load_conns_cfg(vici_conn_t *conn, command_format_options_t format,
 	{
 		printf("successfully loaded %u connections, %u unloaded\n",
 			   loaded, unloaded);
+#ifdef SUPPORT_SYSVPN
+		WriteStageAndStatus("config", 100);
+#endif // SUPPORT_SYSVPN
 		return 0;
 	}
 	fprintf(stderr, "loaded %u of %u connections, %u failed to load, "
diff --git a/src/swanctl/swanctl.h b/src/swanctl/swanctl.h
index d49038c..3ce65e4 100644
--- a/src/swanctl/swanctl.h
+++ b/src/swanctl/swanctl.h
@@ -74,7 +74,11 @@ extern char *swanctl_dir;
 /**
  * Directory for private keys
  */
+#ifdef SUPPORT_SYSVPN
+#define SWANCTL_PRIVATEDIR ""
+#else
 #define SWANCTL_PRIVATEDIR "private"
+#endif // SUPPORT_SYSVPN
 
 /**
  * Directory for RSA private keys
-- 
2.7.4

