From 0c258d54b5a7956eb6cd6e3e79e396c4ce296503 Mon Sep 17 00:00:00 2001
From: g00650597 <g00650597@notesmail.huawei.com/>
Date: Sat, 28 Dec 2024 15:19:53 +0800
Subject: [PATCH] TicketNo:DTS2024121134413 Description:get get secrets config
 from system vpn

Team:OTHERS
Feature or Bugfix:Feature
Binary Source:No
PrivateCode(Yes/No):No

Change-Id: I3a3b5a13546baa40b776e6ff64a43059f5cc63ba
---
 src/libcharon/plugins/stroke/stroke_cred.c    | 57 +++++++++++++++++++
 .../netmanager/include/ipc_request.h          |  2 +
 2 files changed, 59 insertions(+)

diff --git a/src/libcharon/plugins/stroke/stroke_cred.c b/src/libcharon/plugins/stroke/stroke_cred.c
index 783ba2285..c54b357a2 100644
--- a/src/libcharon/plugins/stroke/stroke_cred.c
+++ b/src/libcharon/plugins/stroke/stroke_cred.c
@@ -41,6 +41,7 @@
 
 #ifdef SUPPORT_SYSVPN
 #include "keystore.h"
+#include "ipc_request.h"
 #endif // SUPPORT_SYSVPN
 
 /* configuration directories and files */
@@ -68,6 +69,10 @@
 
 #define MAX_SECRETS_RECURSION 10
 
+#ifdef SUPPORT_SYSVPN
+#define MAX_SECRETS_LEN 1024
+#endif // SUPPORT_SYSVPN
+
 typedef struct private_stroke_cred_t private_stroke_cred_t;
 
 /**
@@ -1195,6 +1200,44 @@ static bool load_shared(mem_cred_t *secrets, chunk_t line, int line_nr,
 	return TRUE;
 }
 
+#ifdef SUPPORT_SYSVPN
+int32_t chunk_secrets_config(chunk_t *src)
+{
+    uint8_t conf_buf[MAX_SECRETS_LEN];
+    memset_s(conf_buf, MAX_SECRETS_LEN, 0, MAX_SECRETS_LEN);
+    int32_t len = GetSysVpnCertUri(L2TP_IPSEC_SECRETS_CONF, conf_buf, MAX_SECRETS_LEN);
+    if (len > 0) {
+        src->ptr = malloc(len);
+        if (!src->ptr) {
+            src->len = 0;
+            return 0;
+        }
+        memcpy(src->ptr, conf_buf, len);
+        src->len = len;
+    } else {
+		src->len = 0;
+		src->ptr = NULL;
+	}
+	return len;
+}
+
+void chunk_secrets_config_clear(chunk_t *src, int32_t len)
+{
+	if (!src) {
+		return;
+	}
+	if (src->ptr) {
+		if (src->len == 0) {
+			src->ptr -= len;
+		}
+		free(src->ptr);
+		src->ptr = NULL;
+		src->len = 0;
+	}
+}
+#endif /* SUPPORT_SYSVPN */
+
+
 /**
  * reload ipsec.secrets
  */
@@ -1205,7 +1248,17 @@ static void load_secrets(private_stroke_cred_t *this, mem_cred_t *secrets,
 	chunk_t *src, line;
 
 	DBG1(DBG_CFG, "loading secrets from '%s'", file);
+#ifdef SUPPORT_SYSVPN
+	chunk_t chunk;
+	int32_t len = chunk_secrets_config(&chunk);
+	if (chunk.len == 0) {
+		src = NULL;
+	} else {
+		src = &chunk;
+	}
+#else
 	src = chunk_map(file, FALSE);
+#endif // SUPPORT_SYSVPN
 	if (!src)
 	{
 		DBG1(DBG_CFG, "opening secrets file '%s' failed: %s", file,
@@ -1375,7 +1428,11 @@ static void load_secrets(private_stroke_cred_t *this, mem_cred_t *secrets,
 			break;
 		}
 	}
+#ifdef SUPPORT_SYSVPN
+	chunk_secrets_config_clear(src, len);
+#else
 	chunk_unmap_clear(src);
+#endif // SUPPORT_SYSVPN
 
 	if (level == 0)
 	{	/* replace secrets in active credential set */
diff --git a/src/libstrongswan/netmanager/include/ipc_request.h b/src/libstrongswan/netmanager/include/ipc_request.h
index 8b6573dd6..f9a2ee056 100644
--- a/src/libstrongswan/netmanager/include/ipc_request.h
+++ b/src/libstrongswan/netmanager/include/ipc_request.h
@@ -27,6 +27,8 @@ enum IpsecVpnCertType : int32_t {
     USER_CERT,
     SERVER_CERT,
     SWAN_CTL_CONF,
+    OPTIONS_L2TP_CLIENT_CONF,
+    L2TP_IPSEC_SECRETS_CONF,
 };
 
 int32_t NotifyConnectStage(char *stage, int32_t state);
-- 
2.34.1

